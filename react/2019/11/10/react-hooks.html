<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>React Hooks 톺아보기 | 예제를 통한 React Hooks | Martin</title><meta name="keywords" content="'React, React Hooks',  React Hooks, 리액트 hooks, React16.8, "><meta name="description" content="React Hooks 학습해보기, 예제를 통한 React Hooks,React Hooks 톺아보기"><meta property="og:image" content="/images/react/react-hooks00.png"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="Martin"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.martinwork.co.kr/react/2019/11/10/react-hooks.html"><link rel="icon" type="image/png" href="/images/favicon/favicon-32x32.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="프론트엔드 개발자 Martin의 사적인 블로그"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-109243056-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-109243056-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="프론트엔드 개발자 Martin의 사적인 블로그" alt="프론트엔드 개발자 Martin의 사적인 블로그"><img src="/images/bg/logo_white_text.png" alt="프론트엔드 개발자 Martin의 사적인 블로그"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/react/react-hooks00.png" alt="React Hooks 톺아보기"></div><header class="post__info"><h1 class="post__title">React Hooks 톺아보기</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://github.com/martinYounghoonKim">Martin</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-11-10</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/react-react-hooks/">React, React Hooks</a></li></ul></div></div></header><div class="post__content"><h2 id="React-Hooks-톺아보기"><a href="#React-Hooks-톺아보기" class="headerlink" title="React Hooks 톺아보기"></a>React Hooks 톺아보기</h2><p>React 에는 Class 컴포넌트와 Functional 컴포넌트 등 총 2가지 형태로 구분하여 컴포넌트를 작성할 수 있다. 과거 처음 React를 이용하여 개발을 시작할 때는 Functional 컴포넌트가 Presentation 컴포넌트이자, Stateless 컴포넌트이고, Class 컴포넌트가 Container 컴포넌트이자, Stateful 컴포넌트라고 생각하였다. 하지만 공부 안한 나의 잘못된 지식을 가지고 있었다는 걸을 탓하며, Class 컴포넌트도 Presentation 컴포넌트가 될 수 있고, Functional 컴포넌트도 Container 컴포넌트가 될 수가 있었던 걸 깨달았다. 이에 또 Hooks라는 또다른 기술부채가 쌓이는 상황이 발생하게 되었다. 이참에 쌓인 기술 부채의 일부를 청산해보가 학습해보게 되었다.</p><h3 id="Hooks의-개요"><a href="#Hooks의-개요" class="headerlink" title="Hooks의 개요"></a>Hooks의 개요</h3><p>일단 Class 컴포넌트 형태로도 작성할 수 있는 데도 불구하고 Hooks를 사용하는 얻는 이점이 뭔지를 살펴보고자 한다.</p><h4 id="1-Stateful-코드를-재사용하기가-힘들다"><a href="#1-Stateful-코드를-재사용하기가-힘들다" class="headerlink" title="1. Stateful 코드를 재사용하기가 힘들다."></a>1. Stateful 코드를 재사용하기가 힘들다.</h4><p>Class 컴포넌트로 작성하게 되면 컴포넌트 간의 코드 재사용성을 위해 HOC(고차함수 컴포넌트) 혹은 render props 형태로 작성해야만 했다. 하지만 이러한 코드의 경우 일단 첫번째는 코드가 다소 직관적이지 않다는 단점이 있으며, React devtools에서 디버깅을 하게 되는 경우 아래와 같이 Wrapper Hell 에 빠지는 것을 쉽게 볼 수 있다.</p><p><img src="/images/react/react-hooks01.png" alt="React Wrapper hell"></p><p>하지만 Hooks는 컴포넌트의 계층 구조와는 상관없이 코드의 재사용성을 높여준다. 이러한 점은 Custom Hooks를 이용하여 이점을 극대화 시킬 수 있다.</p><h4 id="2-Class-컴포넌트의-로직을-관심사에-따라-분리할-수-있다"><a href="#2-Class-컴포넌트의-로직을-관심사에-따라-분리할-수-있다" class="headerlink" title="2. Class 컴포넌트의 로직을 관심사에 따라 분리할 수 있다."></a>2. Class 컴포넌트의 로직을 관심사에 따라 분리할 수 있다.</h4><p>Class 컴포넌트로 컴포넌트를 작성하다보면 각각의 생명 주기(Life cycle) 안에서 여러가지 로직을 추가하는 경우가 있다. 예를 들어 componentDidMount 훅에서는 컴포넌트에 필요한 초기 데이터를 위한 API를 호출하거나 EventListener 를 등록 해줄 수 있다. 뿐만 아니라 이렇게 설정된 데이터 혹은 EventListener 들은 componentWillUnmount 훅에서 제거하거나 데이터를 초기화 해줄 수 있다. 이러한 부분들이 컴포넌트의 생명주기 메소드 내의 가독성과 관심사 분리를 해칠 수 있으며, 이에 따라 버그나 무결성을 해칠 수 있는 여지가 충분하다.</p><p>이러한 이유로 인해 간단하게 작성되기 시작한 Class 컴포넌트도 시간에 따라 점점 더 비대해지며, 정작 중요한 비즈니스 코드가 눈에 한 눈에 들어오지 않게 되는 경우가 발생하게 된다. 관심사별 비즈니스 코드를 분리하기 위해 Redux나 Mobx와 같은 상태 관리 라이브러리를 사용해야 하는 경우가 생긴다. 이러한 문제점에 대해 Hooks는 로직 별로 작은 단위에 컴포넌트에 집중할 수 있는 해결점을 제공해준다.</p><h4 id="3-Class-문법에-대한-진입-장벽을-낮춘다"><a href="#3-Class-문법에-대한-진입-장벽을-낮춘다" class="headerlink" title="3. Class 문법에 대한 진입 장벽을 낮춘다."></a>3. Class 문법에 대한 진입 장벽을 낮춘다.</h4><p>개인적으로는 React에 대한 진입 장벽은 JSX 문법이라고만 생각을 해왔는데, React 공식 문서에 따르면 React 에 대한 진입 장벽 중 하나로 Class 문법을 언급하고 있다. Class로 컴포넌트를 설계하게 되면 this를 이해하지 못하고서는 사용하기가 힘들다. 그래서 bind 메소드를 이용한 this를 바인딩하는 등의 여러가지 작업을 해줘야하는 경우가 있다. 마찬가지로 props, state 혹은 Class 컴포넌트 내의 메소드들을 참조할때도 항상 this 에 대한 스코프가 유지되어야 한다.</p><p>하지만 Hooks의 경우 Functional 컴포넌트 내에서 사용되기 때문에 Class 컴포넌트에 대한 this 장벽을 허물 수 있다는 장점을 가진다. 이뿐만 아니고도 Class 컴포넌트의 경우는 Tree shaking이 원활하게 지원되지 않는 등의 문제를 해결할 수 있다고 있다.</p><p>관련된 자세한 내용은 <a href="https://reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener">공식 문서의 Motivation</a>에서 확인할 수 있다.</p><h3 id="Hooks이란-무엇인가"><a href="#Hooks이란-무엇인가" class="headerlink" title="Hooks이란 무엇인가?"></a>Hooks이란 무엇인가?</h3><p>Hooks는 Functional 컴포넌트도 Hooks를 이용하여 Stateful 컴포넌트가 될 수 있도록 만들어 준다. 리액트의 공식 문서를 살펴보면 다음과 같은 문구를 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Effect Hook lets you perform side effects in function components</span><br></pre></td></tr></table></figure><p>여기에서 이야기하는 <code>side effects</code> 이란, 데이터를 받아오거나, 데이터를 구독하거나 혹은 DOM을 직접 조작하는 행위를 말한다고 한다. 본격적으로 Hooks에 대해서 살펴보도록 하자.</p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>일단 기본적으로 사용하는 문법은 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, counting] = useState(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt; &#123;count&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useState 의 인자로는 상태의 초깃값을 주입해줄 수 있으며, 초기값은 Primitive 타입 혹은 Object 타입 상관없이 주입할 수 있다. 이 초기값은 처음 컴포넌트가 랜더링될 경우에만 사용되며, 이후부터는 useState에서 반환하는 Setter 함수를 통해 변경된 값이 State 에 담긴다. useState의 인터페이스를 살펴보면 다음과 같이 되어 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a stateful value, and a function to update it.</span><br><span class="line"> *</span><br><span class="line"> * @version experimental</span><br><span class="line"> * @see https://reactjs.org/docs/hooks-reference.html#usestate</span><br><span class="line"> */</span><br><span class="line">function useState&lt;S&gt;(initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];</span><br></pre></td></tr></table></figure><p>useState는 제네릭 타입 S(initialState)를 인자로 받은 후, 튜플 타입으로 첫번째 값은 State를 반환하며 두번째 값으로는 State를 업데이트할 수 있는 Dispatch 함수를 반환한다. 여기에서 중요한 것은 Dispatch 함수는 Redux의 Dispatch 함수가 아닌 리액트의 인터페이스에 정의되어 있는 Void 타입의 함수이다.</p><p>위의 인터페이서에서 살펴볼 수 있듯, useState 는 State와 Dispatch 함수로 이뤄진 배열을 반환하기 때문에 useState를 사용할 때 <code>구조 분해 할당 구문</code>을 통하여 다음과 같이 사용할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, addCount] = useState(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>시간을 카운팅하는 코드를 먼저 Class 컴포넌트 형태로 작성하게 되면 다음과 같이 작성할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 최초 컴포넌트가 실행될 때, setState를 일으킨다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>:  <span class="keyword">this</span>.state.count - <span class="number">1</span>&#125;), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="comment">// 이후 state의 변화에 따라 setState를 지속적으로 일으킨다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>:  <span class="keyword">this</span>.state.count - <span class="number">1</span>&#125;), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Class 컴포넌트는 처음 컴포넌트가 마운트되며 setTimeout 함수를 한번 실행할 것 이다. 이후 State 값이 변경됨에 따라 setTimeout 함수가 재호출되며 render 함수를 통해 DOM이 리랜더링 된다.</p><p>하지만 이 코드를 Functional 컴포넌트의 useState를 이용하여 작성하면 다음과 같이 작성할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, counting] = useState(<span class="number">10</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> counting(count<span class="number">-1</span>), <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt; &#123;count&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Functional 컴포넌트는 컴포넌트가 랜더링되며 setTimeout 함수를 반복적으로 호출하는 형태로 작성되어진다.</p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>useState Hook을 사용 하다보면 상황에 따라 Class 컴포넌트의 <code>componentDidMount, componentDidUpdate, componentWillUnmount</code> 등과 같은 특정 상황에 Lifecycle 안에서 특정 로직을 실행시켜 줘야 하는 경우가 있다. 예를 들어 컴포넌트가 마운트되었을 때 컴포넌트에 필요한 초기 데이터를 API를 호출을 통해 받아와야 한다던지, 혹은 DOM에 EventListener를 등록하거나 언마운트될 때 등록된 EventListener를 해제해줘야하는 상황이 있다. 이러한 경우 <code>useEffect</code>를 이용한다면 Class 컴포넌트에서 제공해주는 생명주기 API들을 Functional 컴포넌트에서도 마찬가지로 사용할 수 있다.</p><p>공식 문서를 살펴보면 팁으로 다음과 같이 정보를 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tip</span><br><span class="line"></span><br><span class="line">If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.</span><br></pre></td></tr></table></figure><p>이 말인 즉, Hook의 useEffect를 잘 이해하여 사용한다면 Class 컴포넌트의 componentDidMount, componentDidUpdate, componentWillUnmount 메소드들과 같은 효과를 볼 수 있다는 것이다. 먼저 useEffect 함수의 인터페이스를 살펴보도록 하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Accepts a function that contains imperative, possibly effectful code.</span><br><span class="line"> *</span><br><span class="line"> * @param effect Imperative function that can return a cleanup function</span><br><span class="line"> * @param inputs If present, effect will only activate if the values in the list change.</span><br><span class="line"> *</span><br><span class="line"> * @version experimental</span><br><span class="line"> * @see https://reactjs.org/docs/hooks-reference.html#useeffect</span><br><span class="line"> */</span><br><span class="line">function useEffect(effect: EffectCallback, inputs?: InputIdentityList): void;</span><br><span class="line"></span><br><span class="line">// InputIdentityList 은 아래와 같이 정의되고 있다.</span><br><span class="line">// type InputIdentityList = ReadonlyArray&lt;any&gt;;</span><br></pre></td></tr></table></figure><p>useEffect 함수는 EffectCallback 함수를 인자로 받으며, 두번째 인자로는 state값의 배열을 받는다. 여기에서 우리가 주의깊게 봐야할 것은 첫번째 인자인 EffectCallback 은 Mandatory 값이며, 두번째 인자인 InputIndetiryList는 optional 값이라는 것이다. 만약 InputIdentityList 값이 변경된다면 EffectCallback 함수가 실행될 것이다.</p><p>useEffect로 작성된 컴포넌트를 살펴보기 전에 먼저 우리에게 익숙한 Class 컴포넌트로 해당하는 상황을 살펴보면 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; user &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.state.user) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">        &lt;dt&gt;&#123;this.state.user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">        &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">        &lt;dt&gt;&#123;this.state.user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>처음 컴포넌트가 마운트될 때 fetchUser 라는 API 함수를 호출한다. 그 후, 받아온 user의 데이터를 setState를 이용하여 state에 저장을 해주는 형태이다. 이러한 코드를 useEffect 를 이용하여 변경하면 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">      setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); <span class="comment">// &lt;- 빈 배열임을 꼭 기억해야 한다.</span></span><br><span class="line">  <span class="keyword">return</span> user &amp;&amp; (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">    &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useEffect 함수가 실행되는 시점은 컴포넌트가 처음 마운트되는 시점을 포함하여 컴포넌트가 리랜더링된 이후 매번 실행된다. 하지만 위에서 설명했듯 만약 두번째 인자에 배열 형태의 값을 넣게 되면 useEffect의 콜백함수는 배열의 값에 변화가 있을 경우 실행될 것이다. 위의 예제를 살펴보면 useEffect의 두번째 인자로 빈 배열을 넣어주었는데, 빈 배열을 넣어주게 되면 더이상의 변화가 없기 때문에 EffectCallback 함수는 처음 컴포넌트가 마운트될 때 한번 실행될 것이다. 만약 이것을 감안하지 않고 아래와 같이 인자를 던지지 않으면 DOM이 변경되면서 useEffect 함수가 실행되며 계속 API를 호출하는 상황이 발생할 것이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">      setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;); <span class="comment">// &lt;- InputIdentityList를 넣어주지 않으면 계속해서 fetchData 함수가 실행되는 상황이 생긴다.</span></span><br><span class="line">  <span class="keyword">return</span> user &amp;&amp; (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">    &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>빈 배열이 아닌 아래와 같이 작성한다면 user 데이터가 변경될 때마다 useEffect의 콜백함수가 실행될 것이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"User State changed!"</span>)</span><br><span class="line">&#125;, [user])</span><br></pre></td></tr></table></figure><p>그렇다면 해제 함수를 실행 시켜줘야 할때는 어떻게 해야할까? 그런 경우는 아래와 같이 EffectCallBack 함수에서 해제 함수를 반환해주면 된다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 해제 함수. </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이러한 해제 함수는 컴포넌트가 언마운트될 때 뿐만 아니라, 재랜더링될때도 마찬가지로 실행된다. 만약 언마운트될 때만 실행시켜주고자 한다면 위에서와 같이 두번째 인자를 빈 배열로 주입하게 되면 useEffect 의 EffectCallback 함수는 처음 마운트 될 때 한 번, 언마운드 될때 한번 해서 두번만 실행되며 DOM이 업데이트 되지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Component did mount"</span>);</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">    setUser(user);</span><br><span class="line">  &#125;</span><br><span class="line">  fetchData();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Component will unmount."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h3><p>이 외에도 useContext나 useReducer 같은 또다른 Hook들도 있으며, 필요에 따라 상황에 맞게 사용하면 되지 않을까 한다. 다만 사용하기 전에 대략적으로나마 동작하는 방식에 대해 이해하고 있어야 문제가 생겼을 때 문제를 해결할 수 있지 않을까라고 생각한다.</p><div class="post-announce">현재 이커머스회사에서 frontend 개발자로 업무를 진행하고 있는 <a href="https://github.com/martinYounghoonKim">Martin</a> 입니다. 글을 읽으시고 궁금한 점은 댓글 혹은 메일(hoons0131@gmail.com)로 연락해주시면 빠른 회신 드리도록 하겠습니다. 이 외에도 네트워킹에 대해서는 언제나 환영입니다.：Martin（<a href="https://github.com/martinYounghoonKim">https://github.com/martinYounghoonKim</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/nodejs/2019/09/20/nodejs-with-typescript02.html" title="Typescript와 NodeJS를 이용한 간단한 목킹 서버 띄우기 02"><i class="iconfont icon-prev"></i>Typescript와 NodeJS를 이용한 간단한 목킹 서버 띄우기 02</a></div><div class="post__prev post__prev--right"><a href="/kotlin/2019/11/24/nothing-type-in-kotlin.html" title="Kotlin의 Nothing 타입">Kotlin의 Nothing 타입<i class="iconfont icon-next"></i></a></div></div></div></article><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6986373452203090" data-ad-slot="3762948283" data-ad-format="auto" data-full-width-responsive="true"></ins><script>window.onload=function(){(adsbygoogle=window.adsbygoogle||[]).push({})}</script><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">E-Commerce에서 Front-end 개발을 하고 있는 마틴입니다. 안정성 있는 서비스 구축과 TDD 프로그래밍에 관심이 많으며, 긍정적인 네트워킹에 대해서도 언제나 환영입니다. 저와의 네트워킹을 원하시는 분은 언제든 편하게 SNS나 게시글의 댓글 혹은 이메일을 통해 연락주시면 최대한 빨리 회신드리도록 하겠습니다:)</p></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">theory</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/webpack/">Webpack</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/vuejs/">VueJS</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/unit-test/">Unit Test</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/typescript/">Typescript</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/theory/">Theory</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/review/">Review</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/reactjs/">ReactJS</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/react/">React</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/nodejs/">NodeJS</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/mysql/">Mysql</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/kotlin/">Kotlin</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/javascript/">Javascript</a><span class="block-list-count">15</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/devops/">Devops</a><span class="block-list-count">10</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/ai/">AI</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/review/2020/01/07/remembrance-in-2019.html" title="2019년의 회고"><div class="item__cover"><img src="/images/review/retro.jpg" alt="2019년의 회고"></div><div class="item__info"><h3 class="item__title">2019년의 회고</h3><span class="item__text">2020-01-07</span></div></a></li><li class="latest-post-item"><a href="/theory/2019/12/15/ipv4-address.html" title="IPv4 주소 체계"><div class="item__cover"><img src="/images/theory/ipv4-address00.png" alt="IPv4 주소 체계"></div><div class="item__info"><h3 class="item__title">IPv4 주소 체계</h3><span class="item__text">2019-12-15</span></div></a></li><li class="latest-post-item"><a href="/kotlin/2019/11/24/nothing-type-in-kotlin.html" title="Kotlin의 Nothing 타입"><div class="item__cover"><img src="/images/kotlin/kotlin.png" alt="Kotlin의 Nothing 타입"></div><div class="item__info"><h3 class="item__title">Kotlin의 Nothing 타입</h3><span class="item__text">2019-11-24</span></div></a></li><li class="latest-post-item"><a href="/react/2019/11/10/react-hooks.html" title="React Hooks 톺아보기"><div class="item__cover"><img src="/images/react/react-hooks00.png" alt="React Hooks 톺아보기"></div><div class="item__info"><h3 class="item__title">React Hooks 톺아보기</h3><span class="item__text">2019-11-10</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/2018회고/">2018회고</a></li><li class="tag-item"><a class="tag-link" href="/tags/2019회고-coupang-쿠팡/">2019회고, Coupang, 쿠팡</a></li><li class="tag-item"><a class="tag-link" href="/tags/ai/">AI</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws/">AWS</a></li><li class="tag-item"><a class="tag-link" href="/tags/aws-s3/">AWS S3</a></li><li class="tag-item"><a class="tag-link" href="/tags/array/">Array</a></li><li class="tag-item"><a class="tag-link" href="/tags/authenticate/">Authenticate</a></li><li class="tag-item"><a class="tag-link" href="/tags/awwwards-2018/">Awwwards 2018</a></li><li class="tag-item"><a class="tag-link" href="/tags/back-end/">Back-end</a></li><li class="tag-item"><a class="tag-link" href="/tags/backend/">Backend</a></li><li class="tag-item"><a class="tag-link" href="/tags/binary-search/">Binary Search</a></li><li class="tag-item"><a class="tag-link" href="/tags/csr/">CSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/chai/">Chai</a></li><li class="tag-item"><a class="tag-link" href="/tags/chrome-extension/">Chrome extension</a></li><li class="tag-item"><a class="tag-link" href="/tags/clean-code/">Clean code</a></li><li class="tag-item"><a class="tag-link" href="/tags/commonjs/">CommonJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/conference/">Conference</a></li><li class="tag-item"><a class="tag-link" href="/tags/cookie/">Cookie</a></li><li class="tag-item"><a class="tag-link" href="/tags/database/">Database</a></li><li class="tag-item"><a class="tag-link" href="/tags/dev-ops/">Dev-ops</a></li><li class="tag-item"><a class="tag-link" href="/tags/devops/">Devops</a></li><li class="tag-item"><a class="tag-link" href="/tags/docker/">Docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/ecma-script/">ECMA script</a></li><li class="tag-item"><a class="tag-link" href="/tags/eslint/">Eslint</a></li><li class="tag-item"><a class="tag-link" href="/tags/express/">Express</a></li><li class="tag-item"><a class="tag-link" href="/tags/first-class-object/">First Class Object</a></li><li class="tag-item"><a class="tag-link" href="/tags/flux/">Flux</a></li><li class="tag-item"><a class="tag-link" href="/tags/google-cloud-platform/">Google Cloud Platform</a></li><li class="tag-item"><a class="tag-link" href="/tags/hash-table/">Hash table</a></li><li class="tag-item"><a class="tag-link" href="/tags/ipv4-network-ip/">IPv4, Network, IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/immutablejs/">ImmutableJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt/">JWT</a></li><li class="tag-item"><a class="tag-link" href="/tags/jwt-token/">JWT Token</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript/">Javascript</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-framework/">Javascript Framework</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-method/">Javascript Method</a></li><li class="tag-item"><a class="tag-link" href="/tags/javascript-디자인-패턴/">Javascript 디자인 패턴</a></li><li class="tag-item"><a class="tag-link" href="/tags/karma/">Karma</a></li><li class="tag-item"><a class="tag-link" href="/tags/linear-regression/">Linear Regression</a></li><li class="tag-item"><a class="tag-link" href="/tags/list/">List</a></li><li class="tag-item"><a class="tag-link" href="/tags/machine-learning/">Machine learning</a></li><li class="tag-item"><a class="tag-link" href="/tags/mocha/">Mocha</a></li><li class="tag-item"><a class="tag-link" href="/tags/moment/">Moment</a></li><li class="tag-item"><a class="tag-link" href="/tags/momentjs/">MomentJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/mongodb/">MongoDB</a></li><li class="tag-item"><a class="tag-link" href="/tags/mysql/">Mysql</a></li><li class="tag-item"><a class="tag-link" href="/tags/naver-tech-concert/">Naver Tech Concert</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">NodeJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/nodejs/">Nodejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/nothing타입-코틀린-kotlin/">Nothing타입, 코틀린, Kotlin</a></li><li class="tag-item"><a class="tag-link" href="/tags/oop-programming/">OOP Programming</a></li><li class="tag-item"><a class="tag-link" href="/tags/prototype/">Prototype</a></li><li class="tag-item"><a class="tag-link" href="/tags/queue/">Queue</a></li><li class="tag-item"><a class="tag-link" href="/tags/react-react-hooks/">React, React Hooks</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs/">ReactJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/reactjs-lifecycle/">ReactJS lifecycle</a></li><li class="tag-item"><a class="tag-link" href="/tags/reflow-and-repaint/">Reflow and Repaint</a></li><li class="tag-item"><a class="tag-link" href="/tags/requirejs/">RequireJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/restful-api/">Restful API</a></li><li class="tag-item"><a class="tag-link" href="/tags/review/">Review</a></li><li class="tag-item"><a class="tag-link" href="/tags/solid-원칙/">SOLID 원칙</a></li><li class="tag-item"><a class="tag-link" href="/tags/ssr/">SSR</a></li><li class="tag-item"><a class="tag-link" href="/tags/san-francisco/">San francisco</a></li><li class="tag-item"><a class="tag-link" href="/tags/sentry/">Sentry</a></li><li class="tag-item"><a class="tag-link" href="/tags/session/">Session</a></li><li class="tag-item"><a class="tag-link" href="/tags/stack/">Stack</a></li><li class="tag-item"><a class="tag-link" href="/tags/tmon/">TMON</a></li><li class="tag-item"><a class="tag-link" href="/tags/tensorflow/">TensorFlow</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree/">Tree</a></li><li class="tag-item"><a class="tag-link" href="/tags/tree-node/">Tree Node</a></li><li class="tag-item"><a class="tag-link" href="/tags/typescript/">Typescript</a></li><li class="tag-item"><a class="tag-link" href="/tags/umd/">UMD</a></li><li class="tag-item"><a class="tag-link" href="/tags/unit-test/">Unit test</a></li><li class="tag-item"><a class="tag-link" href="/tags/util-type/">Util type</a></li><li class="tag-item"><a class="tag-link" href="/tags/vitual-dom/">Vitual Dom</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuejs/">Vuejs</a></li><li class="tag-item"><a class="tag-link" href="/tags/vuex/">Vuex</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack/">Webpack</a></li><li class="tag-item"><a class="tag-link" href="/tags/webpack-hmr/">Webpack HMR</a></li><li class="tag-item"><a class="tag-link" href="/tags/withinnovation/">Withinnovation</a></li><li class="tag-item"><a class="tag-link" href="/tags/d-ts/">d.ts</a></li><li class="tag-item"><a class="tag-link" href="/tags/interface/">interface</a></li><li class="tag-item"><a class="tag-link" href="/tags/네이버콘서트/">네이버콘서트</a></li><li class="tag-item"><a class="tag-link" href="/tags/멋쟁이-사자처럼/">멋쟁이 사자처럼</a></li><li class="tag-item"><a class="tag-link" href="/tags/소프트스킬/">소프트스킬</a></li><li class="tag-item"><a class="tag-link" href="/tags/스타트업/">스타트업</a></li><li class="tag-item"><a class="tag-link" href="/tags/스택오버플로우/">스택오버플로우</a></li><li class="tag-item"><a class="tag-link" href="/tags/애자일/">애자일</a></li><li class="tag-item"><a class="tag-link" href="/tags/여기어때/">여기어때</a></li><li class="tag-item"><a class="tag-link" href="/tags/유틸-타입/">유틸 타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/인생전략71가지/">인생전략71가지</a></li><li class="tag-item"><a class="tag-link" href="/tags/인피니티-스크롤/">인피니티 스크롤</a></li><li class="tag-item"><a class="tag-link" href="/tags/제네릭타입/">제네릭타입</a></li><li class="tag-item"><a class="tag-link" href="/tags/최고의집합/">최고의집합</a></li><li class="tag-item"><a class="tag-link" href="/tags/커피한잔마시며-끝내는-vuejs/">커피한잔마시며 끝내는 VueJS</a></li><li class="tag-item"><a class="tag-link" href="/tags/콜스택/">콜스택</a></li><li class="tag-item"><a class="tag-link" href="/tags/타입스크립트/">타입스크립트</a></li><li class="tag-item"><a class="tag-link" href="/tags/티모니언/">티모니언</a></li><li class="tag-item"><a class="tag-link" href="/tags/티켓몬스터/">티켓몬스터</a></li><li class="tag-item"><a class="tag-link" href="/tags/프로그래머스/">프로그래머스</a></li><li class="tag-item"><a class="tag-link" href="/tags/하노이탑알고리즘/">하노이탑알고리즘</a></li><li class="tag-item"><a class="tag-link" href="/tags/해커톤/">해커톤</a></li><li class="tag-item"><a class="tag-link" href="/tags/호텔타임/">호텔타임</a></li><li class="tag-item"><a class="tag-link" href="/tags/회고/">회고</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">Martin(Younghoon Kim)</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Seoul, South Korea</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>hoons0131@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/images/bg/avatar.png" alt="logo" title="프론트엔드 개발자 Martin의 사적인 블로그"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/martinyounghoonkim" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:hoons0131@gmail.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li><li class="social-network__item"><a href="https://www.linkedin.com/in/younghoon-kim-2a1530149/" target="_blank" title="linkedin"><i class="iconfont icon-in"></i></a></li><li class="social-network__item"><a href="https://www.facebook.com/profile.php?id=100005693104994" target="_blank" title="facebook"><i class="iconfont icon-facebook"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="blog-martinwork-co-kr",disqus_config=function(){this.page.url="http://blog.martinwork.co.kr/react/2019/11/10/react-hooks.html",this.page.identifier="/react/2019/11/10/react-hooks.html",this.page.title="React Hooks 톺아보기"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>