<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>프론트엔드 개발자 Martin의 사적인 블로그</title>
  
  <subtitle>Martin</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://blog.martinwork.co.kr/"/>
  <updated>2020-03-24T08:13:59.746Z</updated>
  <id>http://blog.martinwork.co.kr/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01. NestJS란</title>
    <link href="http://blog.martinwork.co.kr/nestjs/2020/03/22/what-is-nestjs.html"/>
    <id>http://blog.martinwork.co.kr/nestjs/2020/03/22/what-is-nestjs.html</id>
    <published>2020-03-22T14:21:51.000Z</published>
    <updated>2020-03-24T08:13:59.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-NestJS란"><a href="#01-NestJS란" class="headerlink" title="01. NestJS란"></a>01. NestJS란</h2><p>NodeJS 진영에도 여러개의 프레임워크가 있다. 그 중 가장 대표적인 것이 Express 라고 볼 수 있다. Express 를 이용하여 개발을 하다보면 항상 아쉬웠던 부분은 프레임워크 안에서 지원해주는 것이 너무 적으며, 하다못해 Typescript를 사용하려고 해도 설정을 개발자가 직접 설정해줘야 한다는 점에서 많은 골치가 아팠다. 그러던 중, 예전 직장 동료가 이야기했던 NestJS에 대해 떠올리게 되었고, 튜터리얼을 살펴보면 중 Springboot와 많은 점에서 유사하다는 것을 느낄 수 있으며, 기본적으로 Typescript를 지원한다는 것을 알 수 있다. 그래서 이참에 현재 진행하고 있는 사이드 프로젝트의 Front-end 서버는 NestJS를 이용하여 구축해보기로 하였다. </p><p>일단 NestJS는 기본적으로 Typescript를 지원하며 Javascript로 애플리케이션을 작성하는 것도 가능하다. 뿐만 아니라 OOP(Object Oriented Programming), FP(Functional Programming), FRP(Functional Reactive Programming) 등등 좋은 키워드는 모두 나온다. 이 중에서 NestJS를 사용해야겠다 라는 생각을 하게된 결정적인 이유는 OOP, 즉 객체 지향 프로그래밍이었다.</p><p><img src="/images/nestjs/nestjs01.png" alt="OOP"></p><p>NestJS는 NodeJS 프레임워크인 Express나 Fastify 등의 API를 직접 사용할 수도 있으며 혹은 NestJS 에서 제공하는 추상화된 인터페이스를 이용할 수도 있다. 이러한 NestJS는 Angular로부터 영감을 받아 만들어졌다. 일단 제일 Javascript와 Typescript를 이용하여 주로 개발하는 나로서는 Frontend코드와 Backend코드를 하나의 언어로 작성할 수 있다는 점이 가장 큰 장점이었다. 무엇보다 항상 제일 고민이었던 부분은 Typescript를 이용하여 개발을 하다보니 항상 생기는 서버 애플리케이션과의 Model 타입에 대한 불일치였는데, NestJS를 이용하여 개발을 하면 이러한 부분에 대해서 해결할 수 있을 것 같다는 생각을 하였다.</p><p>요즘 대부분의 라이브러리나 프레임워크에서 제공해주듯 NestJS 역시 CLI를 통해 프로젝트 스케폴딩을 쉽게 할 수 있다. 셋팅하기에 앞서 @nestjs/cli가 Global로 설치가 되어있어야 하나 혹여라도 전역에 설치하기 싫다면 npx를 이용하여 셋팅을 해도 될 것 같으며, 아예 디펜던시부터 하나 하나 설치하여 진행하는 방법도 있다.</p><p>일단 나는 Next와 함께 이용하여 사용할 예정이기 때문에 프로젝트의 이름은 nest-next-typescript로 지었다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g @nestjs/cli</span><br><span class="line">$ nest new nest-next-typescript</span><br></pre></td></tr></table></figure></p><p>프로젝트가 생성된 후 각각의 디렉토리를 살펴보면 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">     ├── app.controller.ts</span><br><span class="line">     ├── app.service.ts</span><br><span class="line">     ├── app.module.ts</span><br><span class="line">     ├── main.ts</span><br></pre></td></tr></table></figure><p>기본적으로 생성되는 단일 컨트롤러 파일(app.controller.ts)과 간단한 텍스트를 요청한 controller에 전달해주는 서비스 파일(app.service.ts), 그리고 애플리케이션 내의 모듈을 설정하는 파일(app.module.ts) 그리고 에플리케이션의 엔트리 파일(main.ts) 등이 생긴다. controller나 module, 엔트리 파일의 경우에는 익숙하겠지만, service 파일에 경우에는 개념이 조금 헷갈릴 수 있다. 이에 대해서는 뒤에서 별도로 설명하며, 지금은 아래의 사진과 같이 비즈니스 로직을 처리하는 비즈니스 레이어 정도로만 이해하고 넘어가도록 하자.</p><p><img src="/images/nestjs/nestjs02.png" alt="비즈니스 레이어와 프레젠테이션 레이어"></p><p>이 중 엔트리 파일을 살펴보면 안에 NestJS 애플리케이션 인스턴스를 만드는 각각의 설정 값들이 bootstrap 함수 안에서 실행되는 것을 볼 수 있다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure><p>구조 자체적으로 Springboot 와 동일하다는 것을 알 수 있다. 그래서인지 뭔가 앞으로도 NestJS를 좋아할 것 같다는 생각이 든다. 일단은 폴더링에 대한 큰 고민 없이 Springboot 애플리케이션과 동일하게 가져가도 좋지 않을까 싶다.</p>]]></content>
    
    <summary type="html">
    
      NodeJS 프레임워크 NestJS에 대해서 살펴보도록 하자.
    
    </summary>
    
      <category term="NestJS" scheme="http://blog.martinwork.co.kr/categories/nestjs/"/>
    
    
      <category term="NestJS" scheme="http://blog.martinwork.co.kr/tags/nestjs/"/>
    
      <category term="NodeJS Framework" scheme="http://blog.martinwork.co.kr/tags/nodejs-framework/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL 데이터 타입</title>
    <link href="http://blog.martinwork.co.kr/mysql/2020/01/17/mysql-data-type.html"/>
    <id>http://blog.martinwork.co.kr/mysql/2020/01/17/mysql-data-type.html</id>
    <published>2020-01-16T15:50:51.000Z</published>
    <updated>2020-01-18T15:27:06.197Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 MYSQL의 데이터 타입에 대해서 살펴본다. MYSQL에는 크게 4가지의 데이터 타입이 존재하며, 각각의 특징과 범위 그리고 저장 가능한 사이즈가 다르다. 데이터 타입을 살펴보고 상황에 따라 테이블을 생성할 때 어떤 타입이 필요한지 고민해보도록 하자.</p><h3 id="숫자형-데이터-타입"><a href="#숫자형-데이터-타입" class="headerlink" title="숫자형 데이터 타입"></a>숫자형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>범위</th><th>UNSIGNED 사용가능 여부</th></tr></thead><tbody><tr><td>TINYINT(n)</td><td>정수형 데이터 타입</td><td>- 1 Byte(2^8)<br> - 128 ~ + 127 또는 0 ~ 255 수 표현 가능  <br>- 1Byte(2^8) <br>- 128 ~ + 127 또는 0 ~ 255 수 표현 가능</td><td>O</td></tr><tr><td>SMALLINT(n)</td><td>정수형 데이터 타입</td><td>- 2 Byte(2^16)<br> - 32,768 ~ 32,167 또는 0 ~ 65536수 표현 가능</td><td>O</td></tr><tr><td>MEDIUMINT(n)</td><td>정수형 데이터 타입</td><td>- 3 Byte<br> - 8,388,608 ~ 8,388,607 또는 0 ~ 16,777,215 수 표현 가능</td><td>O</td></tr><tr><td>INT(n)</td><td>정수형 데이터 타입</td><td>- 4 Byte<br> - 2,147,483,648 ~ 2,147,483,647 또는 0 4,294,967,295 수 표현 가능</td><td>O</td></tr><tr><td>BIGINT(n)</td><td>정수형 데이터 타입(LONG)</td><td>- 8 byte<br> - 2^64 - 1 표현 가능(무한 수 표현 가능이라고도 함)</td><td>O</td></tr><tr><td>DECIMAL(m, d)</td><td>- 고정 소수형 데이터 타입고정(길이+1 byte)<br> - 화폐 데이터와 같이 데이터의 정확도를 요하는 경우에 주로 사용<br> - M의 최대값은 65, D는 소수 자릿수이며 0이면 소수점 가지지 않음</td><td>- 소수점을 사용한 형태<br> - Default: m ⇒ 10</td><td>X</td></tr><tr><td>FLOAT(n)</td><td>부동 소수형 데이터 타입</td><td>- 4 byte <br>- 부동 소수점을 사용한 형태</td><td>X</td></tr><tr><td>DOUBLE(n)</td><td>부동 소수형 데이터 타입</td><td>- 8 byte <br> - DOUBLE을 문자열로 저장</td><td>X</td></tr></tbody></table><h4 id="UNSIGNED-속성"><a href="#UNSIGNED-속성" class="headerlink" title="UNSIGNED 속성"></a>UNSIGNED 속성</h4><p><code>UNSIGNED</code> 속성을 부여하게 되면 해당 속성을 부여받은 컬럼에는 <code>음수값을 대입하지 못한다</code>. 결제 내역에 대한 테이블을 예시로 들어보도록 하겠다. 결제 금액은 음수값이 될 수 없음을 누구나 알 수 있을 것이다. 이런 경우 UNSIGNED 속성을 부여하여 음수값을 대입하지 못하게 할 뿐만 아니라 대입 가능한 숫자의 범위를 늘려줄 수 있다. 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    total_consume_mount <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>작성된 payment 테이블에 음수값을 대입해보도록 하자. 아마 아래와 같이 에러가 발생하는 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment (uid, total_consume_mount)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">-100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1264 (22003): Out of range value for column 'total_consume_mount' at row 1</span></span><br></pre></td></tr></table></figure><p>또한 기존 SIGNED 속성을 가진 INT 타입에는 최대 2,147,483,647까지 대입 가능한 반면 UNSIGNED 속성을 부여하면 대입 가능한 값이 4,294,967,295까지 늘어난 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 대입 가능한 범위가 늘어남을 볼 수 있다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">4294967295</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 하지만 그 이상의 값을 대입하려 할때면 다음과 같은 에러가 발생하는 것을 확인할 수 있다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">4294967296</span>);</span><br><span class="line"><span class="comment">-- ERROR 1264 (22003): Out of range value for column 'total_consume_mount' at row 1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">#### Integer 타입의 N의 의미</span></span><br><span class="line">TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 공통적으로 MAXIMUM 값은 항상 N과는 무관하게 허용 가능한 범위는 동일하다. 그렇다면 이 N은 언제 사용하는 것일까? 그에 대한 답은 아래의 예제에서 찾을 수 있다.</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment</span><br><span class="line">(</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    total_consume_mount <span class="built_in">INT</span>(<span class="number">3</span>) ZEROFILL <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- ZEROFILL 속성을 부여한다.</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment;</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br><span class="line">| uid | total_consume_mount |</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br><span class="line">|   1 |                 001 |</span><br><span class="line">+<span class="comment">-----+---------------------+</span></span><br></pre></td></tr></table></figure><p>N 값은 ZEROFILL 속성과 함께 사용할 때 의미가 있다. 테이블을 생성할 때, ZEROFILL 속성을 주게되면 N 자릿수 이하의 값에 대해서 부여된 자리수를 항상 0으로 채운다. 만약 N 자릿수를 초과하게 되면 크게 의미가 없다. 또한 ZEROFILL 속성을 부여하게 되면 자동으로 UNSIGNED 속성이 붙게 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DESC payment;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line">| Field               | Type                     | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line">| uid                 | bigint(20)               | NO   | MUL | NULL    |       |</span><br><span class="line">| total_consume_mount | int(3) unsigned zerofill | NO   |     | 000     |       |</span><br><span class="line">+<span class="comment">---------------------+--------------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><h4 id="고정-소수형-데이터-타입-DECIMAL-과-부동-소수형-데이터-타입-FLOAT-DOUBLE"><a href="#고정-소수형-데이터-타입-DECIMAL-과-부동-소수형-데이터-타입-FLOAT-DOUBLE" class="headerlink" title="고정 소수형 데이터 타입(DECIMAL)과 부동 소수형 데이터 타입(FLOAT, DOUBLE)"></a>고정 소수형 데이터 타입(DECIMAL)과 부동 소수형 데이터 타입(FLOAT, DOUBLE)</h4><p>DECIMAL 타입과 FLOAT, DOUBLE의 가장 큰 차이점은 고정 소수형 데이터 타입이냐, 부동 소수형 데이터 타입이냐에 따라 결정되게 된다. DECIMAL 타입의 경우 앞에서 총 2개의 설정을 값을 부여할 수 있다. 아래의 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">wallet</span> (</span><br><span class="line">    uid <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    dollar <span class="built_in">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">    mileage <span class="built_in">FLOAT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dollar 컬럼에 DECIMAL(5,2)의 데이터 타입을 지정하였다. DECIMAL(M, D)에서 M에 해당하는 5의 경우 총 5자리의 숫자를 사용할 수 있다는 의미이고, D에 해당하는 2는 소수점을 2자리까지 지정하겠다라는 의미이다. 그렇다면 정수의 타입은 M-D(5-2)까지 저장할 수 있다는 것을 유추할 수 있다. 그렇게 DECIMAL(5,2) 데이터 타입의 범위는 -999.99 ~ 999.99이다.</p><p>각각의 DECIMAL과 FLOAT 타입에 동일한 데이터를 대입해보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">wallet</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="number">10.91</span>, <span class="number">10.91</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">wallet</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="number">10.91</span>, <span class="number">10.91</span>);</span><br></pre></td></tr></table></figure><p>값을 값을 대입한 후, 조회를 해보면 값은 값이 저장된 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">wallet</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br><span class="line">| user_id | dollar | mileage |</span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br><span class="line">|       1 |  10.91 |   10.91 |</span><br><span class="line">|       2 |  10.91 |   10.91 |</span><br><span class="line">+<span class="comment">---------+--------+---------+</span></span><br></pre></td></tr></table></figure><p>이렇게만 보면 큰 차이점은 없어 보인다. 하지만 아래와 같이 연산을 해보면 서로 다른 결과를 보인다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(dollar) decimal_type, <span class="keyword">SUM</span>(mileage) float_type <span class="keyword">FROM</span> <span class="keyword">wallet</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br><span class="line">| decimal_type | float_type        |</span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br><span class="line">|        21.82 | 21.81999969482422 |</span><br><span class="line">+<span class="comment">--------------+-------------------+</span></span><br></pre></td></tr></table></figure><p>DECIMAL 타입은 고동 소수형 데이터기 때문에 연산을 해도 정해진 자리수로 떨어지는 것을 확인할 수 있지만 FLOAT 타입의 경우, 의도치 않은 결과를 반환하는 것을 볼 수 있다. 그렇기 때문에 앞서의 표에서 <code>화폐 데이터와 같이 정확한 데이터</code>를 요할 경우 주로 사용한다. </p><h3 id="문자형-데이터-타입"><a href="#문자형-데이터-타입" class="headerlink" title="문자형 데이터 타입"></a>문자형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th></tr></thead><tbody><tr><td>CHAR(n)</td><td>- 고정 길이 데이터 타입 <br>- 지정된 길이보다 짧은 데이터 입력 시 나머지 길이는 공백으로 채워짐 <br>- 검색시, PAD_CHAR_TO_FULL_LENGTH 모드를 설정하지 않으면 공백은 제거됨</td><td>0 ~ 255 (byte)</td></tr><tr><td>VACHAR(n)</td><td>- 가변 길이 데이터 타입<br>- 지정된 길이보다 짧은 데이터 입력시 공백으로 채우지 않음<br> -저장시 1-byte 혹은 2-byte 길이 Prefix 데이터를 저장. 이 Prefix 데이터는 값의 바이트 수에 대한 정보를 담는다.(<a href="https://dev.mysql.com/doc/refman/8.0/en/char.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/char.html</a>)</td><td>0 ~ 65,535 (byte)</td></tr><tr><td>TINYTEXT(n)</td><td>- 문자열 데이터 타입(최대 255 byte)<br>- TINYBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)<br><a href="https://dev.mysql.com/doc/refman/8.0/en/blob.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/blob.html</a></td><td>0 ~ 255 (byte)</td></tr><tr><td>TEXT(n)</td><td>- 문자열 데이터 타입(최대 65,535 byte)<br> - BLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 65,535 (byte)</td></tr><tr><td>MEDIUMTEXT(n)</td><td>- 문자열 데이터 타입(최대 16,777,215 byte)<br> - MEDIRMBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 16,777,215 (byte)</td></tr><tr><td>LONGTEXT(n)</td><td>- 문자열 데이터 타입(최대 4,294,967,295 byte) <br>- LONGBLOB와 같은 길이값을 저장 가능(단 차이점은 저장 될때 nonbinary string으로 저장)</td><td>0 ~ 4,294,967,295 (byte)</td></tr></tbody></table><h4 id="범위값-초과"><a href="#범위값-초과" class="headerlink" title="범위값 초과"></a>범위값 초과</h4><p>먼저 예시로 유저 테이블을 생성해보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    uid     <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span>    <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    join_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>(),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>생성된 테이블에 샘플 데이터를 넣게 되어보도록 하자. 아래와 같이 비밀번호 컬럼의 범위 N 값 이내의 경우에는 정상적으로 데이터가 추가되는 것을 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="string">'Martin'</span>, <span class="string">'1234567890'</span>, <span class="keyword">default</span>);</span><br></pre></td></tr></table></figure><p>하지만 N값의 범위를 초과하는 경우, 에러를 반환하는 것을 확인할 수 있다. 만약 <code>strict mode</code>가 설정되어 있지 않다면 나머지 값은 길이에 맞게 짤리고 저장은 될 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="keyword">default</span>, <span class="string">'Martin'</span>, <span class="string">'12345678900'</span>, <span class="keyword">default</span>);</span><br><span class="line"><span class="comment">-- ERROR 1406 (22001): Data too long for column 'password' at row 1</span></span><br></pre></td></tr></table></figure><h3 id="날짜형-데이터-타입"><a href="#날짜형-데이터-타입" class="headerlink" title="날짜형 데이터 타입"></a>날짜형 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th><th>형식</th><th>길이</th></tr></thead><tbody><tr><td>DATE</td><td>날짜(년도, 월, 일) 형태의 기간 표현 데이터</td><td>3 byte</td><td>0000-00-00 (YYYY-MM-DD)</td><td>1000-01-01 ~ 9999-12-31</td></tr><tr><td>TIME</td><td>시간(시, 분, 초) 형태의 기간 표현 데이터</td><td>3 byte</td><td>00:00:00</td><td>.</td></tr><tr><td>DATETIME</td><td>날짜와 시간 형태의 기간 표현 데이터</td><td>8 byte</td><td>0000-00-00 00:00:00 (YYYY-MM-DD hh:mm:ss)</td><td>1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59.999999</td></tr><tr><td>TIMESTAMP</td><td>날짜와 시간 형태의 기간 표현 데이터 타입 시스템 변경 시 자동으로 그 날짜와 시간이 저장</td><td>4 byte</td><td>Integer</td><td>.</td></tr><tr><td>YEAR</td><td>년도 표현 데이터 타입</td><td>1 byte</td><td>0000</td><td>.</td></tr></tbody></table><h3 id="이진-데이터-타입"><a href="#이진-데이터-타입" class="headerlink" title="이진 데이터 타입"></a>이진 데이터 타입</h3><table><thead><tr><th>타입</th><th>정의</th><th>길이</th></tr></thead><tbody><tr><td>BINARY(n) &amp; BYTE(n)</td><td>CHAR 형태의 이진 데이터 타입</td><td>최대 255 byte</td></tr><tr><td>VARBINARY(n)</td><td>VARCHAR 형태의 이진 데이터 타입</td><td>최대 65,535 byte</td></tr><tr><td>TINYBLOB(n)</td><td>이진 데이터 타입</td><td>최대 255 byte</td></tr><tr><td>BLOB(n)</td><td>이진 데이터 타입</td><td>최대 65,535 byte</td></tr><tr><td>MEDIUMBLOB(n)</td><td>이진 데이터 타입</td><td>최대 16,777,215 byte</td></tr><tr><td>LONGBLOB(n)</td><td>이진 데이터 타입</td><td>최대 4,294,967,295 byte</td></tr></tbody></table><h3 id="ENUM-타입"><a href="#ENUM-타입" class="headerlink" title="ENUM 타입"></a>ENUM 타입</h3><p>ENUM 타입의 경우에는 실제 실무에서 사용할 수 있는 경우가 크게 많아 보이지는 않는다. 새로운 ENUM 타입이 생겼을 경우나 혹은 정렬을 해야하는 경우 비효율적이기 때문이다. 그래도 어떠한 타입인지 알고 쓸지 말지를 결정하는 것이 더 좋기 때문에 예제를 통해 한번 살펴보도록 하자. 먼저 아래와 같이 테이블 생성해도록 하자. 여기에서 중요한 것을 size</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> enum_test (</span><br><span class="line">  <span class="keyword">size</span> ENUM(<span class="string">'x-small'</span>, <span class="string">'small'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>, <span class="string">'x-large'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  color ENUM(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>, <span class="string">'white'</span>, <span class="string">'pink'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이렇게 선언된 테이블에 총 2가지 방법은 데이터 삽입이 가능하다. 첫번째 방법은 아래와 같이 ENUM 타입 중 한가지 타입을 이용하여 넣는 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="string">'x-small'</span>, <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>두번째 방법은 아래와 같이 저장된 ENUM 타입의 ordering 숫자로 저장하는 법이다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>기본적으로 ENUM 값을 지정하지 않으면 NULL로 삽입되지만, 만약 NULL값을 원하지 않는다면, size 컬럼과 같이 NOT NULL 속성을 추가해주면 된다. </p><h4 id="ENUM-타입-조회하기"><a href="#ENUM-타입-조회하기" class="headerlink" title="ENUM 타입 조회하기"></a>ENUM 타입 조회하기</h4><p>ENUM 타입은 앞에서 살펴보았듯 ordering 숫자로 저장된다. 그렇기 때문에 해당 필드값을 기준으로 정렬하여 조회할 수 있다. 일단 정렬되는 데이터를 확인하기 위해 몇가지 데이터를 추가해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> enum_test <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| small   | white |</span><br><span class="line">| large   | red   |</span><br><span class="line">| x-large | white |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>몇가지 데이터를 추가한 후, 한번 아래와 같이 데이터 정렬을 해자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enum_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| small   | white |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| large   | red   |</span><br><span class="line">| x-large | white |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>size를 기준으로 정렬을 했을 경우, 위와 같이 저장된 ordering 번호에 맞게 정렬되는 것을 확인할 수 있다. 그렇다면 만약 알파벳 순서대로 조회하고자 한다면 어떻게 해야할까? 제일 좋은 것은 알파벳 순서대로 저장하는 것이지만, 현실 가능성은 떨어진다. 중간에 어떠한 ENUM 타입이 생길지도 모르는데, 그걸 모두 고려해서 알파벳 순서대로 테이블을 추가하기란 쉽지 않다. 알파벳 순서대로 조회하기 위해선 다음과 같이 조회하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> enum_test <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">CAST</span>(<span class="keyword">size</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| size    | color |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br><span class="line">| large   | red   |</span><br><span class="line">| medium  | blue  |</span><br><span class="line">| small   | white |</span><br><span class="line">| x-large | white |</span><br><span class="line">| x-small | red   |</span><br><span class="line">| x-small | red   |</span><br><span class="line">+<span class="comment">---------+-------+</span></span><br></pre></td></tr></table></figure><p>ENUM 타입인 size를 CHAR 형태로 타입 캐스팅 해준 후, 조회를 하는 것이다. 하지만 이또한 데이터가 많아질수록 성능이 안좋아질테니, 되도록이면 ENUM 타입보단 다른 형태의 데이터를 이용하여 저장하고 각각의 ENUM 타입에 대한 맵핑은 각각의 애플리케이션에서 정의하는 것이 좋을 것 같다.</p><h3 id="SET-데이터-타입"><a href="#SET-데이터-타입" class="headerlink" title="SET 데이터 타입"></a>SET 데이터 타입</h3><p>마지막으로 살펴볼 타입은 SET 데이터 타입이다. SET 데이터 타입은 ENUM 타입이랑 다르게 중복값을 허용한다. 먼저 예시를 보기 위해 샘플로 아래와 같은 영화 장르 테이블을 생성하도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> genre (</span><br><span class="line">   <span class="keyword">size</span> <span class="keyword">SET</span>(<span class="string">'horror'</span>, <span class="string">'comic'</span>, <span class="string">'romance'</span>, <span class="string">'documentary'</span>, <span class="string">'sf'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>모두 알다시피 하나의 영화에는 여러개의 장르를 선택할 수 있다. 코믹이면서 로맨스일 수도 있고, 공포이면서 SF일 수도 있다. 일단 하나의 영화에 하나의 장르만 존재한다고 가정하고 데이터를 추가해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'horror'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic'</span>);</span><br></pre></td></tr></table></figure><p>그렇다면 만약 여러개의 장르를 가져야할때는 어떻게 해야할까? </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic,romance'</span>);</span><br></pre></td></tr></table></figure><p>중복으로 넣어줄 데이터를 쉼표(,)와 함께 추가해주면 된다. 다만 여기에서 중요한 것은 쉼표 뒤에 띄어쓰기가 되어있으면 안되고, 무조건 붙어있어야 한다. 만약 띄어쓰기를 한 후 데이터를 추가하려고 하면 아래와 같은 에러가 발생한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="string">'comic,romance'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ERROR 1265 (01000): Data truncated for column 'size' at row 1</span></span><br></pre></td></tr></table></figure><p>또 다른 방법으로는 SET 데이터 타입의 주요한 특징에서 찾을 수 있다. SET 데이터의 경우 하나의 값마다 순서대로 Binary 값이 부여된다. Jenre 데이터 테이블의 SET 데이터를 바이너리로 표현하면 다음과 같이 표현할 수 있다.</p><table><thead><tr><th>VALUE</th><th>DECIMAL</th><th>BINARY</th></tr></thead><tbody><tr><td>horror</td><td>1</td><td>00001</td></tr><tr><td>comic</td><td>2</td><td>00010</td></tr><tr><td>romance</td><td>4</td><td>00100</td></tr><tr><td>documentary</td><td>8</td><td>01000</td></tr><tr><td>sf</td><td>16</td><td>10000</td></tr></tbody></table><p>이를 이용하여 다음과 같이 넣어줄 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="number">1</span>); <span class="comment">-- INSERT INTO genre VALUES ('horror'); 와 같다.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> genre <span class="keyword">VALUES</span> (<span class="number">7</span>); <span class="comment">-- INSERT INTO genre VALUES ('horror,comic,romance'); 와 같다.</span></span><br></pre></td></tr></table></figure><h4 id="SET-데이터-타입-조회하기"><a href="#SET-데이터-타입-조회하기" class="headerlink" title="SET 데이터 타입 조회하기"></a>SET 데이터 타입 조회하기</h4><p>SET 데이터를 조회하는 방법은 여러가지가 있다. 일단 첫번째로 일반적인 방법으로 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 단일 조건을 이용하여 조회하는 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span>=<span class="string">'horror'</span>; <span class="comment">-- 정확하게 horror 값만 가지고 있는 데이터만 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%horror%'</span>; <span class="comment">-- horror 값을 포함한 데이터 모두가 조회 가능하다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 여러 조건을 이용하여 조회하는 경우</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span>=<span class="string">'horror,romance'</span>; <span class="comment">-- 정확하게 두가지 값을 모두 가지고 있는 데이터만 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%horror%'</span> <span class="keyword">AND</span> <span class="keyword">size</span> <span class="keyword">LIKE</span> <span class="string">'%romance%'</span>; <span class="comment">-- 'horror'와 'romance' 값 모두 가지고 있는 데이터 모두 조회 가능하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">size</span> &amp; <span class="number">4</span>; <span class="comment">-- 위와 도잉ㄹ하다.</span></span><br></pre></td></tr></table></figure><p>두번째 방법은 비트 연산자를 활용하는 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">1</span>; <span class="comment">-- SELECT * FROM genre WHERE size LIKE '%horror%'; 와 동일하다.</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> <span class="keyword">size</span> &amp; <span class="number">00001</span>; <span class="comment">-- 위와 동일하다.</span></span><br></pre></td></tr></table></figure><p>마지막 방법은 FIND_IN_SET 함수를 이용하는 것이다. 이 함수는 첫번째 인자로는 SET 의 값을, 두번째 인자로는 필드 이름을 넣어주면 저장되 있다면 저장된 순서값을, 저장되어있지 않다면 0을 반환한다. 아래의 예제를 살펴보도록 하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIND_IN_SET(<span class="string">'romance'</span>, <span class="keyword">size</span>) <span class="keyword">FROM</span> genre;</span><br></pre></td></tr></table></figure><p>이와 같이 조회하면 romance가 저장되어 있다면 3을 그렇지 않다면 면 0을 반환하는 것을 확인할 수 있다. 이 함수를 이용한다면 다음과 같은 조건으로 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> genre <span class="keyword">WHERE</span> FIND_IN_SET(<span class="string">'romance'</span>, <span class="keyword">size</span>) &gt; <span class="number">0</span>; <span class="comment">-- romance 값이 저장된 모든 데이터가 조회 가능하다.</span></span><br></pre></td></tr></table></figure><p>지금까지 MYSQL 의 데이터 타입에 대해서 살펴보았다. 혹여라도 이와 관련된 소스를 확인하고 싶다면 <a href="https://github.com/MartinYounghoonKim/technical-debt-repayment-project/blob/master/mysql/select_query.sql" target="_blank" rel="noopener">여기</a>에서 확인할 수 있다. </p>]]></content>
    
    <summary type="html">
    
      RDBMS의 한 종류 MYSQL의 데이터 타입을 살펴보자
    
    </summary>
    
      <category term="Mysql" scheme="http://blog.martinwork.co.kr/categories/mysql/"/>
    
    
      <category term="Mysql, 데이터타입" scheme="http://blog.martinwork.co.kr/tags/mysql-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"/>
    
  </entry>
  
  <entry>
    <title>2019년의 회고</title>
    <link href="http://blog.martinwork.co.kr/review/2020/01/07/remembrance-in-2019.html"/>
    <id>http://blog.martinwork.co.kr/review/2020/01/07/remembrance-in-2019.html</id>
    <published>2020-01-06T15:50:51.000Z</published>
    <updated>2020-01-18T08:04:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="큰-맥락으로-2019년은"><a href="#큰-맥락으로-2019년은" class="headerlink" title="큰 맥락으로 2019년은?"></a>큰 맥락으로 2019년은?</h2><p>2019년은 가장 크게는 몇가지의 이벤트로 인해  일을 시작한 이후 가장 의미있는 한 해이며, 그 동안 생각해왔던 마음가짐이 달라졌던 해였다. 일단 2019년의 가장 큰 이벤트를 간략하게 정리하면 다음과 같다.</p><blockquote><ul><li>‘커피 한 잔 마시며 끝내는 VueJS’ 출판</li><li>쿠팡으로의 이직, 그리고 고마운 동료들과의 만남</li><li>사이드 프로젝트 ‘스낵 뉴스’ 오픈</li><li>글또 3기 마무리</li><li>외부 활동</li></ul></blockquote><p>이 이벤트 중 개인적으로 가장 특별한 이벤트 아무래도 나만의 책을 출판했다는 것이겠지만, <a href="https://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html">2019년 상반기 회고</a>와 <a href="https://blog.martinwork.co.kr/review/2019/07/18/publish-book-for-beginner.html">‘흔한 주니어 개발자의 VueJS 책 집필기’</a> 라는 포스팅에서 이야기했기 때문에 자세한 내용은 해당 포스팅을 보는 것을 추천한다.</p><h3 id="VueJS-책-출판"><a href="#VueJS-책-출판" class="headerlink" title="VueJS 책 출판"></a>VueJS 책 출판</h3><p>2019년 7월 30일, 그 동안의 길고긴 여정을 끝으로 드디어 VueJS 책을 출판하게 되었다. 일단 주변에서 이야기하는 많은 묻는 질문은 많이 팔렸냐인데, 솔직히 말해서 나도 잘 모르겠다. 물론 출판사의 담당자 분을 통해 판매 지수에 대해 묻고자하면 물을 수는 있겠지만, 결과보단 과정에 큰 의미를 두어서 집필 과정에 큰 의미를 두어서인지 크게 궁금하지 않았던 것도 있다. 또 막상 조만간 판매 지수에 대한 결산을 받아보면 또 생각이 달라질지도..</p><p><img src="/images/review/remembrance-in-2019_01.png" alt="정말 결과보다 과정일까..?"></p><p>물론 제일 많이 들려왔던 말은 <code>정말 커피 한잔 마시며 끝낼 수 있냐</code>라는 말이였다. 제목에 대해 냉소적인 태도를 취하는 사람들도 없지는 않았고, 지인들은 나에게 그러한 이야기를 전해주기도 했다. 물론 그때마다 우스갯소리로 ‘누구를 기준으로 했냐에 따라 커피 한잔이 될 수도 있지 않을까요?’ 라는 대답으로 일관했지만, 이러한 이야기들을 전해들으며 되도록이면 사람들 앞에 나를 내보이는 것에 대해 거부감을 가지게 된 원인 중 하나가 되었다. (사람들 앞에 나를 내보이는 것에 대한 거부감의 근본적인 이유는 뒤에서 설명하겠지만 따로 있다.)</p><h2 id="쿠팡으로의-이직-그리고-이상적인-동료들과의-만남"><a href="#쿠팡으로의-이직-그리고-이상적인-동료들과의-만남" class="headerlink" title="쿠팡으로의 이직 그리고 이상적인 동료들과의 만남"></a>쿠팡으로의 이직 그리고 이상적인 동료들과의 만남</h2><p>전 회사에 대한 리뷰를 쓰고나서 1년도 안되었는데 이직에 대한 이야기를 하려니 민망하긴 하지만… 뜻하지 않게 이직을 하게 되었다. 사실 이직 준비를 하는 기간을 두고 이직 준비를 한 것도 아니였고, 이직에 대한 생각도 크게 하고 있지 않은 상태에서 이직을 하게 되었다.</p><p><img src="/images/review/remembrance-in-2019_02.png" alt="갑자기..."></p><p>물론 이렇게 이야기하면 쉽게 이직을 했다는 것처럼 보일 수 있으나, 준비를 하지 않았다는 것이지 홈워크나 면접 등이 쉬었던 것은 아니다. 검색만 해도 심심치 않게 나올 수 있지만, 쿠팡의 면접 과정은 험난한 길이기도 했다. 하루의 면접으로 끝나지만 그 하루의 면접이 4시간에서 5시간동안 진행되기 때문이다. 그 시간동안 여러 명의 면접관들을 거쳐야 하기 때문에 정신력 싸움이였던 것 같다. 만약 나처럼 첫 면접에서 어버버하기 시작하면 그 뒤로는 무슨 이야기를 했는지 기억조차 나지 않는다. 보통은 면접 끝나고 항상 주변 카페에 가서 면접 질문과 과정에 대해 복기한 후 내가 무엇이 부족했는지 적어둔 나만의 정리 노트가 있는데 유일하게 쿠팡은 면접 질문에 대한 복기가 없다. </p><p><img src="/images/review/remembrance-in-2019_03.png" alt="입사문제"></p><p>그리고 2019년 8월 29일, 내가 생각하는 이상적인 개발 문화와 동료들과 조우하였다. 일단 말하기 전에 미리 최소한의 방어책을 세워놓자면…. 팀마다 분위기가 다를 수 있고, 사람마다 느끼는 점이 다를 수 있기 때문에 쿠팡의 모든 개발팀의 문화가 이렇다라는 의미도 아니며 모든 사람이 쿠팡이라는 회사에서 일을 하며 혹은 일했던 경험이 나와 같지는 않을 수 있다. </p><p>일단 우리 팀의 이상적인 개발 문화를 가지고 있다라고 하는 몇 가지 이유가 있는데 크게는 다음과 같다.</p><blockquote><ul><li>한달 정도의 온보딩 기간을 가지고 이 기간동안 <code>팀의 문화와 일하는 방식</code>을 배우며, <code>비즈니스 구현 외적으로 팀에 기여할 수 있는 것을 찾아 기여</code>하도록 한다.</li><li>온/오프라인 가리지 않는 빡빡한 코드 리뷰를 하며 보통 한번의 코드 리뷰를 진행하면 회의실에서 짧게는 1시간 길게는 2시간 3시간까지도 진행한다.</li><li>대부분의 시니어 개발자들도 끊임없이 공부를 하며 그러한 지식에 대해 매일 매일 공유하는 시간을 갖는다.</li></ul></blockquote><p>이 외에 애자일 방식의 업무, 자율근무제, 재택 근무 등에 대해서 쿠팡 전체적으로 적용되기 때문에 따로 이 팀만의 이상적인 개발 문화라고 이야기 싶진 않다. 10년을 넘게 일해온 시니어들조차도 끊임없이 공부하며, 동료들과 지식 나누기를 즐기며, 코드 리뷰를 몇시간동안 진행을 하더라도 지친 기색없이 열정적으로 리뷰 하는 모습을 보며 과연 10년 후에 나도 이런 시니어 개발자가 될 수 있을까 라는 생각을 들게끔 한다.</p><p>쿠팡의 개발 문화나 팀 문화 혹은 채용 관련해서 궁금하신 분은 언제든 편하게 연락주세요 :)</p><h2 id="사이드-프로젝트-‘스낵-뉴스’-오픈"><a href="#사이드-프로젝트-‘스낵-뉴스’-오픈" class="headerlink" title="사이드 프로젝트 ‘스낵 뉴스’ 오픈"></a>사이드 프로젝트 ‘스낵 뉴스’ 오픈</h2><p>전 직장에서 만난 동료들 4명을 시작으로 이제는 개발자 4명, PO 1명, 디자이너 1명, 에디터 2명이라는 지금은 작지 않은 사이드 프로젝트 팀이 되었다. 물론 모든 사이드 프로젝트 특성상 회사 일이나 개인의 일 때문에 꾸준히 하진 못했지만 긴 기간동안 준비했던 프로젝트였다.   </p><p><img src="/images/review/remembrance-in-2019_04.png" alt="쿠팡에서의 미팅한느 스낵 뉴스 개발팀"></p><p>AWS에 대해 잘 이해도 못한 상태에서 서비스를 이용하다가 하마터면 사용 범위를 초과하여 배포를 못했던 우스운 일도 있었고, 원격으로 코드 리뷰를 진행하기도 하는 등의 기억에 남는 일도 많았다. 이에 대해서는 이후에 회고글에서 다룰 예정이다. 아마도.. VueJS와 Typescript 그리고 Firebase를 이용한 애플리케이션 개발기라는 이름으로 개발하며 겪었던 이슈 등을 함께 공유하지 않을까 싶다.</p><h2 id="글또-3기-마무리"><a href="#글또-3기-마무리" class="headerlink" title="글또 3기 마무리"></a>글또 3기 마무리</h2><p>5월 27일, SNS의 피드를 통해 글또 라는 모임을 처음 알게 되었다. </p><p><img src="/images/review/remembrance-in-2019_05.png" alt="글또원 모집 피드글"></p><p>글또는 <code>글쓰는 개발자 모임</code> 으로 내가 참여했을 때는 세번째 기수였다. 일단 이 모임을 처음 참여하게 된 계기는 꾸준한 블로깅을 하기 위해서였다. 내가 알던 지식, 새롭게 알게 되는 지식들을 글로써 정리를 한다면 조금더 머릿 속에 차곡차곡 저장할 수 있다고 느꼈기 때문이다. 물론 나의 경우 대부분의 경우에서 느꼈지만, 혼자서 목표없이 진행을 하게되면 금방 흐지부지해짐을 느꼈다. 그래서 강제성을 부여하기 위해 기회를 엿보던 중, 나의 목적과 부합하는 모임이기에 참여를 하게 되었다. 글또의 모임에 참여하며 한달에 2번의 블로깅을 강제적으로 하게 되었다. 물론 처음에는 <code>내가 모르던 지식을 정리해야지</code> 라며 의지가 뿜뿜했지만, 어느 순간부터는 패널티를 부여받지 않기 위해 글을 쓰고 있게 되었다. 물론 이러한 강제성을 부여받고자 했던 모임이기 때문에 목적은 충분히 달성했다. 개인적인 만족도가 높은 모임이기도 했으며, 다음에 기회가 된다면 또 참여 하고 싶은 모임이기도 하다.</p><h2 id="외부-활동"><a href="#외부-활동" class="headerlink" title="외부 활동"></a>외부 활동</h2><p>2018년과 다른 점은 올 한해는 다른 회사의 개발자들과 많이 만나서 이야기를 나눠보고 생각을 들어보고자 했다는 것이다. 그래서 멋쟁이 사자처럼 해커톤에 멘토로 참여하기도 했으며, 모각작(모여서 각자 작업하기) 모임을 만들어 다같이 애자일스러운 스크럼과 회고를 진행하기도 했다. Chit Chat 이라는 모임을 주최하기도 했으며, mini LAZYCON 이라는 모임을 기획하기도 했다.</p><p><img src="/images/review/remembrance-in-2019_06.png" alt="LAZYCON"></p><p>혹시나 무슨 활동이었는지 궁금하다면 각각의 링크를 통해 확인할 수 있다.</p><blockquote><ul><li><a href="https://blog.martinwork.co.kr/review/2019/06/01/likelion-hackerton.html">멋쟁이 사자처럼</a></li><li><a href="https://www.notion.so/lazylab/1-aba9a155df3d4d0a872e76c5f7e4132a" target="_blank" rel="noopener">모각작(모여서 각자 작업하기) 모임</a></li><li><a href="https://www.notion.so/lazylab/e7a87514534a4a5da0d9583e7e036c6a" target="_blank" rel="noopener">mini LAZYCON</a></li><li><a href="https://lubycon.github.io/magazines/2019/11/18/1st-chit-chat-retrospective" target="_blank" rel="noopener">CHIT Chat</a></li></ul></blockquote><p>물론 다른 누군가에겐 적은 수이긴 하지만, 컨퍼런스나 강연 등을 포함하여 모든 외부 활동의 횟수가 1년에 1번 참여할까 말까하는 나에게는 적은 수는 아니였다. 이러한 모임을 통해 배운 것도 많았으며, 느낀 점 역시 적지 않았다. 많은 좋은 개발자 분들과 이야기를 나눠볼 수 있었으며, 개인적으로 궁금한 분은 먼저 연락을 드려 대화를 나눠보는 시간도 가져보았다. 무엇보다 생각 외로 먼저 연락 드려 대뜸 만나보고 싶다고 하여도 이상하게 바라보지 않았던 분들 모두에게 감사의 표현을 전하고 싶다.</p><p> 하지만 2020년 이후부터는 이러한 <code>모임들을 주최하거나 참여하지 않을 예정</code>이며, 마찬가지로 <code>블로깅 역시 기존과는 다른 성격의 말 그대로 메모장에 가까운 내가 무엇을 공부하고 있고, 무엇을 몰랐는지에 대해 기록하는 블로그</code> 가 될 예정이다. 혹시나 오해의 소지가 있어 미리 이야기하자면 <code>절대 외부 활동에 대한 경험이 좋지 않아서가 아니다</code>. 올해의 목표와 방향에 대한 일단 가장 큰 이유는 결국 <code>선택과 집중</code>이 아닐까 싶다. 지금 현재 프론트 엔드 엔지니어로서 부족한 점, 그리고 앞으로 있을 커리어 전환을 위해 필요한 하드 스킬들 등이 가장 큰 이유이다. 2019년의 외부 활동 등으로 인해 많은 좋은 경험을 하였고, 새로운 사람들도 많이 만났지만 반대로 그러한 활동을 통해 내가 얼마나 부족한지, 얼마나 더 많은 시간을 투자해야 하는지에 대해 깨닫는 한해가 되었다. 오히려 내가 아는 지식과 경험의 수준이 높지 않은 상태에서 다른 누군가에게 나를 내 보였다는 것이 한편으로 부끄럽기도 했던 한해 였다. 지금 함께 하는 동료들이 이 글을 볼지는 모르겠지만, 좁은 시야를 넓혀준 동료 모두에게 감사의 표현을 전하고 싶다.</p><p> 과거 2018년의 회고글을 보며 느낀점이 많듯, 2019년의 회고를 2020년에 읽으며 더 성장하는 나를 조우하기를 기대해본다.</p>]]></content>
    
    <summary type="html">
    
      2019년, 한해의 결산과 반성
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="2019회고, Coupang, 쿠팡" scheme="http://blog.martinwork.co.kr/tags/2019%ED%9A%8C%EA%B3%A0-coupang-%EC%BF%A0%ED%8C%A1/"/>
    
  </entry>
  
  <entry>
    <title>IPv4 주소 체계</title>
    <link href="http://blog.martinwork.co.kr/theory/2019/12/15/ipv4-address.html"/>
    <id>http://blog.martinwork.co.kr/theory/2019/12/15/ipv4-address.html</id>
    <published>2019-12-14T15:50:51.000Z</published>
    <updated>2020-01-07T13:25:14.800Z</updated>
    
    <content type="html"><![CDATA[<p>우리는 사람을 구별할 때 보통 이름과 얼굴, 성별 등과 같은 요소로 구별을 한다. 하지만 이러한 요소들을 고유하지 않으며, 그렇기 때문에 서류상에 등록할 때 사람들 각각을 구분하기 위하여 주민번호를 발급하여 구분하며 이러한 주민번호는 고유한 값이다.</p><p><img src="/images/theory/ipv4-address02.png" alt="주민등록번호 규칙"></p><p>이것은 마치 데이터베이스에 있는 PK값과 같아 각자를 고유한 개개인을 구분하는데 사용할 수 있다. 마찬가지로 네트워크상에서 각각의 컴퓨터는 이러한 주민번호와 같은 고유한 값을 가지게 되는데 이러한 값을 하는 것이 <code>IP</code>이다. 현재 우리가 사용하는 IP 체계는 32Bit 체계를 사용하며, 대략 42억개의 IP 주소를 사용할 수 있다고 한다.</p><p><img src="/images/theory/ipv4-address02.png" alt="32bit 체계의 IPv4"></p><p>처음 IPv4, 즉 32 bit 체계를 가질 때만 해도 컴퓨터가 지금처럼 보급화되지 않았기 때문에 42억개 정도로도 충분했지만, 지금은 개인이 여러개를 가지는 경우도 있기 때문에 거의 고갈되어 2010년도 기준, IPv6 체계까지 하여 총 2가지 체계를 가진다고 한다. </p><p>과거에는 IP를 할당할 때 클래스 단위로 나누어 IP를 할당하였지만 지금은 현재 CIDR(사이더)이란 방식을 사용한다고 한다. 오늘은 과거에 사용하던 클래스 단위 IP 주소 체계에 대해 살펴볼 예정이다. IP를 클래스 단위로 할당할 때, 각각의 기준에 따라 총 3가지 클래스로 나누어 구분할 수 있다.</p><ul><li>A Class</li><li>B Class</li><li>C Class</li></ul><p>각각의 클래스는 가지는 네트워크 주소(대표 주소)와 Host 주소(IP)의 규모가 다르며, IP 대의 영역이 있기 때문에 대략적으로 IP 주소만 봐도 어떠한 클래스에 속하는지 구별할 수 있다. </p><h3 id="A-Class"><a href="#A-Class" class="headerlink" title="A Class"></a>A Class</h3><p>먼저 A Class를 구분할 때는 아래의 그림에서 네트워크 주소에서 1번째 비트 즉 <code>구분 비트</code>가 0이어야 한다.</p><p><img src="/images/theory/ipv4-address03.png" alt="A Class"></p><p>그렇다라는 의미는 반대로 최대로 할당될 수 있는 네트워크는 아래의 그림과 같이 표현될 수 있다.</p><p><img src="/images/theory/ipv4-address04.png" alt="A Class"></p><p>이렇게 표현되어 있는 2진수를 10진수로 바꾸었을 때, 이는 0~127 범위 안에 속하여 이 사이에 있는 IP 주소는 A Class라고 볼 수 있다. 네트워크 주소 내에서 첫번째 구분 비트를 제외하면 총 2^7 개의 네트워크 그룹이 존재하며, 이 네트워크 그룹은 2^24개(16,777,216개)로 약 1,600만개의 IP 주소를 가질 수 있다. 예를 들어 <code>54.15.135.12</code>의 IP는 A Class에 속해 있으며, 대표 IP는 네트워트 주소만으로 표현됨으로 <code>54.0.0.0</code>이라고 볼 수 있다. 간단하게 정리하면 다음과 같이 정리 할 수 있다.</p><blockquote><p>A Class IP의 범위는 0.0.0.0 ~ 127.255.255.255 이며, 약 1,600만개의 Host 주소를 가진 네트워크 그룹은 총 127개 있다.</p></blockquote><h3 id="B-Class"><a href="#B-Class" class="headerlink" title="B Class"></a>B Class</h3><p>B Class는 구분 비트 <code>10</code> 이다. A Class 에 비해 표현할 수 있는 네트워크 주소의 범위가 더 커졌으며, 호스트 주소의 범위는 줄어들었다.  </p><p><img src="/images/theory/ipv4-address05.png" alt="B Class"></p><p>위와 마찬가지로 최대로 할당될 수 있는 네트워크 범위의 수는 아래의 그림과 같이 <code>10111111</code>까지이며 이는 10진수로 표현했을 때 191이다.</p><p><img src="/images/theory/ipv4-address06.png" alt="B Class"></p><p>이러한 B Class는 네트워크 영역 중 고정되는 앞의 2개의 구분 비트를 제외하면 총 2^14개(16,384개) 네트워크 그룹이 있으며 각각의 네트워크 그룹은 2^16개(65,536개)로 대략 65,000개의 IP 주소를 가질 수 있다. B Class의 범위는 앞의 A Class 범위 이후부터이기 때문에 다음과 같이 정리할 수 있다. </p><blockquote><p>B Class IP의 범위는 128.0.0.0 ~ 191.255.255.255 이며, 약 65,000개의 Host 주소를 가진 네트워크 그룹이 대략 16,000개 존재한다.</p></blockquote><p>만약 <code>153.39.16.3</code>의 IP를 사용하고 있다면 이는 B Class 안에 포함되며 대표 IP는 네트워크 영역 안의 <code>153.39.0.0</code>이 된다.</p><h3 id="C-Class"><a href="#C-Class" class="headerlink" title="C Class"></a>C Class</h3><p>마지막으로 C Class는 가장 넓은 범위의 네트워크 범위를 가진다. 하지만 반대로는 호스트 주소의 범위는 줄어든다.</p><p><img src="/images/theory/ipv4-address07.png" alt="C Class"></p><p>C Class는 구분자 비트는 무조건 <code>110</code>이어여 하며, 범위는 최대 <code>11011111</code>까지이다. 이는 10진수로 표현했을때, 223에 해당하는 값이다. </p><p><img src="/images/theory/ipv4-address08.png" alt="C Class"></p><p>C Class는 총 2^23개(2,097,152개)의 네트워크 주소를 가지며, 각각의 네트워크는 2^8(256개)개의 호스트 주소를 가질 수 있다. 그렇기 때문에 C Class의 IP 범위는 아래와 같이 정리할 수 있다.</p><blockquote><p>C Class IP의 범위는 192.0.0.0 ~ 223.255.255.255까지 이며, 254개의 호스트 주소를 가지는 네트워크가 대략 200만개 존재한다. </p></blockquote><p>만약 <code>203.18.41.12</code>의 IP를 사용하고 있다면 이는 C Class 안에 포함되며 대표 IP는 <code>203.18.41.0</code> 이다. 위의 설명을 살펴보면 사용할 수 있는 호스트 갯수를 254개 라고 설명했는데 이는 0-255 범위로 총 256개의 IP 보다 2개 적은 숫자이다. 이는 대표 IP인 <code>203.18.41.0</code>번과 브로드 캐스트 IP인 <code>203.18.41.255</code>를 제외한 숫자이다. </p><p>이상으로 대략적인 IP 주소 체계에 대해서 살펴보았다. 사실 그동안 관심을 안가져서 어려웠지 막상 공부를 하고나니 대략적으로나마 IP 주소 체계에 대해 이해할 수 있었던 계기가 되었다.</p>]]></content>
    
    <summary type="html">
    
      IPv4 주소의 A Class, B Class, C Class에 대해 살펴본다.
    
    </summary>
    
      <category term="theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="IPv4, Network, IP" scheme="http://blog.martinwork.co.kr/tags/ipv4-network-ip/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin의 Nothing 타입</title>
    <link href="http://blog.martinwork.co.kr/kotlin/2019/11/24/nothing-type-in-kotlin.html"/>
    <id>http://blog.martinwork.co.kr/kotlin/2019/11/24/nothing-type-in-kotlin.html</id>
    <published>2019-11-23T15:50:51.000Z</published>
    <updated>2020-01-07T13:25:14.800Z</updated>
    
    <content type="html"><![CDATA[<p>아래의 예제를 통해 Kotlin 내에서 특별하게 취급되는 타입 중 하나인 Nothing 타입에 대해 살펴보도록 하자. 그 전에 알고가야할 것은 아래의 예제 코드 속에서 엘비스 연산자의 우항에 return 문이 대입되어 있다는 점이다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> otherPerson = o <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> otherPerson.firstName == firstName &amp;&amp;</span><br><span class="line">         otherPerson.lastName == lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> address = person.company?.address</span><br><span class="line">      ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"No address"</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/kotlin/kotlin-nothing-type01.png" alt="이게 뭐야"></p><p>지금까지 Javascript만 이용하여 개발을 해왔던 나로서는 제일 이해가 안되는 것 중 하나이기도 하다. 어떻게 문이 값처럼 취급 될 수 있는 것인가? 그러던 중 코틀린의 문서에서 <code>코틀린 내에서는 throw 나 return 등의 연산도 식으로 판단한다.</code> 라는 문구를 읽게 되었다. 그렇기 때문에 위의 코드처럼 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있던 것이다. 위의 예제 코드와 같이 에러에 해당하는 throw의 경우 <strong>Nothing</strong>이라는 특별한 타입을 가진다.</p><h3 id="Nothing-타입"><a href="#Nothing-타입" class="headerlink" title="Nothing 타입"></a>Nothing 타입</h3><p>nothing 타입은 “<strong>이 함수가 정상적으로 끝나지 않는다</strong>“ 라는 걸 명시적으로 표현하는 타입이다. Nothing 타입은 아무런 값도 포함하지 않으므로, <strong>함수의 반환 타입</strong> 등에 사용한다.</p><p>그 외에는 변수에 아무 값도 저장할 수 없으므로 큰 의미가 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.1.4_3_Nothing_type.kt</span></span><br><span class="line"><span class="keyword">var</span> a: String? = <span class="literal">null</span></span><br><span class="line">a = <span class="string">"테스트"</span></span><br><span class="line"><span class="keyword">val</span> x: <span class="built_in">Nothing</span>? = <span class="literal">null</span>           <span class="comment">// 'x' has type `Nothing?`</span></span><br><span class="line">x = <span class="string">""</span> <span class="comment">// =&gt; Type missmatch</span></span><br><span class="line"><span class="keyword">val</span> l: List&lt;<span class="built_in">Nothing</span>?&gt; = listOf(<span class="literal">null</span>)   <span class="comment">// 'l' has type `List&lt;Nothing?&gt;</span></span><br></pre></td></tr></table></figure><p>이러한 Nothing 타입은 Nothing 함수를 반환하는 함수가 “정상적으로 종료하지 않음”을 알고 그 함수를 호출하는 함수를 분석할 때 유용하게 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.1.4_3_Nothing_type.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(message: <span class="type">String</span>?)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> IllegalAccessException(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span> <span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 아래와 같이 null 일 경우, 정상적으로 종료하지 않는다는 사실을 쉽게 알 수 있음</span></span><br><span class="line">  <span class="keyword">val</span> address = company.address ?: fail(<span class="string">"adress"</span>)</span><br><span class="line">  println(address.city)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      함수가 정상적으로 종료되지 않음을 나타낼 수 있는 Nothing 타입에 대해 살펴본다.
    
    </summary>
    
      <category term="Kotlin" scheme="http://blog.martinwork.co.kr/categories/kotlin/"/>
    
    
      <category term="Nothing타입, 코틀린, Kotlin" scheme="http://blog.martinwork.co.kr/tags/nothing%ED%83%80%EC%9E%85-%EC%BD%94%ED%8B%80%EB%A6%B0-kotlin/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 톺아보기</title>
    <link href="http://blog.martinwork.co.kr/react/2019/11/10/react-hooks.html"/>
    <id>http://blog.martinwork.co.kr/react/2019/11/10/react-hooks.html</id>
    <published>2019-11-09T15:50:51.000Z</published>
    <updated>2019-11-16T12:20:56.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Hooks-톺아보기"><a href="#React-Hooks-톺아보기" class="headerlink" title="React Hooks 톺아보기"></a>React Hooks 톺아보기</h2><p>React 에는 Class 컴포넌트와 Functional 컴포넌트 등 총 2가지 형태로 구분하여 컴포넌트를 작성할 수 있다. 과거 처음 React를 이용하여 개발을 시작할 때는 Functional 컴포넌트가 Presentation 컴포넌트이자, Stateless 컴포넌트이고, Class 컴포넌트가 Container 컴포넌트이자, Stateful 컴포넌트라고 생각하였다. 하지만 공부 안한 나의 잘못된 지식을 가지고 있었다는 걸을 탓하며, Class 컴포넌트도 Presentation 컴포넌트가 될 수 있고, Functional 컴포넌트도 Container 컴포넌트가 될 수가 있었던 걸 깨달았다. 이에 또 Hooks라는 또다른 기술부채가 쌓이는 상황이 발생하게 되었다. 이참에 쌓인 기술 부채의 일부를 청산해보가 학습해보게 되었다.  </p><h3 id="Hooks의-개요"><a href="#Hooks의-개요" class="headerlink" title="Hooks의 개요"></a>Hooks의 개요</h3><p>일단 Class 컴포넌트 형태로도 작성할 수 있는 데도 불구하고 Hooks를 사용하는 얻는 이점이 뭔지를 살펴보고자 한다.  </p><h4 id="1-Stateful-코드를-재사용하기가-힘들다"><a href="#1-Stateful-코드를-재사용하기가-힘들다" class="headerlink" title="1. Stateful 코드를 재사용하기가 힘들다."></a>1. Stateful 코드를 재사용하기가 힘들다.</h4><p>Class 컴포넌트로 작성하게 되면 컴포넌트 간의 코드 재사용성을 위해 HOC(고차함수 컴포넌트) 혹은 render props 형태로 작성해야만 했다. 하지만 이러한 코드의 경우 일단 첫번째는 코드가 다소 직관적이지 않다는 단점이 있으며, React devtools에서 디버깅을 하게 되는 경우 아래와 같이  Wrapper Hell 에 빠지는 것을 쉽게 볼 수 있다.</p><p><img src="/images/react/react-hooks01.png" alt="React Wrapper hell"></p><p>하지만 Hooks는 컴포넌트의 계층 구조와는 상관없이 코드의 재사용성을 높여준다. 이러한 점은 Custom Hooks를 이용하여 이점을 극대화 시킬 수 있다.</p><h4 id="2-Class-컴포넌트의-로직을-관심사에-따라-분리할-수-있다"><a href="#2-Class-컴포넌트의-로직을-관심사에-따라-분리할-수-있다" class="headerlink" title="2. Class 컴포넌트의 로직을 관심사에 따라 분리할 수 있다."></a>2. Class 컴포넌트의 로직을 관심사에 따라 분리할 수 있다.</h4><p>Class 컴포넌트로 컴포넌트를 작성하다보면 각각의 생명 주기(Life cycle) 안에서 여러가지 로직을 추가하는 경우가 있다. 예를 들어 componentDidMount 훅에서는 컴포넌트에 필요한 초기 데이터를 위한 API를 호출하거나 EventListener 를 등록 해줄 수 있다. 뿐만 아니라 이렇게 설정된 데이터 혹은 EventListener 들은 componentWillUnmount 훅에서 제거하거나 데이터를 초기화 해줄 수 있다. 이러한 부분들이 컴포넌트의 생명주기 메소드 내의 가독성과 관심사 분리를 해칠 수 있으며, 이에 따라 버그나 무결성을 해칠 수 있는 여지가 충분하다. </p><p>이러한 이유로 인해 간단하게 작성되기 시작한 Class 컴포넌트도 시간에 따라 점점 더 비대해지며, 정작 중요한 비즈니스 코드가 눈에 한 눈에 들어오지 않게 되는 경우가 발생하게 된다. 관심사별 비즈니스 코드를 분리하기 위해 Redux나 Mobx와 같은 상태 관리 라이브러리를 사용해야 하는 경우가 생긴다. 이러한 문제점에 대해 Hooks는 로직 별로 작은 단위에 컴포넌트에 집중할 수 있는 해결점을 제공해준다.</p><h4 id="3-Class-문법에-대한-진입-장벽을-낮춘다"><a href="#3-Class-문법에-대한-진입-장벽을-낮춘다" class="headerlink" title="3. Class 문법에 대한 진입 장벽을 낮춘다."></a>3. Class 문법에 대한 진입 장벽을 낮춘다.</h4><p>개인적으로는 React에 대한 진입 장벽은 JSX 문법이라고만 생각을 해왔는데, React 공식 문서에 따르면 React 에 대한 진입 장벽 중 하나로 Class 문법을 언급하고 있다. Class로 컴포넌트를 설계하게 되면 this를 이해하지 못하고서는 사용하기가 힘들다. 그래서 bind 메소드를 이용한 this를 바인딩하는 등의 여러가지 작업을 해줘야하는 경우가 있다. 마찬가지로 props, state 혹은 Class 컴포넌트 내의 메소드들을 참조할때도 항상 this 에 대한 스코프가 유지되어야 한다. </p><p>하지만 Hooks의 경우 Functional 컴포넌트 내에서 사용되기 때문에 Class 컴포넌트에 대한 this 장벽을 허물 수 있다는 장점을 가진다. 이뿐만 아니고도 Class 컴포넌트의 경우는 Tree shaking이 원활하게 지원되지 않는 등의 문제를 해결할 수 있다고 있다.</p><p>관련된 자세한 내용은 <a href="https://reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noopener">공식 문서의 Motivation</a>에서 확인할 수 있다.  </p><h3 id="Hooks이란-무엇인가"><a href="#Hooks이란-무엇인가" class="headerlink" title="Hooks이란 무엇인가?"></a>Hooks이란 무엇인가?</h3><p>Hooks는 Functional 컴포넌트도 Hooks를 이용하여 Stateful 컴포넌트가 될 수 있도록 만들어 준다. 리액트의 공식 문서를 살펴보면 다음과 같은 문구를 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Effect Hook lets you perform side effects in function components</span><br></pre></td></tr></table></figure><p>여기에서 이야기하는 <code>side effects</code> 이란, 데이터를 받아오거나, 데이터를 구독하거나 혹은 DOM을 직접 조작하는 행위를 말한다고 한다. 본격적으로 Hooks에 대해서 살펴보도록 하자.</p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>일단 기본적으로 사용하는 문법은 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, counting] = useState(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt; &#123;count&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useState 의 인자로는 상태의 초깃값을 주입해줄 수 있으며, 초기값은 Primitive 타입 혹은 Object 타입 상관없이 주입할 수 있다. 이 초기값은 처음 컴포넌트가 랜더링될 경우에만 사용되며, 이후부터는 useState에서 반환하는 Setter 함수를 통해 변경된 값이 State 에 담긴다. useState의 인터페이스를 살펴보면 다음과 같이 되어 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a stateful value, and a function to update it.</span><br><span class="line"> *</span><br><span class="line"> * @version experimental</span><br><span class="line"> * @see https://reactjs.org/docs/hooks-reference.html#usestate</span><br><span class="line"> */</span><br><span class="line">function useState&lt;S&gt;(initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];</span><br></pre></td></tr></table></figure><p>useState는 제네릭 타입 S(initialState)를 인자로 받은 후, 튜플 타입으로 첫번째 값은 State를 반환하며 두번째 값으로는 State를 업데이트할 수 있는 Dispatch 함수를 반환한다. 여기에서 중요한 것은 Dispatch 함수는 Redux의 Dispatch 함수가 아닌 리액트의 인터페이스에 정의되어 있는 Void 타입의 함수이다. </p><p>위의 인터페이서에서 살펴볼 수 있듯, useState 는 State와 Dispatch 함수로 이뤄진 배열을 반환하기 때문에 useState를 사용할 때 <code>구조 분해 할당 구문</code>을 통하여 다음과 같이 사용할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, addCount] = useState(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>시간을 카운팅하는 코드를 먼저 Class 컴포넌트 형태로 작성하게 되면 다음과 같이 작성할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">        <span class="comment">// 최초 컴포넌트가 실행될 때, setState를 일으킨다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>:  <span class="keyword">this</span>.state.count - <span class="number">1</span>&#125;), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="comment">// 이후 state의 변화에 따라 setState를 지속적으로 일으킨다.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>:  <span class="keyword">this</span>.state.count - <span class="number">1</span>&#125;), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Class 컴포넌트는 처음 컴포넌트가 마운트되며 setTimeout 함수를 한번 실행할 것 이다. 이후 State 값이 변경됨에 따라 setTimeout 함수가 재호출되며 render 함수를 통해 DOM이 리랜더링 된다.</p><p>하지만 이 코드를 Functional 컴포넌트의 useState를 이용하여 작성하면 다음과 같이 작성할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, counting] = useState(<span class="number">10</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> counting(count<span class="number">-1</span>), <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt; &#123;count&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>Functional 컴포넌트는 컴포넌트가 랜더링되며 setTimeout 함수를 반복적으로 호출하는 형태로 작성되어진다. </p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>useState Hook을 사용 하다보면 상황에 따라 Class 컴포넌트의 <code>componentDidMount, componentDidUpdate, componentWillUnmount</code> 등과 같은 특정 상황에 Lifecycle 안에서 특정 로직을 실행시켜 줘야 하는 경우가 있다. 예를 들어 컴포넌트가 마운트되었을 때 컴포넌트에 필요한 초기 데이터를 API를 호출을 통해 받아와야 한다던지, 혹은 DOM에 EventListener를 등록하거나 언마운트될 때 등록된 EventListener를 해제해줘야하는 상황이 있다. 이러한 경우 <code>useEffect</code>를 이용한다면 Class 컴포넌트에서 제공해주는 생명주기 API들을 Functional 컴포넌트에서도 마찬가지로 사용할 수 있다.  </p><p>공식 문서를 살펴보면 팁으로 다음과 같이 정보를 제공해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tip</span><br><span class="line"></span><br><span class="line">If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.</span><br></pre></td></tr></table></figure><p>이 말인 즉, Hook의 useEffect를 잘 이해하여 사용한다면 Class 컴포넌트의 componentDidMount, componentDidUpdate, componentWillUnmount 메소드들과 같은 효과를 볼 수 있다는 것이다. 먼저 useEffect 함수의 인터페이스를 살펴보도록 하자. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Accepts a function that contains imperative, possibly effectful code.</span><br><span class="line"> *</span><br><span class="line"> * @param effect Imperative function that can return a cleanup function</span><br><span class="line"> * @param inputs If present, effect will only activate if the values in the list change.</span><br><span class="line"> *</span><br><span class="line"> * @version experimental</span><br><span class="line"> * @see https://reactjs.org/docs/hooks-reference.html#useeffect</span><br><span class="line"> */</span><br><span class="line">function useEffect(effect: EffectCallback, inputs?: InputIdentityList): void;</span><br><span class="line"></span><br><span class="line">// InputIdentityList 은 아래와 같이 정의되고 있다.</span><br><span class="line">// type InputIdentityList = ReadonlyArray&lt;any&gt;;</span><br></pre></td></tr></table></figure><p>useEffect 함수는 EffectCallback 함수를 인자로 받으며, 두번째 인자로는 state값의 배열을 받는다. 여기에서 우리가 주의깊게 봐야할 것은 첫번째 인자인 EffectCallback 은 Mandatory 값이며, 두번째 인자인 InputIndetiryList는 optional 값이라는 것이다. 만약 InputIdentityList 값이 변경된다면 EffectCallback 함수가 실행될 것이다.  </p><p>useEffect로 작성된 컴포넌트를 살펴보기 전에 먼저 우리에게 익숙한 Class 컴포넌트로 해당하는 상황을 살펴보면 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; user &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.state.user) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">        &lt;dt&gt;&#123;this.state.user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">        &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">        &lt;dt&gt;&#123;this.state.user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>처음 컴포넌트가 마운트될 때 fetchUser 라는 API 함수를 호출한다. 그 후, 받아온 user의 데이터를 setState를 이용하여 state에 저장을 해주는 형태이다. 이러한 코드를 useEffect 를 이용하여 변경하면 다음과 같다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">      setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); <span class="comment">// &lt;- 빈 배열임을 꼭 기억해야 한다.</span></span><br><span class="line">  <span class="keyword">return</span> user &amp;&amp; (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">    &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useEffect 함수가 실행되는 시점은 컴포넌트가 처음 마운트되는 시점을 포함하여 컴포넌트가 리랜더링된 이후 매번 실행된다. 하지만 위에서 설명했듯 만약 두번째 인자에 배열 형태의 값을 넣게 되면 useEffect의 콜백함수는 배열의 값에 변화가 있을 경우 실행될 것이다. 위의 예제를 살펴보면 useEffect의 두번째 인자로 빈 배열을 넣어주었는데, 빈 배열을 넣어주게 되면 더이상의 변화가 없기 때문에 EffectCallback 함수는 처음 컴포넌트가 마운트될 때 한번 실행될 것이다. 만약 이것을 감안하지 않고 아래와 같이 인자를 던지지 않으면 DOM이 변경되면서 useEffect 함수가 실행되며 계속 API를 호출하는 상황이 발생할 것이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FunctionalComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">      setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;); <span class="comment">// &lt;- InputIdentityList를 넣어주지 않으면 계속해서 fetchData 함수가 실행되는 상황이 생긴다.</span></span><br><span class="line">  <span class="keyword">return</span> user &amp;&amp; (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &lt;dt&gt;유저의 이름&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.name&#125;&lt;/</span>dt&gt;</span><br><span class="line">      &lt;dt&gt;유저의 나이&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dt&gt;&#123;user.age&#125;&lt;/</span>dt&gt;</span><br><span class="line">    &lt;<span class="regexp">/dl&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>빈 배열이 아닌 아래와 같이 작성한다면 user 데이터가 변경될 때마다 useEffect의 콜백함수가 실행될 것이다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"User State changed!"</span>)</span><br><span class="line">&#125;, [user])</span><br></pre></td></tr></table></figure><p>그렇다면 해제 함수를 실행 시켜줘야 할때는 어떻게 해야할까? 그런 경우는 아래와 같이 EffectCallBack 함수에서 해제 함수를 반환해주면 된다. </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 해제 함수. </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이러한 해제 함수는 컴포넌트가 언마운트될 때 뿐만 아니라, 재랜더링될때도 마찬가지로 실행된다. 만약 언마운트될 때만 실행시켜주고자 한다면 위에서와 같이 두번째 인자를 빈 배열로 주입하게 되면 useEffect 의 EffectCallback 함수는 처음 마운트 될 때 한 번, 언마운드 될때 한번 해서 두번만 실행되며 DOM이 업데이트 되지 않는다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Component did mount"</span>);</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">    setUser(user);</span><br><span class="line">  &#125;</span><br><span class="line">  fetchData();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Component will unmount."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h3><p>이 외에도 useContext나 useReducer 같은 또다른 Hook들도 있으며, 필요에 따라 상황에 맞게 사용하면 되지 않을까 한다. 다만 사용하기 전에 대략적으로나마 동작하는 방식에 대해 이해하고 있어야 문제가 생겼을 때 문제를 해결할 수 있지 않을까라고 생각한다.  </p>]]></content>
    
    <summary type="html">
    
      React Hooks 학습해보기
    
    </summary>
    
      <category term="React" scheme="http://blog.martinwork.co.kr/categories/react/"/>
    
    
      <category term="React, React Hooks" scheme="http://blog.martinwork.co.kr/tags/react-react-hooks/"/>
    
  </entry>
  
  <entry>
    <title>Typescript와 NodeJS를 이용한 간단한 목킹 서버 띄우기 02</title>
    <link href="http://blog.martinwork.co.kr/nodejs/2019/09/20/nodejs-with-typescript02.html"/>
    <id>http://blog.martinwork.co.kr/nodejs/2019/09/20/nodejs-with-typescript02.html</id>
    <published>2019-09-19T15:50:51.000Z</published>
    <updated>2019-11-10T13:38:52.707Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>이 포스팅에서 사용한 모든 소스는 <a href="https://github.com/MartinYounghoonKim/nodejs-express-typescript-sample" target="_blank" rel="noopener">깃헙</a>에서 확인할 수 있습니다. </p></blockquote><p><a href="https://blog.martinwork.co.kr/nodejs/2019/09/08/nodejs-with-typescript01.html">이전 포스팅</a>에서는 로컬에서 NodeJS 프레임워크 중 하나인 Express를 이용하여 API 서버를 만들 수 있도록 기본적인 환경을 구축해보았다. 사실 내가 이 포스팅을 쓰며 정리하고자 했던 내용은 이제부터 본격적인 시작이 아닐까 싶다.</p><p><img src="/images/nodejs/nodejs-with-typescript03.png" alt="본격적인 시작"></p><h3 id="Typescript-적용하기"><a href="#Typescript-적용하기" class="headerlink" title="Typescript 적용하기"></a>Typescript 적용하기</h3><p>이전의 다른 포스팅에서도 여러번 언급을 했지만 나는 서비스 개발 시 Typescript를 이용하여 개발을 하는 것이 서비스의 안정성을 높이는 일이라고 생각한다. 그렇기 때문에 역시나 MOCK 서버에서도 마찬가지로 Typescript를 이용하여 개발할 수 있도록 설정을 해줄 예정이다. 여기에서의 핵심은 <code>클라이언트에서 정의한 모델(Model)에 대한 타입과 서로 타입을 공유하여 MOCK 서버의 응답값(Response)와 타입을 유기적으로 잘 엮어주는 것</code>이다. 하지만 이번 포스팅에서 이러한 내용까지 다루기에는 클라이언트 코드까지 작성해야한다는 번거로움이 있기 때문에 별도로 다루진 않는다. 만약 이러한 상황이 생긴다면 꼭 서로 유기적으로 연결하여 서로의 타입에 대해 실시간으로 검증할 수 있도록 작성하도록 하자(실제 회사에 적용된 MOCK 서버 역시 말한 것과 같이 클라이언트와 모델(Model)에 대한 타입을 공유하여 사용하고 있다.)</p><p>일단 먼저 타입스크립트를 Express에서 사용할 수 있도록 필요한 모듈을 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install typescript ts-node @types/node @types/express --save-dev</span><br></pre></td></tr></table></figure><p>설치가 되었다면 앞서 추가한 nodemon에 ts-node를 사용할 수 있도록 수정해보도록 하자. 수정되기 전은 아마도 아래와 같이 설정되어 있을 것이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"nodemon ./bin/www"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드를 아래와 같이 변경하면서 <code>www</code> 파일의 확장자를 ts로 변경해준다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"nodemon --exec 'ts-node' bin/www.ts"</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변경된 후에는 tsconfig.json 파일을 하나 생성하여 각자의 입맛에 맞는 설정을 추가한다. 이 포스팅에서는 <code>tsc --init</code> 옵션을 통해 생성해주는 기본 tsconfig.json 파일을 사용한다. 만약 tsc 옵션을 사용하고자 한다면 typescript를 전역으로 설치해주면 사용할 수 있으니 참고하도록 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --init</span><br></pre></td></tr></table></figure><p>명령어를 실행시켜주면 다음과 같이 프로젝트의 최상위 루트에 <code>tsconfig.json</code> 파일이 생성되는 것을 볼 수 있다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    "target": "es5",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */</span><br><span class="line">    "module": "commonjs",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */</span><br><span class="line">    // "lib": [],                             /* Specify library files to be included in the compilation. */</span><br><span class="line">    // "allowJs": true,                       /* Allow javascript files to be compiled. */</span><br><span class="line">    // "checkJs": true,                       /* Report errors in .js files. */</span><br><span class="line">    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */</span><br><span class="line">    // "declaration": true,                   /* Generates corresponding '.d.ts' file. */</span><br><span class="line">    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */</span><br><span class="line">    // "sourceMap": true,                     /* Generates corresponding '.map' file. */</span><br><span class="line">    // "outFile": "./",                       /* Concatenate and emit output to single file. */</span><br><span class="line">    // "outDir": "./",                        /* Redirect output structure to the directory. */</span><br><span class="line">    // "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span><br><span class="line">    // "composite": true,                     /* Enable project compilation */</span><br><span class="line">    // "removeComments": true,                /* Do not emit comments to output. */</span><br><span class="line">    // "noEmit": true,                        /* Do not emit outputs. */</span><br><span class="line">    // "importHelpers": true,                 /* Import emit helpers from 'tslib'. */</span><br><span class="line">    // "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span><br><span class="line">    // "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span><br><span class="line"></span><br><span class="line">    /* Strict Type-Checking Options */</span><br><span class="line">    "strict": true,                           /* Enable all strict type-checking options. */</span><br><span class="line">    // "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */</span><br><span class="line">    // "strictNullChecks": true,              /* Enable strict null checks. */</span><br><span class="line">    // "strictFunctionTypes": true,           /* Enable strict checking of function types. */</span><br><span class="line">    // "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */</span><br><span class="line">    // "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */</span><br><span class="line">    // "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */</span><br><span class="line"></span><br><span class="line">    /* Additional Checks */</span><br><span class="line">    // "noUnusedLocals": true,                /* Report errors on unused locals. */</span><br><span class="line">    // "noUnusedParameters": true,            /* Report errors on unused parameters. */</span><br><span class="line">    // "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */</span><br><span class="line">    // "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */</span><br><span class="line"></span><br><span class="line">    /* Module Resolution Options */</span><br><span class="line">    // "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span><br><span class="line">    // "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */</span><br><span class="line">    // "paths": &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span><br><span class="line">    // "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span><br><span class="line">    // "typeRoots": [],                       /* List of folders to include type definitions from. */</span><br><span class="line">    // "types": [],                           /* Type declaration files to be included in compilation. */</span><br><span class="line">    // "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span><br><span class="line">    "esModuleInterop": true                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span><br><span class="line">    // "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    // "sourceRoot": "./",                    /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span><br><span class="line">    // "mapRoot": "./",                       /* Specify the location where debugger should locate map files instead of generated locations. */</span><br><span class="line">    // "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */</span><br><span class="line">    // "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span><br><span class="line"></span><br><span class="line">    /* Experimental Options */</span><br><span class="line">    // "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */</span><br><span class="line">    // "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같이 타입스크립트에 대한 config 파일이 생성되었다면 한번 Express 앱을 실행시켜보도록 하자. 만약 이 포스팅과 동일하게 실행했다면 다음과 같이 에러가 발생할 것이다.  </p><p><img src="/images/nodejs/nodejs-with-typescript04.png" alt="타입스크립트의 에러"></p><p>이러한 이유는 기존의 Javascript로 작성해준 코드를 Typescript 파일로 변경하면 적어주지 않은 인자에 대한 타입이 지정되어 있지 않아 컴파일시 발생하는 에러이다. <code>bin/www.ts</code> 파일의 <code>normalizePort</code> 함수와 <code>onError</code> 함수의 인자(Parameter)에 다음과 같이 타입을 지정해주면 해당 문제를 해결할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ErrnoException 타입을 추가한다</span></span><br><span class="line"><span class="keyword">import</span> ErrnoException = NodeJS.ErrnoException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normalizePort 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizePort</span>(<span class="params">val: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// val 파라미터에 string 타입을 지정한다. </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// onError 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">error: ErrnoException</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// error 파라미터에 ErrnoException 타입을 지정한다.</span></span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같은 방법으로 기존에 생성되어져있는 js 확장자를 ts 확장자로 변경하며, 애러를 하나씩 잡아보도록 하자.</p><h3 id="샘플-API-Entry-포인트-생성하기"><a href="#샘플-API-Entry-포인트-생성하기" class="headerlink" title="샘플 API Entry 포인트 생성하기"></a>샘플 API Entry 포인트 생성하기</h3><p>현재는 서버가 실행되고 있는 localhost:3000으로 접속하면 Express의 화면이 노출될 것이다. 하지만 해당 포스팅에서 Express는 API 서버로만 이용할 예정이기 때문에 화면(View)나 혹은 스태틱 리소스(Static resource)에 대한 코드는 필요가 없다. 그렇기 때문에 API와 무관한 코드는 모두 삭제해주도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// View 템플릿이 위치하고 있는 views 디렉토리와 view 템플릿 엔진을 설정하는 코드를 삭제한다.</span></span><br><span class="line"><span class="comment">// app.set('views', path.join(__dirname, 'views'));</span></span><br><span class="line"><span class="comment">// app.set('view engine', 'pug');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 리소스 파일을 서빙(Serving) 해주는 코드 역시 삭제한다.</span></span><br><span class="line"><span class="comment">// app.use(express.static(path.join(__dirname, 'public')));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>불필요한 파일을 삭제한 후, routes 디렉토리 안의 index.ts 파일을 아래와 같이 수정한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NextFunction, Request, Response &#125; <span class="keyword">from</span> <span class="string">"express"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) </span>&#123;</span><br><span class="line">  res.json(&#123; title: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>파일을 수정한 후 <code>localhost:3000</code> 디렉토리에 접속해보면 설정한 응답값을 반환받을 수 있다.</p><h3 id="Express-앱을-배포할-때는…"><a href="#Express-앱을-배포할-때는…" class="headerlink" title="Express 앱을 배포할 때는…"></a>Express 앱을 배포할 때는…</h3><p>Node 서버의 경우 에러 발생 시, 서버가 쉽게 죽어 만약 재시작 되도록 처리되어 있지 않은 상황에서 서비스에 올렸다면 초유의 사태가 생길지도 모른다. 그렇기 때문에 앱을 재시작해주는 프로세스 관리할 수 있는 모듈이 필요하다. 물론 편리한 개발 환경 구축을 위해 Nodemon을 설치하기는 했지만, Nodemon의 경우 development에서만 사용해야 한다. 그래서 실제 NodeJS 기반의 서버를 배포할 때 여러가지 Process Manager 중 하나를 선택하여 프로세스들을 관리한다. 대표적으로 PM2, Forever, StrongLoop Process Manager 등이 있다. (<a href="http://strong-pm.io/compare/" target="_blank" rel="noopener">관련 비교 링크</a>) 이 중 꾸준한 업데이트와 모니터링의 편의성, 로깅, 클러스터링 지원 등으로 인해 개인적으로는 PM2를 주로 이용을 한다. PM2는 <code>Process Manager</code>의 약자로서 <code>NodeJS의 프로세스를 관리해줄 프로세스 관리자</code> 중 하나이다. 먼저 간단하게 명령어를 살펴보도록 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 프로세스를 실행할 때</span></span><br><span class="line"><span class="comment"># 기본 명령어</span></span><br><span class="line">$ pm2 start index.js</span><br><span class="line"><span class="comment"># 애플리케이션의 이름을 지정할 경우</span></span><br><span class="line">$ pm2 start index.js --name <span class="string">"my-app"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. PM2를 이용하여 시작된 애플리케이션 리스트를 볼 경우</span></span><br><span class="line">$ pm2 list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. PM2 애플리케이션 프로세스를 종료할 경우</span></span><br><span class="line">$ pm2 stop &#123;application_id&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. PM2에 등록된 애플리케이션을 삭제할 경우</span></span><br><span class="line">$ pm2 delete &#123;application_id&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. PM2 애플리케이션의 상세 정보를 조회할 경우</span></span><br><span class="line">$ pm2 show &#123;application_id&#125;</span><br></pre></td></tr></table></figure><p>간단한 명령어이지만 이러한 명령어들을 추가해주기 위해서는 package.json 의 scripts 안에 한줄로 작성해줘야 한다. 간단한 앱이라면 명령어 한줄로 관리해도 무방하지만 실제 애플리케이션을 PM2를 이용하여 올리기 시작하다보면 적용해야할 옵션들이 많아지고 그 때마다 추가하게된다면 점점더 관리가 힘들어질 가능성이 다분하다. 다행이도 PM2는 이러한 옵션들에 대하여 별도의 설정 파일을 Javascript, JSON 그리고 YAML 형식에 따라 각각 지원한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 ecosystem</span><br></pre></td></tr></table></figure><p>위와 명령어를 치면 아래와 같이 ecosystem.config.js 파일이 생성된다. 자바스크립트의 경우 파일명은 큰 상관은 없으나 꼭 끝이 <code>.config.js</code> 로 끝나야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: <span class="string">'API'</span>, <span class="comment">// 애플리케이션 이름</span></span><br><span class="line">    script: <span class="string">'app.js'</span>, <span class="comment">// PM2를 실행시켜줄 스크립트 파일의 경로</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Options reference: https://pm2.io/doc/en/runtime/reference/ecosystem-file/</span></span><br><span class="line">    args: <span class="string">'one two'</span>, <span class="comment">//</span></span><br><span class="line">    instances: <span class="number">1</span>, <span class="comment">// 설치될 앱 인스턴스가 갯수</span></span><br><span class="line">    autorestart: <span class="literal">true</span>, <span class="comment">// 앱 크러쉬 등으로 인해 앱이 종료될 때 재시작할지 여부 (default: true)</span></span><br><span class="line">    watch: <span class="literal">false</span>, <span class="comment">// 폴더 내의 파일에 변경이 있을때, 앱이 리로딩 여부</span></span><br><span class="line">    max_memory_restart: <span class="string">'1G'</span>,</span><br><span class="line">    env: &#123; <span class="comment">// 앱의 env를 설정</span></span><br><span class="line">      NODE_ENV: <span class="string">'development'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    env_production: &#123;</span><br><span class="line">      NODE_ENV: <span class="string">'production'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    log_date_format: <span class="string">"YYYY-MM-DD HH:mm Z"</span>,</span><br><span class="line">    out_file: <span class="string">"logs/out.log"</span></span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  deploy : &#123;</span><br><span class="line">    production : &#123;</span><br><span class="line">      user : <span class="string">'node'</span>,</span><br><span class="line">      host : <span class="string">'212.83.163.1'</span>,</span><br><span class="line">      ref  : <span class="string">'origin/master'</span>,</span><br><span class="line">      repo : <span class="string">'git@github.com:repo.git'</span>,</span><br><span class="line">      path : <span class="string">'/var/www/production'</span>,</span><br><span class="line">      <span class="string">'post-deploy'</span> : <span class="string">'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>여기에서 ㅇ 것은 <code>env</code>에 대한 설정이다.</p><p>다만 여기에서 중요한 것은 이 포스팅과 같이 Typescript로 개발된 앱을 서버로 올릴 때는 결국 Webpack을 통해 빌드를 거친 후 서버를 띄우게 된다. Webpack 4의 경우 mode를 통해 ‘development’, ‘production’, ‘none’ 등을 NODE_ENV로 지원을 해주게 된다. 그리고 무엇보다 wepback의 빌드를 거친 후에는 <code>해당하는 값이 변수로 치환되어 런타임에서 결정되는 것이 아니라 String 형태로 변환</code> 되어지기 때문에 PM2의 env 값중 NODE_ENV가 정상적으로 동작하지 않는다. 그렇기 때문에 만약 이러한 값을 설정해주고 싶다면 NODE_ENV가 아닌 다른 값을 통해 환경 변수를 가지고 들어갈 수 있도록 설정을 해줘야 한다. </p><p>설정 파일이 생성되었다면 다음과 같이 프로세스를 쉽게 관리 할 수 있다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start all applications</span></span><br><span class="line">$ pm2 start ecosystem.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start only the app named worker-app</span></span><br><span class="line">$ pm2 start ecosystem.config.js --only worker-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stop all</span></span><br><span class="line">$ pm2 stop ecosystem.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restart all</span></span><br><span class="line">$ pm2 start   ecosystem.config.js</span><br><span class="line"><span class="comment">## Or</span></span><br><span class="line">$ pm2 restart ecosystem.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reload all</span></span><br><span class="line">$ pm2 reload ecosystem.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete all</span></span><br><span class="line">$ pm2 delete ecosystem.config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 특정 프로세스만 실행시킬 경우</span></span><br><span class="line">$ pm2 start   ecosystem.config.js --only api-app</span><br></pre></td></tr></table></figure><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li>[PM2 공식 홈페이지] (<a href="http://pm2.keymetrics.io/docs/usage/application-declaration/#environment-definition" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/application-declaration/#environment-definition</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      타입스크립트와 NodeJS의 Express를 이용하여 환경을 구축하는 과정을 설명한다.
    
    </summary>
    
      <category term="NodeJS" scheme="http://blog.martinwork.co.kr/categories/nodejs/"/>
    
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/tags/typescript/"/>
    
      <category term="Express" scheme="http://blog.martinwork.co.kr/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Typescript와 NodeJS를 이용한 간단한 목킹 서버 띄우기 01</title>
    <link href="http://blog.martinwork.co.kr/nodejs/2019/09/08/nodejs-with-typescript01.html"/>
    <id>http://blog.martinwork.co.kr/nodejs/2019/09/08/nodejs-with-typescript01.html</id>
    <published>2019-09-07T15:50:51.000Z</published>
    <updated>2019-11-10T13:38:52.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>이 포스팅에서 사용한 모든 소스는 <a href="https://github.com/MartinYounghoonKim/nodejs-express-typescript-sample" target="_blank" rel="noopener">깃헙</a>에서 확인할 수 있습니다. </p></blockquote><p>최근 이직을 하며 새로운 조직에 합류하게 되었다. 이 새로운 조직에서는 새로운 팀원이 합류하였을 때, 새로운 팀원에게 비즈니스와 무관한 플랫폼에 대한 미션을 주는데 이번에 나에게 주어진 미션은 <code>프론트 엔드 개발시 필요한 목 서버(MOCK Server)를 구축</code> 하는 미션이었다. 아마 프론트 엔드 개발을 해본 사람이라면 한 번쯤은 백엔드 API가 개발되어지지 않은 상태에서 먼저 개발을 시작해야하는 곤란한 상황에 처해본적이 있을 것이다.     </p><p><img src="/images/nodejs/nodejs-with-typescript01.png" alt="이거 너무한거 아니냐고 움짤"></p><p>(<del>이거 너무 한거 아니냐고</del>)</p><p>그래도 하늘이 무너져도 솟을 구멍은 있다고 이러한 상황에 닥치면 보통 백엔드 개발자와 API에 대한 인터페이스 미리 협의 후 진행하기 때문에 어찌되었던 개발은 진행할 수 있을 것이다. 이후에는 아마 2가지 선택권으로 나뉠 것이다. 먼저 별도의 API 레이어를 분리해놓고 쓴다면 그냥 해당 API 레이어의 함수에서 정해져있는 결과값을 반환해주면 될 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isSuccess: <span class="literal">true</span>,</span><br><span class="line">    message: <span class="string">""</span>,</span><br><span class="line">    data: [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">"1"</span>, <span class="attr">text</span>: <span class="string">"투두 API 샘플1"</span>, <span class="attr">isDone</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">"2"</span>, <span class="attr">text</span>: <span class="string">"투두 API 샘플2"</span>, <span class="attr">isDone</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    ]    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개발 서버의 API가 나오기 전까진 일단은 Vuex던 Redux던 API 레이어 함수를 호출하여 개발을 진행하다 API 서버가 나오면 API 레이어 코드를 AJAX로 호출하는 형태로 변경하면 된다. 하지만 개발을 하다보면 모든 상황이 낙관적이지 않듯, 개발 서버의 API 배포되어도 여러 비즈니스의 개발 소스가 모이기 때문에 개발 서버가 제대로 돌아가리란 보장이 되지 않는다. 백엔드 API의 코드를 분석할 수 있다고 하더라도 여러 비즈니스가 얽키고 설켜있기 때문에 이것이 내가 사용하는 API가 문제인지, 아니면 내가 사용하는 API가 의존하고 있는 다른 API에서 문제가 생겼는지 알 수가 없다.  </p><p><img src="/images/nodejs/nodejs-with-typescript02.png" alt="강 건너 불구경"></p><p>그렇다고 강 건너 불구경 하듯 나올 때까지 기다릴 수도 없을 따름이니 다시 API 레이어 코드를 AJAX를 통하지 않도록 수정해야 한다. 이러한 상황이 반복되다보면 비즈니스 코드를 수정하는 게 아니라 별도의 목킹 서버의 필요성을 느끼게 된다. </p><p>그래서 이참에 한번 NodeJS와 타입스크립트를 이용한 간단한 API 서버를 구축해보며 그 과정을 정리해보고자 한다. 만약 이러한 과정이 귀찮다면 <a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">JSON Server</a>를 이용하는 것도 하나의 방법이다.</p><h3 id="NodeJS-서버-환경-구축"><a href="#NodeJS-서버-환경-구축" class="headerlink" title="NodeJS 서버 환경 구축"></a>NodeJS 서버 환경 구축</h3><p>일단 NodeJS의 서버 프레임워크 중 유명한 프레임워크인 Express를 이용하여 API 서버를 구축해볼 예정이다. 간단하게 Express Generator를 이용하여 환경을 구축한다. Express generator가 설치되어 있지 않다면 express 명령어를 사용할 수 있도록 express-generator를 전역적으로 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express-generator -g</span><br></pre></td></tr></table></figure><p>설치가 되었다면 아래와 같이 환경을 구축한다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ express --view=pug nodejs-express-typescript-sample</span><br></pre></td></tr></table></figure><p>API 서버이기 때문에 view 템플릿을 무엇이든 상관없다. 위의 명령어를 이용하면 Express 서버를 띄우기 위한 모든 코드가 자동으로 생성된다. 생성되었다면 package.json에 있는 모듈을 <code>npm install</code> 명령어를 이용하여 설치해준다. 설치되었다면 다음으로 Nodemon에 대해서 살펴보도록 하자.</p><h3 id="Nodemon-이용하기"><a href="#Nodemon-이용하기" class="headerlink" title="Nodemon 이용하기"></a>Nodemon 이용하기</h3><p>Nodemon은 마치 webpack-dev-server와 같이 NodeJS 서버의 코드가 수정되면 자동으로 서버를 재시작시켜주는 모듈이다. Nodemon을 이용하면 별도의 설정 없이 간단하게 이용할 수 있다. </p><p>nodemon을 이용하여 앱을 실행할 경우, 아래의 명령어를 이용하여 간편하게 앱을 실행시킬 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon [your node app]</span><br></pre></td></tr></table></figure><p>단, nodemon의 경우 개발할 경우 사용하고 실제 서비스에 올릴 때는 <code>PM2 모듈을 사용하는 것을 권장</code>한다. PM2에 대해서는 뒤에서 따로 다루도록 한다. nodemon을 이용하기 위해서는 nodemon을 전역으로 설치 해야 하지만, NPX를 이용한다면 전역적으로 설치하지 않고도 해당 명령어를 사용할 수 있다. NPX는 Create-React-App을 이용해봤다면 한번쯤은 다들 접해봤을 것이다. NPX는 <a href="mailto:npm@5.2" target="_blank" rel="noopener">npm@5.2</a>+ 이상의 버전에는 자동으로 추가되는 도구로서 주로 npm run scripts 없이 패키지 바이너리를 쓸 경우 사용하게 된다. </p><p>예를 들어, npx를 사용하지 않았을 경우 create-react-app을 사용해야한다고 하면 다음과 같이 create-react-app을 글로벌로 설치한 후 사용해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install create-react-app -g</span><br></pre></td></tr></table></figure><p>물론 create-react-app의 경우 큰 문제가 되지 않을 수 있지만, mocha나 grunt, bower, webpack 등과 같은 툴의 경우 프로젝트 별로 버전을 관리하기가 힘들 수 있다. 또 이런 경우 다른 버전의 패키지를 사용하려고 한다면 해당 패키지를 새로 설치해야 한다.</p><p>물론 이러한 문제점을 scripts에 포함하여 사용하면 문제없이 사용할 수 있지만, 이보다 더 편한 방법으로 npx를 이용할 수도 있다.</p><p>일단 먼저 NPX를 사용하기 전 NPX가 패키지 바이너리를 사용하는 순서를 살펴보면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 해당하는 프로젝트의 node_modules/.bin 안에 존재하는 패키지를 기준으로 호출한다.</span><br><span class="line">2. 로컬에 해당 패키지가 없다면 npx 레지스트리에서 해당 이름의 패키지를 자동으로 다운로드 받은 후 호출한다.</span><br></pre></td></tr></table></figure><p>NPX는 패키지 명령어를 위와 같은 방법으로 실행시키기 때문에 Global로 패키지를 설치하지 않아도 해당하는 패키지의 명령어를 사용할 수 있다. 다만 2번과 같이 자동으로 다운로드 받은 후 호출된다고 하더라도 전역적으로 설치를 시키는 게 아니라, 패키키를 호출한 후 삭제해버리니 글로벌로 설치되지 않을까 하는 걱정은 하지 않아도 된다. 다만 매번 명령어를 실행할 때마다 설치를 진행하므로 명령어를 한번 실행할 때 시간이 오래 걸리기 때문에 로컬 프로젝트에 설치하여 사용하는 것을 권장한다.</p><p>일단 nodemon을 사용할 수 있도록 로컬에 설치해주도록 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure><p>설치되었다면 npm 명령어 한번으로 실행시킬 수 있도록 scripts에 명령어를 수정한다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"nodejs-express-typescript-sample"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    // "start": "node ./bin/www",</span><br><span class="line">    "start": "nodemon ./bin/www"</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;</span><br><span class="line">    "body-parser": "~1.18.2",</span><br><span class="line">    "cookie-parser": "~1.4.3",</span><br><span class="line">    "debug": "~2.6.9",</span><br><span class="line">    "express": "~4.15.5",</span><br><span class="line">    "morgan": "~1.9.0",</span><br><span class="line">    "pug": "2.0.0-beta11",</span><br><span class="line">    "serve-favicon": "~2.4.5"</span><br><span class="line">  &#125;,</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "nodemon": "^1.19.2"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그 후에 start 명령어를 이용해 정상적으로 서버가 재실행이 되는지 확인한다. 여기까지 확인이 되었다면 로컬 내에서 개발하기 위한 NodeJS를 이용한 Mock API 서버에 대한 기본적인 환경은 갖춰졌다. 이후의 포스팅에서는  타입스크립트와 레디스(Redis)를 이용하여 Mock 데이터를 키-벨류(Key-Value) 형태로 저장할 수 있는 API 서버를 구축할 예정이다. 만약 간단하게 SUCCESS(성공)/FAILURE(실패)에 대한 결과만 클라이언트 앱에 던져주고자 한다면 여기까지 환경을 구축하여 컨트롤러(Controller)에 각각의 응답값을 정의해서 써보도록 하자. 이후의 단계에 대해서 궁금하신 분은 <a href="https://blog.martinwork.co.kr/nodejs/2019/09/20/nodejs-with-typescript02.html">다음 포스트</a>을 살펴보도록 하자. </p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="http://pm2.keymetrics.io/docs/usage/application-declaration/#environment-definition" target="_blank" rel="noopener">PM2 공식 홈페이지</a></li></ul>]]></content>
    
    <summary type="html">
    
      타입스크립트와 Express를 이용하여 간단한 MOCK 서버를 위한 환경을 구축한다.
    
    </summary>
    
      <category term="NodeJS" scheme="http://blog.martinwork.co.kr/categories/nodejs/"/>
    
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/tags/typescript/"/>
    
      <category term="Express" scheme="http://blog.martinwork.co.kr/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 라이브러리에 타이핑하기</title>
    <link href="http://blog.martinwork.co.kr/typescript/2019/08/25/declare-javascript-library-in-typescript.html"/>
    <id>http://blog.martinwork.co.kr/typescript/2019/08/25/declare-javascript-library-in-typescript.html</id>
    <published>2019-08-24T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h3><p>개인적으로 나는 타입스크립트를 아주 좋아한다. 좋아하는 데는 여러가지 이유가 있겠지만 가장 큰 이유는 아무래도 <code>타입을 통해 버그를 쉽게 잡을 수 있다</code> 라는 점 때문이었다. 타입스크립트를 이용하면 얻는 이점에 대해서는 해당 포스팅에서 따로 다루진 않는다. 이 글을 읽는 분이라면 대부분 이미 타입스크립트를 사용하며 얻는 이점에 대해 공감을 하여 타입스크립트를 도입하여 사용하고 있다고 생각한다. </p><p>하지만 그런 나조차도 가끔은 회의감이 들때가 있으니 그것은 바로 라이브러리에 대한 인터페이스이다. </p><p> <img src="/images/typescript/declare-javascript-library-in-typescript01.png" alt="생각지도 못한 정체"></p><p>물론 과거에 비해 요즘은 많은 라이브러리에 d.ts 파일이 존재하기도 하지만, 아직은 <code>제로 None d.ts 시대</code>는 아닌 것 같다. </p><blockquote><p>d.ts 파일은 말 그대로 구현되어져 있는 모듈에 대한 타입 선언 파일이다. 그러므로 모듈 구현과 타입 선언은 명백하게 분리해서 생각해야 한다. 모듈 구현 코드는 런타임에서 실제 돌아가는 동작부 코드이며, 타입 선언의 경우에는 컴파일되는 과정에서의 타입 검증을 위해 사용된다.</p></blockquote><p>이러한 경우에 직면할 때는 자바스크립트 라이브러리에 대해서 직접 인터페이스를 선언해줘야 한다. 물론 가끔은 다음과 같이 any 키워드를 이용하여 사용하는 경우도 있을 것이다. <del>귀찮음을 대변하는 타이핑이 아니라는 변명은 하지 않겠다</del></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> $: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br></pre></td></tr></table></figure><p>물론 jQuery 역시 @types가 존재하기는 하지만, 과거의 최신 버전의 jQuery가 아닌 경우는 미묘하게 타입이 일치하지 않는다. 한 예로 T사에 재직 중일 당시 리뉴얼 프로젝트에서 새로 개발되는 페이지의 경우 ReactJS + Typescript 조합을 이용하여 개발하였지만, 기존의 코드와의 의존성을 끊을 수가 없었다. 하지만 기존의 코드는 1.x.x대의 jQuery를 사용하고 있었는데, 이러한 코드에 대한 타입이 없기도 했으며 부분적인 코어 모듈에서만 사용하는 라이브러리이기 때문에 any 키워드로 뭉트그려도 타입 검증이 이뤄지지 않아도 상관이 없었다. </p><p><img src="/images/typescript/declare-javascript-library-in-typescript02.png" alt="저기 미안한데 귀찮아 짤"></p><p>사실 써드 파티 라이브러리의 경우, 대부분 자체적으로 단위 테스트가 붙어 있을 정도로 어느 정도 검증된 코드들인 경우가 많다. 물론 버그가 아예 없는 경우는 없지만, 어느 정도의 궤도에 올라온 라이브러리인 경우 이미 이슈로 등록되어있던가 혹은 스택 오버플로우에 해결 방법이 거의 대부분 나와있다. 그래서 시간이 부족하거나 정말 타이핑하기가 귀찮을 경우는 any 키워드로 때려넣은 적도 있다.</p><p><img src="/images/typescript/declare-javascript-library-in-typescript03.png" alt="자아 성찰 짤"></p><p>하지만 문제는 어플리케이션 내에 강력한 영향을 미치는 라이브러리이다. 일단 본격적으로 타이핑을 해보기 전에 선행 작업이 필요하다. tsconfig.json 파일에 다음과 같이 typeRoots에 타입 선언해줄 디렉토리를 추가한다. </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "typeRoots": [</span><br><span class="line">      "./node_modules/@types/",</span><br><span class="line">      "./@types" // 타입 선언해줄 디렉토리를 추가해준다.</span><br><span class="line">    ],</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="본격적으로-타이핑-해보기"><a href="#본격적으로-타이핑-해보기" class="headerlink" title="본격적으로 타이핑 해보기"></a>본격적으로 타이핑 해보기</h3><p>앞서와 같이 @types 디렉토리를 생성했다면 다음으로 타입을 선언해줄 d.ts 파일을 생성한다. 그 다음으로 사용하려는 라이브러리에 대하여 declare module 키워드를 이용하여 선언한다. 본 포스팅에서의 예제는 현재 사이드로 개발 중인 에디터 플랫폼에서 사용하는 써드 파티 라이브러리 중 하나인 editorjs의 의존성을 가진 라이브러리를 이용하여 작성하였다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@editorjs/header';</span><br></pre></td></tr></table></figure><p>일단 이렇게만 작성해도 거의 대부분이 끝났다. 위와 같이 선언만 해준다면 애플리케이션 내에서 문제 없이 사용할 수 있다. 하지만 이렇게 선언된 써드 파티 라이브러리의 타입은 any 타입을 가지게 된다. 만약 써드 파티 라이브러리의 타입 선언에 대해 더이상의 시간을 투자하고 싶지 않다거나 시간 관계상 현재 타이핑 하는 것이 현실적으로 불가능하다면 위와 같이 선언해도 문제는 없을 것이다.</p><p>하지만 개인적으로는 이러한 방식은 타이핑에 대한 문제를 해결하기 보단 그냥 회피하는 방법이라고 생각이 들었다.   </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@editorjs/header' &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; BlockToolConstructable &#125; <span class="keyword">from</span> <span class="string">"@editorjs/editorjs"</span>;</span><br><span class="line">  <span class="keyword">interface</span> HeaderConstructor <span class="keyword">extends</span> BlockToolConstructable &#123;</span><br><span class="line">    <span class="comment">// 이후 추가되는 인터페이스에 대해서는 해당 영역에 작성한다. </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> k: HeaderConstructor;</span><br><span class="line">  <span class="keyword">export</span> = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다행히도 내가 사용하는 editorjs 라이브러리 안에는 각각의 tools에 해당하는 constrructor에 대한 인터페이스가 존재하였기 때문에 그 안에서 상속받는 형태로 작성하였다. 이후부터 editorjs에 추가되는 플러그인에 대해서는 각각의 타입 선언 파일 내에서 선언하면 되지 않을까 한다. </p><h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p>대략적으로 자바스크립트 라이브러리에 타이핑을 하는 방법을 살펴보았다. 과거 불과 1년여 전만 해도 이러한 써드 파티 라이브러리에 대해 타이핑하는 것 때문에 타입스크립트 도입을 꺼려하는 개발자들이 많았다. 하지만 더 이상 타입스크립트의 도입에 반대하는 의견 중 가장 큰 원인이 써드 파티 라이브러리에 대한 타입이 원인이 되기는 힘들다는 생각이 든다. 물론 이것조차도 누군가에겐 부정적인 의견을 가질 수 있겠지만…</p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="noopener">타입스크립트 공식 홈페이지</a></li><li><a href="https://medium.com/naver-fe-platform/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EB%AA%A8%EB%93%88-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95-5bfc55a88bb6" target="_blank" rel="noopener">네이버 FE 플랫폼</a></li><li><a href="https://www.slideshare.net/gloridea/dts-74589285" target="_blank" rel="noopener">d.ts 만들기</a></li></ul>]]></content>
    
    <summary type="html">
    
      인터페이스가 없는 자바스크립트 라이브러리에 타이핑하기
    
    </summary>
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/categories/typescript/"/>
    
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/tags/typescript/"/>
    
      <category term="interface" scheme="http://blog.martinwork.co.kr/tags/interface/"/>
    
      <category term="d.ts" scheme="http://blog.martinwork.co.kr/tags/d-ts/"/>
    
  </entry>
  
  <entry>
    <title>흔한 주니어 개발자의 VueJS 책 집필기</title>
    <link href="http://blog.martinwork.co.kr/review/2019/07/18/publish-book-for-beginner.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/07/18/publish-book-for-beginner.html</id>
    <published>2019-07-17T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h3><p>이번에 처음 책을 집필하며 책 관련한 스터디를 여러 차례 진행하였습니다. 당시 스터디원을 모집하면서 간단하게나마 설문을 받았는데, 설문에 작성해준 내용에는 생각보다 많은 분들의 버킷리스트 혹은 목표가 책 집필인 경우가 많다는 것을 느꼈습니다. 그래서 이 글은 미래의 저자 분들을 위해 작성하였습니다. 이 글이 책을 집필하며 어려운 점이나 궁금한 점 혹은 조언이 필요한 분들에게 조금이나마 도움이 되었으면 좋겠고, 혹시라도 이외에도 도움이 필요하신 분은 언제든 이 글에 댓글 혹은 메일로 연락을 주시면 최대한 빨리 회신 드리도록 하겠습니다. 😁</p><p><img src="/images/review/publish-book-for-beginner02.png" alt="감사 인사"></p><p>일단 먼저 이 책을 쓰기까지 도움을 주신 김용기님, 백재연님, 이지만님, 김지영님, 김상열님, 박은정님, 윤경선님, 배수향님, 박지윤님, 이정재님, 박철현님, 허승님 모두에게 감사하며, 이 외에도 언급하진 않았지만 도와주신 모든 분들에게 이 기회를 빌어 감사하다는 말씀을 드립니다 :) (물론 이분들이 이 글을 볼지는 모르겠지만…😜) 무엇보다 공동 집필에 대한 제안을 흔쾌히 수락하고 10개월이 넘는 시간을 함께 고생해준 문동욱에게 고맙다는 인사 전합니다.</p><h2 id="뜻밖의-기회"><a href="#뜻밖의-기회" class="headerlink" title="뜻밖의 기회"></a>뜻밖의 기회</h2><p>과거 <a href="https://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html">2018년의 회고</a>에도 썼지만, 나에게 생각치도 못한 기회가 찾아왔다. 2018년 8월 30일, 뜬금없이 스팸 메일이 의심되는 메일을 받았다. 🤔</p><p><img src="/images/review/publish-book-for-beginner03.png" alt="책 집필 제안 메일"></p><p>그럴 수 밖에 없는게 일단은 이미 유명한 수많은 개발자들도 많은데 굳이 하찮은 나에게 연락을 했을까라는 생각이 앞섰기 때문이다. 무엇보다 나를 어디서 보고 연락을 했을까라는 의심이 들어 회신을 보내니, 과거의 올린 블로그 글을 우연치 않게 보게 되어 연락을 했다고 회신이 왔다. 아마 지인 개발자들에게 블로그의 중요성을 전파하기 시작한 때가 이때 이후부터였던 것 같다. 😎 </p><p><img src="/images/review/publish-book-for-beginner04.gif" alt="야너도?야나두!"></p><p>(이미 많은 개발자들을 위한 자기계발서 책에서도 블로그에 대한 긍정적인 효과에 대해서 설명을 하고 있기 때문에 굳이 여기에서 다시 언급하진 않지만, 사실 나는 직접적으로 블로그의 긍정적인 효과를 경험했기 때문에 더더욱 블로깅에 대해 적극적으로 홍보하고 있다.)</p><p>일단은 주변의 지인 개발자 분들도 책 집필 문의에 대해서 메일로 받았다라는 이야기를 몇 번 듣고는 의심의 눈초리가 한풀 식은 것도 있었다. 여튼 메일에 대한 확신이 든 순간에 큰 고민 없이 제안을 수락하였다. </p><p><img src="/images/review/publish-book-for-beginner05.jpg" alt="가즈아!!"></p><p>일단 받은 책 진행 프로세스에 대해서 받은 제안은 다음과 같았다.  </p><blockquote><ul><li>👉 최소 6개월에서 한두달 정도 조율하여 집필을 진행했으면 좋겠다.</li><li>👉 시작 전, 출판사쪽에서 보내주는 양식에 맞게 집필 계획서를 제출했으면 좋겠다.</li><li>👉 인세는 원고 탈고 후 50만원, 출간이 된 후 50만원 총 100만원의 선인세를 지급하겠다.</li><li>👉 초판은 1,500부에서 2,000부 정도 찍을 예정이며, 인세는 권당 책값의 10%를 지급하겠다.</li></ul></blockquote><p>주변에서 제일 많이 궁금해하는 것이 돈이었다. 🤑 다들 책을 쓰면 돈을 많이 번다고 생각을 하겠지만, 작업 기간 대비 금액은 거의 무보수라고 할 수준이다.  </p><p><img src="/images/review/publish-book-for-beginner06.jpg" alt="무보수 노동"></p><p>하지만 책을 쓰는데 가장 큰 의의는 쉽게 경험해보지 못할 짜릿한 경험을 해볼수 있었다라는 점에서 돈보다 더한 가치를 느꼈다. 일단은 수락하고 나서 바로 함께 사이드 프로젝트를 하던 친구에게 공동 집필 제안을 했다. 지금도 아마 이 친구는 모르겠지만, 당시 제안을 하기 전에 의견을 물어보고 나서 제안을 수락하겠다라고 말을 했다. 하지만 사실은 미리 공동 집필에 대해 출판사쪽에 이야기를 한 상태였다. 이 친구 또한 항상 새로운 경험을 추구하며 도전하는 친구이기 때문에 거절할 것이라는 생각은 하지 않았다는 점이 가장 컸다. 😉 </p><p>아마도 공동 집필을 하는 분들이 이 점이 가장 궁금할텐데, <code>공동 집필을 한다고 인세나 선인세가 2배가 되거나 하지 않는다.</code> 혹시나 공동 집필을 준비하려는 분은 꼭 이점 염두해두길 바란다.  </p><h2 id="집필-계획서-작성하기"><a href="#집필-계획서-작성하기" class="headerlink" title="집필 계획서 작성하기"></a>집필 계획서 작성하기</h2><p>집필을 시작하기 마음 먹고 출판사 쪽에도 뜻을 전달한 후, 바로 집필 계획서를 제출하라는 회신을 받았다. 그리고 나서 바로 집필 계획서를 쓰기 시작하였다. 일단 집필 계획서에는 출판사마다 조금씩 다를 수 있지만 나 같은 경우는 다음과 같은 내용을 기재해서 제출해달라는 요청을 받았다.</p><blockquote><ul><li>👉 도서명(또는 주제)</li><li>👉 작성자와 작성일 </li><li>👉 연락처 및 이메일</li><li>👉 제목(가제)</li><li>👉 책의 핵심 컨셉</li><li>👉 내용 요약 및 특징</li><li>👉 이 책과 관련된 기술의 동향</li><li>👉 타깃 독자층</li><li>👉 경쟁 도서 및 경쟁 도서와의 차별성</li><li>👉 원고의 탈고 날짜(3회에 걸쳐 탈고하며 1/3 분량씩 나눠서 제출하기 때문에 총 3번에 걸쳐 날짜를 기재해야한다.)</li></ul></blockquote><p>집필 계획서를 쓰기도 전에 마음 먹었던 컨셉은 <code>VueJS를 이용하여 실제 애플리케이션을 만들어보기</code> 였다. 나는 기술 서적 컬렉터여서 한달에 평균 10만원 어치의 기술 서적을 사모으는데, 사모은 책들을 보며 느꼈던 점은 많은 책들이 기술에 대한 API 등만 설명할 뿐 실제 응용해서 어떻게 써먹어야되는지에 대해서 다루는지 않는다는 점이 아쉬웠다. </p><p><img src="/images/review/publish-book-for-beginner07.jpg" alt="도서관 짤"></p><p>(10만원씩 꾸준히 언젠가는 도서관을 만들 예정이다🤤)</p><p>물론 그렇다고 그 책들을 보며 배울게 없다거나 혹은 그 안에 있는 내용을 모두 이해했다는 것은 아니다. 또한 모든 책들이 API에 대해서만 다루는 것이 아니라 응용하여 어떻게 내가 이 기술을 써먹어야지 좋은지에 대해서 설명해주는 좋은 책들 역시 많다. 하지만 이 책에서는 조금더 실무에 가까운 혹은 응용한다면 실무에서 바로 써먹을 수 있는 그러한 내용을 다루고 싶었다. 그래서 그때부터 열심히 집필 계획서를 작성하기 시작했다.</p><p><img src="/images/review/publish-book-for-beginner08.png" alt="디자이너의 고통1"></p><p>지금 이 글을 쓰며 오랫만에 집필 계획서를 살펴보았지만, 작명된 파일명을 보며 디자이너들의 고통을 조금이나마 이해할 수 있었다. 지금은 어떤 것이 최종본 집필 계획서인지 나조차도 알수가 없다… 거의 이정도면 디자이너의 흔한 최종 파일과 같은 느낌이랄까..</p><p><img src="/images/review/publish-book-for-beginner09.png" alt="디자이너의 고통2"></p><p>여튼 여차저차 대략적으로 한달 정도의 집필 계획서 끝에 출판사에서도 승인을 한 이후 본격적인 집필에 앞서 출판사의 담당자와의 미팅을 시작했다. 미팅에서는 주로 집필 계획서에 대한 내용과 계약서에 대한 대략적인 이야기 그리고 출판 계획 등에 대해서 이야기를 하였다. 그리고 몇일 뒤 출판사에서 최종 집필에 대한 승인이 떨어지고나서 계약서를 작성하였다. 10월 2일, 제안을 받고 나서 대략 2달 후 본격적으로 책 집필을 하기 시작하였다. 이때부터가 현기증 나는 책 집필이 시작될 것이라는 사실을 나는 몰랐다. </p><p><img src="/images/review/publish-book-for-beginner10.png" alt="타이슨 명언"></p><p>당시의 일정은 2018년 11월 30일 1차 탈고, 2019년 2월 28일 2차 탈고, 2019년 4월 30일 최종 탈고를 계획으로 시작되었다. 하지만 모두가 알듯 직장인에게 계획이란 큰 의미가 없었다.</p><p><img src="/images/review/publish-book-for-beginner11.png" alt="원티드 짤"></p><p>(<del>한 취업 포털 회사에서 정말 계획에 대해서 잘 대변해주고 있는 것 같다.</del>)</p><h2 id="본격적인-집필-시작"><a href="#본격적인-집필-시작" class="headerlink" title="본격적인 집필 시작"></a>본격적인 집필 시작</h2><p>본격적으로 집필을 시작하기에 앞서 먼저 시작했던 것은 포멧팅에 대한 규칙과 문체였다. 혼자 집필하면 아무 상관이 없었지만 공통 집필을 하게 되면 가장 큰 문제는 각자 쓰는 문체가 다르다는 것이었다. 그래서 대략적인 문체와 문서에 대한 포멧팅을 정하기 시작했다. 처음에 정한 규칙은 다음과 같았다.  </p><blockquote><ul><li>👉 “기본 형식은 이와 같다”를 기준으로 모든 문체는 평서형을 기준으로 작성한다. </li><li>👉 이미지 내에 화살표나 박스를 추가한 경우 원본 이미지와 함께 “(line)” 폴더명을 함께 기재한다.</li><li>👉 코드나 이미지 다음 문장에는 한 열씩 띄어쓴다.</li><li>👉 제목과 단락에 대한 폰트 사이즈 규칙은 통일한다. </li></ul></blockquote><p>규칙을 정한 이후로는 구글 독스를 이용하며 하나씩 작성하기 시작했으며, 서로 작성한 글을 읽어보며 어색한 문제에 대해서는 구글 독스의 댓글 형태로 남기기로 하였다. 하지만 이러한 방식은 한 챕터 3개 정도 쓰다가 교체되었다. 구글 독스에다가 쓰는 것이 불편하다. README로 작성하게 해달라라는 공동 집필하는 친구의 의견 때문이었다. 찾아본 결과 pdf 혹은 docx 파일로 제너레이팅 해주는 모듈이 있고, 오히려 README 문법으로 글을 쓰면 더 나은 파포먼스를 낼수 있을거라고 판단해 나 역시 동의했다.  책을 집필하며 나중에 작성해야할 내용이나 놓치고 잇던 부분들은 이슈로 남겨두었고, 각자 쓴 글에 대해서는 서로에게 PR을 날려 서로의 글에 대해서 리뷰를 진행하였다. 하지만 이게 나중에는 엄청난 혹으로 돌아왔다. 😅 혹시나 책을 집필하려는 분들 중 README로 작성한 후 모듈을 통해 변환하려고 하신다면 나는 적극적으로 말리고 싶다. 우리가 하고자 하는 포멧을 세부적으로 조절할 수 없을 뿐만 아니라, 코드 역시 포멧팅이 다 깨져 결국에는 수작업으로 옮겨와야만 했다..</p><p><img src="/images/review/publish-book-for-beginner12.png" alt="어이가 없네"></p><p>책을 진행하며 총 2차례에 걸쳐 일정이 밀렸지만 가장 큰 이유는 포멧팅 문제도 문제였지만 직장은 다니면서 책을 쓴다는 것이 생각보다 쉽지 않았다. 책을 집필하기 이전에 한 회사의 개발자로서 회사 내에서의 역할 역시 무시못할 중요한 일이었다. 책을 집필하는 시기와 이직하는 시기가 겹쳐 이직한 후 새로운 조직에 적응하는 것도 일이었지만, 새로운 조직에서 담당하게 된 프로젝트의 일정 역시 책을 집필하는 시기와 맞물렸다. 회사의 프로젝트에 소홀할 순 없으니 결국에는 책을 집필하는 것에 소홀해질 수 밖에 없었다. 😒</p><h2 id="베타-리딩-스터디-모집"><a href="#베타-리딩-스터디-모집" class="headerlink" title="베타 리딩 스터디 모집"></a>베타 리딩 스터디 모집</h2><p>처음 책을 쓰다보니 우리 책이 실제 대상 독자군들에게 어떻게 다가갈 수 있을지에 대해 명확하게 확신이 들지 않았기 때문이다. 아마 책을 처음 쓰는 분들이 공통적으로 고민하는 부분이 아닐까 싶다. 그래서 실제 우리 책에서 독자를 하는 분들을 모시고 스터디를 진행하기로 했다. 직접 옆에서 집필된 책을 보며 공부하며 어려움을 겪는 부분에 대해서 조언을 드리고, 우리는 그 부분에 대해서 조금더 쉬운 표현으로 바꾸거나 지나친 부분들에 대해서 내용을 추가하기 위해서 였다. </p><p><img src="/images/review/publish-book-for-beginner13.png" alt="I Want to you"></p><p>그렇게 2월 VueJS 커뮤니티와 하코사에 글을 올려 스터디원을 모집하기 시작했다. 대략 1주일 정도 모집을 하였지만, 이렇게 많은 분들이 지원해주실지는 상상도 못했다. 이 글을 읽고 계신 분들중 당시 스터디 신청한 분들도 계실지 모르겠지만 130명이 넘는 인원이 지원을 하였다.</p><p><img src="/images/review/publish-book-for-beginner14.png" alt="저요저요"></p><p> 공간상의 이유로 모든 분들을 다 모시지 못하고, 그 중에서도 책에서 독자 타켓팅이 되는 분들에게 연락을 드렸다.(당시 이메일을 기재해주신 분들에게는 한분한분 죄송하다는 메일을 드렸지만, 혹시 그때 연락을 받지 못한 분들에게는 다시 한번 스터디에 관심을 가져주셔서 감사하고, 함께 하지 못해 죄송하다는 말씀을 드리고 싶다.) 그렇게 2달동안 스터디를 진행하였다.  당시 스터디를 진행하면서 책 뒷부분들은 계속해서 집필을 하고 잇었는데 집필 속도를 따라 잡는데는 얼마 걸리지 않아 오히려 책을 씀과 동시에 리뷰를 진행하기도 했다.😅 그렇게 2달동안 수많은 오타와 수정을 반복하여 6월 드디어 최종 탈고를 하였다. 처음 최종 탈고를 하기로 한 4월 30일에 비해 거진 두달이나 밀린 일정이었지만, 담당자분에게 들어보니 이정도면 양호하다는 이야기를 들었다. <del>실제 집필하시는 분들이 반년 이상 밀리는 경우도 많다고 한다</del></p><h2 id="끝을-향한-마지막-여정"><a href="#끝을-향한-마지막-여정" class="headerlink" title="끝을 향한 마지막 여정"></a>끝을 향한 마지막 여정</h2><p>책을 다쓰고나서 이제 본격적으로 책 제목에 대해서 고민하게 된다. 책을 쓰기 전에는 책 제목을 확정 짓고 책을 써야하는지 알았지만, 막상 진행해보니 내용을 다쓰고 나서 정한다는 점이 의외였다. 책 제목을 정하면서 정말 재미있는 의견도 많이 나왔지만, 작명 센스가 없는 나로서는 책 제목을 정하는게 고역이 아닐수 없었다. 그래서 주변 지인들의 의견과 무엇보다 출판사 담당자 분의 의견이 책 제목을 짓는데 가장 큰 힘이 되어주었다. 그렇게 책 제목은 커피 한잔 마시며 끝내는 VueJS로 확정 지었다😊</p><p>책을 최종 탈고 및 책 제목도 확정짓게 되면 이제 출판사 쪽에서 책의 컨셉에 맞게 책 내부의 디자인과 책 표지를 디자인 하여 몇가지 시안을 보내준다. 내가 받은 시안은 아래와 같이 총 3가지 였다. 아무래도 책 제목을 반영한 디자인이지 않나 싶다.</p><p><img src="/images/review/publish-book-for-beginner15.png" alt="저요저요"></p><p>결국 이중에 주변 지인분들의 조언을 통해 2번 시안으로 최종 결정하였다.</p><p>이때까지만해도 책을 다썼다라는 실감이 되지는 않는다. 정말 책을 썼구나 라고 실감하던 때는 서문과 작가소개를 쓸때였던 것 같다. 그 동안 책을 사서 보면 서문을 그렇게 주의 깊게 읽지 않앗는데 서문에 책에 대한 저자의 생각이 가장 많이 들어간다라는 점을 서문을 작성하면서 느꼈다. 책을 쓰며 어떠한 생각을 가지고 썼는지, 어떠한 분들에게 어떠한 지식을 전달해드리고 싶었는지에 대해서 정말 많은 고민을 하게 되는 시간이었다. 그리고 무엇보다 서문을 작성하며 느낀 것이지만, 이 책을 쓰기까지 너무 많은 분들의 도움이 있었구나를 느꼈다. </p><p>그렇게 뒷표지 문구, 찾아보기, 저자 소개, 서문 그리고 전체 책에 대한 검토를 마치고나서야 드디어 7월 19일 책 집필에 대해 마무리를 하게 되었다.</p><h2 id="책을-집필을-마치며"><a href="#책을-집필을-마치며" class="headerlink" title="책을 집필을 마치며"></a>책을 집필을 마치며</h2><p>주변에서도 나와 같은 집필에 대한 제안을 받는 분들을 심심치않게 볼수 있다. 하지만 대부분의 분들이 내 지식에 대해 누가 궁금해할까 하는 부담감으로 인해 재안을 거절한다고 한다. 나 역시도 그러한 부담감을 갖지 않은 것은 아니였다. 혹여라도 누군가에게 잘못된 지식을 전달하면 어떻게 하지 혹은 한문장 한문장이 다른 누군가에게 불편하면 어떻게 하지 라는 걱정이 많이 들엇다. 하지만 반대로 그러면서 글을 쓰는 방법과 내 의도를 효과적으로 전달하려면 어떻게 해야하는지에 대해서도 고민을 하게 되엇고, 무엇보다 모르는 지식들을 나역시도 누군가에게 전달하기 위해 공부해나가기 시작했다. 오히려 책상에 앉아 혼자 공부하는 시간보다 책을 쓰며 보낸 시간이 더 많은 성장을 이루지 않았나라는 생각을 한다. 혹여하도 집필을 준비한다던가, 혹은 제안을 받은 분들이 이 글을 읽고나서 집필에 대한 결정을 하는데 도움이 되었으면 한다. </p>]]></content>
    
    <summary type="html">
    
      기술 서적을 집필하려는 또다른 초보 개발자를 위하여 &#39;커피한잔 마시며 끝내는 VueJS&#39;를 집필하며 겪었던 과정에 대해서 포스팅하였습니다.
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="커피한잔마시며 끝내는 VueJS" scheme="http://blog.martinwork.co.kr/tags/%EC%BB%A4%ED%94%BC%ED%95%9C%EC%9E%94%EB%A7%88%EC%8B%9C%EB%A9%B0-%EB%81%9D%EB%82%B4%EB%8A%94-vuejs/"/>
    
  </entry>
  
  <entry>
    <title>2019년 상반기의 회고</title>
    <link href="http://blog.martinwork.co.kr/review/2019/07/04/the-first-half-year-remembrance.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/07/04/the-first-half-year-remembrance.html</id>
    <published>2019-07-03T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.557Z</updated>
    
    <content type="html"><![CDATA[<p>2019년에 들어 새로운 활동을 시작하였다. 그리고 2019년 상반기에 대한 회고를 작성하는 것이 그 활동이 첫 시작이었다. 때마침 하반기가 시작됨에 따라 올해의 하반기 목표를 되새기고자 회고를 작성하게 되었다.</p><h2 id="2월-프로젝트의-달"><a href="#2월-프로젝트의-달" class="headerlink" title="2월, 프로젝트의 달"></a>2월, 프로젝트의 달</h2><p>2월 26일, 새로운 조직에 입사하고 난 후 담당하게 된 프로젝트를 성공적으로 오픈하였다. 이커머스 특성상 회사에서는 물건을 구매하기 전의 프로세스와 물건을 구매하는 프로세스 그리고 물건을 구매하고 난 이후의 프로세스 세 가지 프로세스로 나누어지는 데, 이번에 진행한 프로젝트의 경우 상품 구매 이후의 프로세스에 대해서 이해할 수 있는 프로젝트로서 쉽게 이야기하여 “구매내역”과 “구매한 상품에 대한 일련의 클레임”이 포함돼 있다.</p><p><img src="/images/review/the-first-half-year-remembrance01.png" alt="/images/review/the-first-half-year-remembrance01.png"></p><p>이 프로젝트는 나에게는 감회가 새로운 프로젝트이기도 했다. 새로운 조직에 합류한 후 처음 오픈하는 프로젝트라는 점도 있지만 제일 큰 점은 ReactJS 생태계에 처음 발을 들였다는 점이다. 이전에는 ReactJS를 사용해본 경험이 없어 프로젝트를 시작과 동시에 문법부터 공부하기 시작했다. 회사에서 세미나 발표에서도 이야기 했지만, ReactJS를 이용하여 프로젝트를 진행하며 제일 기억에 남는 것은 온갖 종류의 써드 파티 라이브러리를 접할 수 있다라는 점이다. 이번 프로젝트는 상태 관리 시스템을 Redux를 선택하였는데, Redux를 선택하기 전에도 Redux와 Mobx 사이에서 많은 고민을 하기도 했다. 그런데 막상 Redux를 선택하고 나니 다시 redux-thunk냐 redux-saga냐의 갈림길에 빠지게 되는 한마디로 매 순간이 선택의 기로에 빠지게 만들었다. </p><p><img src="/images/review/the-first-half-year-remembrance02.png" alt="/images/review/the-first-half-year-remembrance02.png"></p><p>개인적으로는 상태 관리나 라우트와 같이 주요한 라이브러리는 정해져있고, 사용할지 말지만 결정하면 되는 VueJS와는 대비되는 점에서 약간의 거부감이 들기도 했던 시점이기도 했다. 물론 회사의 기술 스택 선택은 자유롭기 때문에 처음 프로젝트를 들어가기 전에 꼭 ReactJS가 아닌 VueJS로 개발을 해도 상관은 없었지만, 회사 내에 개발되는 대부분의 프로젝트들이 ReactJS로 개발이 되고 있기 때문에 ReactJS로 개발을 시작하였다. 개인적으로는 프로젝트 안에서의 타입 시스템은 휴먼 에러를 위한 최소한의 방어선이라고 생각하기 때문에 타입스크립트를 도입하여 사용하였다. 조직 안에서 처음 프로덕션 레벨에 타입스크립트를 도입한 이후로 점점더 타입스크립트로 개발되는 프로젝트들이 많아 개인적으로는 또 하나의 보람을 느끼기도 했다.</p><h2 id="3월-본격적인-TDD-프로그래밍"><a href="#3월-본격적인-TDD-프로그래밍" class="headerlink" title="3월, 본격적인 TDD 프로그래밍"></a>3월, 본격적인 TDD 프로그래밍</h2><p>3월은 테스트 코드와 친해지기 위해 고군분투하였다. 2월에 사내에서 프로젝트를 오픈하고 나서는 여유가 생겨 기존에 작성돼 코드에 테스트 코드를 붙이기 시작하였으며, 오픈 이후에 들어오는 스펙에 대해서는 TDD 프로그래밍 방식으로 개발을 하기 시작하였다. 테스트 코드를 작성하게 된 계기는 아무래도 리팩토링 시 생길 수 있는 사이드 이펙트에 대한 안정성을 보장받기 위해서였던 것 같다. 아무래도 일정과 익숙하지 않은 환경에서의 개발로 인해 프로젝트를 오픈한 이후에는 개선해야 할 코드들이 많았기 때문에 주기적으로 리팩토링을 하여 배포를 했다. 리팩토링 과정에서 매번 QA의 도움을 기대할 수 없었기 때문에 예측 범위 내에서의 코드 수정을 해야만 했다. 그러한 사이드 이펙트에 대한 예측 가능성을 테스트 코드를 통해 높여나갔다. </p><h2 id="4월과-5월-현기증-나는-책-집필"><a href="#4월과-5월-현기증-나는-책-집필" class="headerlink" title="4월과 5월, 현기증 나는 책 집필"></a>4월과 5월, 현기증 나는 책 집필</h2><p>   4월에는 집필하고 있던 VueJS 서적의 대상군을 모집하여, 집필된 책에 대한 코멘트를 받고자 VueJS 스터디를 진행했다. 페이스북의 <a href="https://www.facebook.com/groups/vuejs.korea/?ref=bookmarks" target="_blank" rel="noopener">VueJS Korea</a>와 <a href="https://cafe.naver.com/hacosa" target="_blank" rel="noopener">하코사</a>에 글을 올려 사람들을 모집했는데, 감사하게도 대략 130명이 넘는 많은 분들이 지원을 해주셨다. 죄송하게도 공간상의 이유로 모든 인원과 함께 할 수 없어 집필하는 책의 대상군을 선별하여 함께 스터디를 진행하였다. 대략 3달 정도 진행을 했는데 신중하게 선별해서 그런지 모든 분들의 참여율이 거의 100%에 가까웠으며, 책에 대한 코멘트 역시 적극적으로 해주셨다. </p><p>   그렇게 5월, 함께 스터디를 진행한 분들의 코멘트까지 모두 반영하여 책의 집필이 모두 끝났다. 아니, 끝난지 알았다… </p><p>   <img src="/images/review/the-first-half-year-remembrance03.png" alt="/images/review/the-first-half-year-remembrance03.png"></p><p>스터디가 끝난 후 본격적인 기술 감수 및 베타리딩을 위해 베타 리더분들께 책을 발송하기 시작했다. 그리고 2주 만에 100개가 넘는 수많은 수정 사항들을 남겨주셨다.. 이러한 이유에는 베타 리더분들의 기대 이상의 관심을 보여주셨고, 모든 분들이 책을 꼼꼼하게 봐주셨기 때문이 아닐까 싶다. 물론 이러한 이유로 결국 최종 탈고가 한 달 미뤄지는 상황이 생겼지만, 다행히도 출판사의 담당자분이 양해를 해주셨다. 그렇게 5월 내내 책을 탈고하기 위해 고군분투했다.<br>   (이 글을 보실지는 모르겠지만, 이 기회를 빌어 스터디 참여에 지원해주신 분, 스터디에 참여해주신 분 그리고 베타리딩 해주신 분들 모두에게 감사하다는 인사드립니다.) </p><h2 id="6월-상반기의-마지막-달"><a href="#6월-상반기의-마지막-달" class="headerlink" title="6월, 상반기의 마지막 달"></a>6월, 상반기의 마지막 달</h2><p>   그리고 6월, 최종 수정본을 받아 드디어 책을 출판사에 넘겼다. 2018년 8월부터 시작하여 10개월 동안 준비를 했지만 아쉬움이 많이 남았다. 한 문장 한 문장에 대해 고민을 많이 하기도 했지만 혹시나 “틀린 정보를 전달하면 어떻게 하지?”라는 두려움을 가진 채 글을 쓰다 보니, 생각보다 10개월이라는 시간이 길게 느껴지지 않았다. 물론 최종 탈고를 미룰 수도 있었지만, 기간이 늘어난다고 더 좋은 책을 쓸 수 있다는 확신이 들지 않았다. 그리고 무엇보다, 한평생에 쓸 글을 10개월 사이에 쏟아내듯 작성했기 때문에 책상에 앉아 인내심 있게 글을 쓸 수 있을 것 같지도 않았다. 책에 대한 자세한 이야기는 책이 출판된 이후에 별도의 회고로 작성하지 않을까 싶어 할 말은 많지만 더 이상 말하진 않는다…</p><p>   그리고 VueJS 집필 스터디의 좋은 인연으로 생각지도 못한 좋은 경험을 하게 될 기회가 생겼다. 함께 스터디 하던 분들 중 한분이 “멋쟁이 사자처럼”의 운영진으로, 해커톤을 주최하게 되었는데 그 해커톤에 연사로 참여할 기회가 생겼다. 해커톤의 자세한 참여 후기는 여기에서 별도로 다루진 않지만 혹시나 궁금하신 분들을 위해 <a href="https://blog.martinwork.co.kr/review/2019/06/01/likelion-hackerton.html">링크</a>는 남겨둔다. 내 스스로 아직 이뤄놓은 것도 없는데, 누군가 앞에서 나의 경험을 이야기한다는 것은 하나의 부담이기도 했지만, 보잘것없는 나의 이야기로 인해 다른 누군가에게 긍정적인 영향을 미칠 수도 있다는 점이 또 하나의 매력이기도 했다. 앞으로 이런 기회가 또 올지는 모르겠지만, 조그마한 나의 경험이 다른 누군가에게 도움 줄 수 있는 기회가 생긴다면 또 하지 않을까는 생각을 해보기도 했다.</p><h2 id="상반기를-돌아보며-하반기는…"><a href="#상반기를-돌아보며-하반기는…" class="headerlink" title="상반기를 돌아보며, 하반기는…"></a>상반기를 돌아보며, 하반기는…</h2><p>돌이켜보면 생각보다 상반기에 적은 것 같으면서도 많은 일을 한 것 같다. 올해 초, 상반기와 하반기로 나누어 두루뭉실하게나마 올해의 목표를 세운 적이 있다. 상반기에는 책 집필 완료였고, 하반기에는 본격적으로 기술 부채를 해결하는 것과 영어 공부였다. 7월의 시작과 동시에 영어 공부를 시작하였고, 기술 부채를 기록하기 위한 새로운 커뮤니티를 시작하였다. </p><p>새로 시작한 모임은 글또 라는 <a href="https://www.facebook.com/zzsza" target="_blank" rel="noopener">변성윤</a>님이 주최하는 커뮤니티로서 여러 분야의 개발자들이 모여 주기적으로 블로깅을 하는 모임이다.</p><p><img src="/images/review/the-first-half-year-remembrance04.png" alt="/images/review/the-first-half-year-remembrance04.png"></p><p>사실 어색한 분위기를 못 견뎌하기 때문에 새로운 사람들과의 만남에 있어 엄청난 부담감을 가지고 있지만 다행히도 모임은 처음과 마지막만 오프라인으로 진행하고, 나머지는 온라인으로 진행하기 때문에 이러한 부담감을 덜 할것 같아 참여를 하게 되었다. 앞으로 구체적으로 어떠한 글을 쓸지는 미지수이지만, 대략적인 방향은 회사에서의 트러블 슈팅 혹은 내가 배워나가는 개발 지식들에 대해서 글을 쓰지 않을까 싶다 :)</p><p>이제 하반기가 시작되었다. 과거 <a href="https://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html">2018년의 회고</a>와 같이 아마도 별일이 없다면 2020년이 되기 전 2019년의 회고를 작성하지 않을까 싶다. 그리고 그 글을 작성할 때는 “상반기보다 조금 더 보람찬 하반기를 보낸 한 해였다”라는 글을 쓰고 싶다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019년에 들어 새로운 활동을 시작하였다. 그리고 2019년 상반기에 대한 회고를 작성하는 것이 그 활동이 첫 시작이었다. 때마침 하반기가 시작됨에 따라 올해의 하반기 목표를 되새기고자 회고를 작성하게 되었다.&lt;/p&gt;
&lt;h2 id=&quot;2월-프로젝
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="회고" scheme="http://blog.martinwork.co.kr/tags/%ED%9A%8C%EA%B3%A0/"/>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>멋사 해커톤 참여기</title>
    <link href="http://blog.martinwork.co.kr/review/2019/06/01/likelion-hackerton.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/06/01/likelion-hackerton.html</id>
    <published>2019-05-31T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.555Z</updated>
    
    <content type="html"><![CDATA[<p>2019년 6월 1일, 경희대학교에서 <code>멋쟁이 사자처럼</code>의 일부 운영진들이 진행하는 대학생 해커톤이 열렸다. 해커톤에는 대략적으로 50여명 정도의 대학생이 참여를 했으며, 나는 그 해커톤의 연사로 참여를 하게 되었다. 사실 연사라고 표현하기에는 너무 거창하고 스스로가 부족하다고 생각하여 그냥 해커톤에서 대학생들의 시간을 뺏는 사람 정도였다라고 생각한다 😅</p><p>일단 글을 시작하기 전에 이러한 좋은 기회를 준 멋쟁이 사자처럼의 운영진 분들과 함께 연사로 참여해준 숨고의 동욱님, 그리고 티몬에서 함께 일을 하는 철현님, 허승님께 감사하다는 말을 드리고 싶다. 🙏 (물론 그 분들이 이 글을 볼지는 미지수이지만.. 🙄) </p><h2 id="어떠한-질문을-받았니"><a href="#어떠한-질문을-받았니" class="headerlink" title="어떠한 질문을 받았니?"></a>어떠한 질문을 받았니?</h2><p>연사분들과 함께 해커톤을 진행 중인 장소 안으로 들어가기 전까지만 해도 다들 걱정이 많았다. 무엇보다 우리가 어떠한 질문을 받을지, 어떠한 주제로 라이트닝 토크가 진행되는지, 우리에게 무엇을 기대하는지 어떠한 가이드도 받지 못했기 때문이다. 하지만 막상 들어가서 우리의 걱정이 기우였다는 것을 깨닫기까지는 얼마나 걸리지 않았다. </p><p>소개가 끝나고 나서 바로 첫 질문을 받기 시작했을 때는 2분 정도 밖에 손을 들지 않아 속으로 “생각보다 우리에게 질문이 별로 없구나. 괜히 시간을 뺏는게 아닐까?” 라는 걱정을 했다. 하지만 첫번째 질문에 대한 답이 끝나고 나서 두번째 질문을 받는다고 했을 때, 7분이 넘는 분들이 질문을 위해 적극적으로 손을 들었다. </p><p><img src="/images/review/likelion-hackerton-review01.jpg" alt="/images/review/likelion-hackerton-review01.jpg"></p><p>그 모습을 보고 한편으로 “과연 나는 사람들이 많이 모인 공적인 자리에서 남들 앞에서 용기내어 누군가에게 질문을 한적이 있었던가?” 라는 생각이 들 정도로 깜짝 놀랐다. 대학생분들이 우리에게 궁금했던 것은 다음과 같았다. </p><blockquote><ul><li>👉 개발자라는 직업을 선택할 때, 비전공자로서의 두려움은 없었나요?</li><li>👉 개발자/기획자가 되기 위해 어떻게 공부 혹은 노력을 했나요?</li><li>👉 언제 “개발자/기획자로서의 길이 내 길이다” 라는 확신이 들었나요? </li><li>👉 이후 취업을 하기 위해 어떤 언어/프레임워크를 공부하면 될까요?</li><li>👉 성장을 할 때 가장 중요한 것은 무엇이라고 생각하나요? </li><li>👉 해외 취업을 하기 위해서는 어떠한 준비를 해야할까요?</li><li>👉 중소기업에 들어가면 대기업으로 이직하기 힘들다고 하는데 그럼 첫회사는 대기업으로 가야할까요?</li><li>👉 지금 회사에서 나를 뽑아준 이유는 뭐라고 생각하시나요?</li></ul></blockquote><h3 id="개발자로서의-내-모습은…"><a href="#개발자로서의-내-모습은…" class="headerlink" title="개발자로서의 내 모습은…"></a>개발자로서의 내 모습은…</h3><p>사실 돌이켜보면 누구나 한번쯤은 고민했을 법한 주제이다. 하지만 나는 부끄럽게도 적어도 대학생 때는 이러한 고민과 불안감을 가지지 않았다. 어떻게 보면 커리어에 대해서 그들만틈 진지하게 생각해보지 않았을 수도 있다. 내가 개발자로서의 길을 선택한 것은 <code>나 스스로 보기에도 개발을 할 때의 내 모습이 다른 일을 할 때보다 즐거워보인다</code>라는 단순한 이유였다. </p><p>물론 이렇게 이야기하면 일부 사람들은 나에게 “그건 괜찮은 환경에 있어서 즐겁다고 느낄 수 있었던 거 아니에요?”라는 역질문을 던질 때가 있다. 하지만 처음 개발 공부를 흥미를 갖고 시작했던 회사는 10명도 채 안되는 조그마한 에이전시였다. 다른 에이전시에 비해 특출날 것 없이 고객사에 뜻대로 작업을 해야하며, 고객사가 원하면 의미없는 야근도 감수해야 했으며, 깊은 지식을 요하는 작업을 하는 것도 아니였다. 그럼에도 불구하고 새로운 것을 공부하는 것이 즐거워 고시 공부하듯 남들보다 빠르게 출근해서 공부를 하고, 퇴근하고 나서도 미친듯이 공부를 했다. (이때가 나의 멘토를 만나게 된 시점과도 비슷한 시점이다.) 아마 이때가 엘런 머스크의 <code>80시간의 법칙</code>을 지켰던 유일한 기간이 아닐까 싶다. (요즘에는 조금 나태해져 80시간까지 채우기는 쉽지 않다.😰)</p><p><img src="/images/review/likelion-hackerton-review02.jpg" alt="/images/review/likelion-hackerton-review02.jpg"></p><p>물론 세상을 바꾸기 위해 공부를 했던 것은 아니다. 단지 내가 좋아하는 분야에 대해 무지한 내 스스로에게 실망하기 싫었기 때문이다. 그렇기 때문에 나에게 있어 비전공자로서의 두려움 혹은 선택에 대한 확신을 생각했던 적도 없었던 것 같다. 말 그대로 좋아서 했던 하나의 취미가 곧 내 일이되었기 때문이다.</p><p><img src="/images/review/likelion-hackerton-review03.jpg" alt="/images/review/likelion-hackerton-review03.jpg"></p><p>무엇보다 앞서의 질문과 같이 성장이 환경에서 나온다고 생각하진 않는다. 물론 이에 대해서는 사람마다 생각하는게 다를 수 있지만, 개인적으로는 스스로 느끼기에 환경이 불만족스럽다라고 하면 환경을 개선하기 위해 최소한의 노력은 해봐야 한다고 생각한다. 물론 개인의 힘으로 환경을 바꾸기란 쉽지 않다. 만약 동료들이 역시 환경을 개선해야한다는 필요성을 느끼면서도 함께 행동하지 않거나 혹은 최악의 경우 동료가 비관주의자라면 그땐 더 좋은 환경을 위해 떠나는게 맞다. 하지만 노력에 따라 개선의 여지가 있다면 환경을 탓하기보단 한번쯤은 나의 주변 환경을 바꾸기 위한 노력을 해봐도 되지 않을까.</p><h3 id="무엇을-공부해야-할까"><a href="#무엇을-공부해야-할까" class="headerlink" title="무엇을 공부해야 할까?"></a>무엇을 공부해야 할까?</h3><p>주기적으로 한 커뮤니티에 제일 많이 올라오는 글 중 하나는 “무엇을 공부해야하나요?” 라는 질문이다. 주기적으로 이런 글이 올라온다는 것이 이제는 놀랍지도 않다. 과거의 회사에서는 VueJS와 타입스크립트를, 현재의 회사에서는 ReactJS와 타입스크립트 조합을 이용하여 개발을 하고 있지만, 단 한번도 프레임워크에 대해서 공부한 적이 없다. 아니, 엄연히 말하면 프레임워크를 학습하고 난후 회사를 입사하거나 혹은 프로젝트를 진행한 적이 없다.  </p><p><img src="/images/review/likelion-hackerton-review04.jpg" alt="/images/review/likelion-hackerton-review04.jpg"></p><p>지금 돌이켜보면 놀라운 사실은 전회사에서 VueJS를 이용한 프로젝트를 진행할 때는 VueJS라는 것을 처음 들어봤으며, 지금 회사의 대부분의 팀이 ReactJS를 이용하여 개발을 하지만 회사를 입사할 때는 ReactJS의 존재유무만 알았을 뿐 문법조차 몰랐다. 회사에서 쓰기 전까지는 사실 관심도 가지지 않았으며 공부를 해야할 필요성도 느끼지 못했다. 평소에 내가 공부하는 것들을 대체적으로 회사 서비스에 사용하는 기술이거나 현재 진행 중인 프로젝트에 도입을 해야하는 것 혹은 진행했던 프로젝트를 개선하기 위한 기술들이다. </p><p>언젠가 지인과 이야기 하다 2가지 유형의 개발자라는 주제를 가지고 이야기한적이 있다. 첫번째 유형은 플랫폼 성향이 강한 개발자이고, 두번째 유형은 비즈니스 성향이 강한 개발자였다. 첫번째 유형의 개발자는 새로운 기술에 대해 관심이 많으며, 끊임없이 신기술들에 대해 학습을 한다. 반대로 두번째 유형의 개발자는 새로운 기술보다는 비즈니스에 관심이 많다. 이 중 개인적으로 나는 두번째 유형에 가까운 개발자인 것 같다. 그렇기 때문에 개인적으로 학습하는 모든 기술은 회사에서 진행하는 혹은 사이드 프로젝트를 위한 기술이다. </p><p>이러한 예 중 기억나는 것은 바로 타입스크립트 도입이었다. 자바스크립트는 동적 언어기 때문에 특성상 자료형이 실행시 결정된다. 그렇기 때문에 자바스크립트를 이용하여 개발할 때 제일 많이 겪는 에러 중 하나는 타입 에러이다. 이러한 에러로 인해 기능이 제대로 작동하지 않을 때도 있으며, 이러한 에러를 찾기 위해서는 실제 실행시켜봐야 알 수 있다보니 에러를 찾고 수정하는 데 까지 걸리는 시간이 길 수 밖에 없다. 이러한 단점은 개발 생산성을 떨어트릴 뿐만 아니라 리팩토링할 때에도 흔히 이야기하는 몸 사리는 코딩을 하게 만들었다. 이러한 문제의 돌파구로 찾은 것이 타입스크립트였다. 타입스크립트는 개발자로 하여금 컴파일 단계에서 타이핑 에러를 감지했으며, 인터페이스로 하여금 전보다 더 예측 가능한 애플리케이션을 만들 수 있도록 했다.</p><p>물론 프레임워크나 라이브러리를 깊이 알고 잘 쓴다고 한다면 더할 나위 없이 좋다. 하지만 근본적으로는 대부분의 기술은 어떠한 문제를 해결하기 위해 나온다. 마치 자바스크립트의 동적 타입에 불편함을 느끼고 정적 타입 시스템을 도입하기 위해 나온 타입스크립트라던지, 혹은 브라우저의 DOM을 효율적으로 업데이트 하기 위한 Virtual DOM 개념, 클라이언트의 싱태를 효율적으로 관리하기 위한 flux 패턴과 거기서 파생된 Vuex, Redux 등과 같다. 그렇기 때문에 막연하게 불나방처럼 기술에 달려드는 것보단 기술의 본질에 대해서 공부를 하고, 필요한 시점이 되었을 때 적재적소에 사용하는 것이 어떨까라는 생각을 한다. </p><h3 id="멘토-혹은-함께하는-동료-만들기"><a href="#멘토-혹은-함께하는-동료-만들기" class="headerlink" title="멘토 혹은 함께하는 동료 만들기"></a>멘토 혹은 함께하는 동료 만들기</h3><p>나는 개인적으로 학원에 대해 마냥 긍정적인 입장은 아니다. 일단은 학원은 상업 기관임에도 마치 교육기관처럼 탈바꿈하려고 하는 것도 그렇지만, 제일 큰 이유는 “X주 완성하기”와 같은 허위 혹은 과대 광고 때문이다. (물론 모든 학원이 그렇다는 것은 아니다.) 하지만 학원에는 분명히 순기능이 존재한다. 개인적으로 학원의 가장 큰 순기능 중 하나는 <code>함께 공부하는 사람들과의 네트워킹으로 인한 동기부여</code>라고 생각한다.  </p><p><img src="/images/review/likelion-hackerton-review05.jpg" alt="/images/review/likelion-hackerton-review05.jpg"></p><p>혼자 공부를 하면 내가 옳은 방향으로 가고 있는가에 대한 방향성, 성장 속도에 대한 지표 혹은 혼자 얻을 수 있는 정보에 대한 한계에 부딪히기 쉽다. 하지만 긍적적인 네트워킹을 통한 동료들은 러닝 메이트와 같이 함께 성장하며 함께 나아갈 수 있으며, 나의 성장 속도, 방향에 대한 측정 가능한 지표가 되어줄 수 있다. 또는 내가 지치거나 번아웃이 왔을 때 나를 이끌어 주고나 붙잡아줄 수 있으며, 반대로 내가 동료에게 힘이 되어 줄수도 있다. </p><p>물론 제일 좋은 것은 멘토의 유무이지만, 멘토를 찾기도 쉽지 않다. 설령 찾았다고 해도 개인적인 시간까지 할애해가며 도와주는 멘토를 찾기가 더더욱 쉽지 않다. (글을 써놓고 보니 2년째 나를 지켜봐주시는 멘토분께 새삼 감사함을 느낀다😝) 만약 좋은 멘토를 구하기 어렵다면 컨퍼런스나 커뮤니티를 이용하여 동료를 구해보는 것도 좋을 것 같다.</p><h3 id="나에게-있어-오늘의-경험은"><a href="#나에게-있어-오늘의-경험은" class="headerlink" title="나에게 있어 오늘의 경험은"></a>나에게 있어 오늘의 경험은</h3><p>무엇보다 해커톤에서 대학생 분들에게 받은 질문을 듣고 느꼈던 그들의 고민의 키워드는 <code>성장</code>과 <code>미래에 대한 불안감</code>이였다. 그에 대한 답변을 하면서도 나 자신에게도 되묻고 싶었다. 불과 3년 전만 해도 나도 그들과 비슷한 고민을 했었던 것 같다. 아니, 오히려 오늘 만난 대학생분들보다 더 진지하게 고민해보지 못했던 것 같다. </p><p>내 이력서에 에이전시인 회사는 딱 1군데이지만 비공식적으로 내 이력서에 적기엔 내 스스로를 너무 초라하게 만드는 에이전시가 더 있었다. 그 중 한군데서는 그래도 에이전시 내에서는 저력이 있었던 작지 않았던 에이전시 였으며, 다음 회사는 임금 체불이라는 나에겐 또 다른 시련을 안겨준 회사도 있었다. 이러한 회사를 다 합쳐서 채 3개월이 되지도 않은 시점에 나는 2번째 회사를 나오며 “스스로를 보며 실패했다”라는 생각을 많이 했다. 그 때까지만 해도 내가 누군가의 앞에서 나의 경험에 대해서 혹은 성장에 대해서 이야기할 기회가 올거라고 생각하지 못했다. 물론 이번에 우연치 않은 기회로 해커톤의 연사로 참여했지만, 앞에서 말했듯 스스로가 연사를 참여할 만큼 대단하다고 생각하진 않는다. 하지만 오늘의 경험으로 인해 나는 과거의 열심히 살지 못했던 내 스스로를 돌아보게 되었으며 오히려 해커톤에 참여함으로써 앞으로도 계속 노력해나가야 하는 부족한 개발자라는 것을 깨닫는 계기가 되었다. </p><h2 id="아쉬웠던-점"><a href="#아쉬웠던-점" class="headerlink" title="아쉬웠던 점"></a>아쉬웠던 점</h2><p>해커톤에 참여하기 하루 전, “과연 나는 어떠한 질문을 받을까? 그리고 그 질문을 받고 나면 나는 어떻게 대답해줄까”라는 생각을 하다 잠이 들었다. 물론 다행이도 어느 정도 예상했던 예상 범위 안에서 질문을 받았다 하지만 어떠한 주제로 라이트닝 토크가 진행되는지 컨셉이라도 알았더라면 막상 이러한 질문을 받았을 때, 조금더 도움되는 말을 해줄텐데 라는 생각에 많은 아쉬움이 남았다. 물론 이러한 아쉬움 내 스스로에 대한 아쉬움일 수도 있다. 한때는 나역시도 커리어에 대한 비슷한 고민과 걱정을 했었고, 만약 그때 고민과 걱정에 대해 조금더 깊게 생각해보았더라면 아마 오늘의 답변이 다른 이들에게 조금더 도움이 되지 않았을까란 생각을 해봤다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019년 6월 1일, 경희대학교에서 &lt;code&gt;멋쟁이 사자처럼&lt;/code&gt;의 일부 운영진들이 진행하는 대학생 해커톤이 열렸다. 해커톤에는 대략적으로 50여명 정도의 대학생이 참여를 했으며, 나는 그 해커톤의 연사로 참여를 하게 되었다. 사실 연
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="멋쟁이 사자처럼" scheme="http://blog.martinwork.co.kr/tags/%EB%A9%8B%EC%9F%81%EC%9D%B4-%EC%82%AC%EC%9E%90%EC%B2%98%EB%9F%BC/"/>
    
      <category term="해커톤" scheme="http://blog.martinwork.co.kr/tags/%ED%95%B4%EC%BB%A4%ED%86%A4/"/>
    
  </entry>
  
  <entry>
    <title>Typescript의 기본 유틸 타입</title>
    <link href="http://blog.martinwork.co.kr/typescript/2019/05/28/typescript-util-types.html"/>
    <id>http://blog.martinwork.co.kr/typescript/2019/05/28/typescript-util-types.html</id>
    <published>2019-05-27T15:50:51.000Z</published>
    <updated>2020-03-05T03:13:23.294Z</updated>
    
    <content type="html"><![CDATA[<p>타입스크립트를 이용해서 개발을 한지 어느덧 1년이 조금 넘은 것 같다. 현재의 직장으로 옮기기 전에는 VueJS와 타입스크립트 조합으로 사용을 하였고, 지금은 ReactJS와 타입스크립틀 조합으로 사용하고 있다. </p><p><img src="/images/typescript/vue-vs-react-business-perspective-v2.jpg" alt="/images/typescript/vue-vs-react-business-perspective-v2.jpg"></p><p>타입스크립트로 프로젝틀를 진행을 하며 처음에는 인터페이스와 모듈에 대한 인풋/아웃풋의 타입에만 신경을 쓰고, 비효율적인 인터페이스 선언에 대한 고려는 크게 하지 않았다. 사실은 알면서도 모른 척 했을 수도 있다. 하지만  비지니스가 점점 더 복잡해짐에 따라 인터페이스를 효율적으로 관리해야하는 니즈가 생겼다. 간단한 프로젝트에서는 모델에 대한 인터페이스 선언을 해도 그 수가 많지 않았지만, 지금은 선언된 모듈 인터페이스만 해도 그 수가 기하급수적으로 많아지기 시작했다. 그러던 중 타입스크립트 내에서 제공해주는 유틸 타입을 보게 되었고, 추가적인 라이브러리 내에서 지원하는 유틸 타입을 보게 되었다. 물론 라이브러리에서 지원하는 모든 유틸 타입이 다 필요한 것은 아니기에, 살펴보고 필요하다라고 판단되는 것은 일부 정의해서 쓰기로 했다. 그 중 유용하다고 생각하는 유틸 타입이나 타입스크립트에서 제공해주는 유틸 타입에 대해서 살펴보았다.</p><h3 id="타입스크립트에서-기본적으로-제공해주는-유틸-타입"><a href="#타입스크립트에서-기본적으로-제공해주는-유틸-타입" class="headerlink" title="타입스크립트에서 기본적으로 제공해주는 유틸 타입"></a>타입스크립트에서 기본적으로 제공해주는 유틸 타입</h3><h4 id="Partial-유틸-타입"><a href="#Partial-유틸-타입" class="headerlink" title="Partial 유틸 타입"></a>Partial<t> 유틸 타입</t></h4><p>Partial 타입은 제네릭 타입 T에 대해서 모든 프로퍼티들을 Optional하게 변경한다. 정의된 Patial 타입을 살펴보면 아래와 같이 선언되어져 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;    </span><br><span class="line">[P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Patial 타입은 제네릭 타입의 T 타입의 Public Property 들에 대하여 기존의 타입은 유지하되, 각각의 Property 들을 Optional 타입으로 변경해준다. </p><h5 id="keyof-T-와-T-K"><a href="#keyof-T-와-T-K" class="headerlink" title="keyof T 와 T[K]"></a>keyof T 와 T[K]</h5><p>Indexed type query인 keyof T는 제네릭 타입 T의 Public Property 들에 대한 Union 타입이다. 우리에게 익숙한 TODO에 대한 인터페이스를 통해 살펴보면 다음과 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">id: <span class="built_in">string</span>;</span><br><span class="line">text: <span class="built_in">string</span>;</span><br><span class="line">isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Key = keyof Todo; <span class="comment">// "id" | "text" | "isDone"</span></span><br></pre></td></tr></table></figure><p>이러한 keyof 는 문자열(String) 타입의 서브 타입이다. 이러한 keyof 키워드와 함께 자주 쓰이는 연산자가 있다. 위에서 Partial 타입에서 살펴봤던 T[K]이다. Indexed access operator 인 T[K] 연산자 덕분에 Partial 타입이 기존의 타입을 유지한 상태에서 각각의 Property들을 Optional 한 타입으로 변경해줄 수 있었다. Indexed type query와 Index access operator를 응용한다면 아래와 같이 type-safe 한 값들을 가져올 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">todo: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> todo[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">id: <span class="built_in">string</span>;</span><br><span class="line">text: <span class="built_in">string</span>;</span><br><span class="line">isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalTodo1 = Partial&lt;Todo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OptionalTodo1 와 OptionalTodo2 는 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">interface</span> OptionalTodo2 &#123;</span><br><span class="line">id?: <span class="built_in">string</span>;</span><br><span class="line">text?: <span class="built_in">string</span>;</span><br><span class="line">isDone?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 Partial 타입을 이용하여 인터페이스 안에 혼재 되어 있는 타입들에 대하여 Required 타입과 Optional 타입을 분리할 수 있다는 장점이 있다. 사용자 정보에 대한 모델 타입이 있다고 가정해보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInformation &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  uid: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  profile?: <span class="built_in">string</span>;</span><br><span class="line">  phone?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 이러한 형태로 작성해도 문제는 없을 것이다. 하지만 상황에 따라 Required 타입와 Optional 타입을 분리해야할 상황이 있다. 예를 들어 별도의 API 거쳐 Service Layer 를 통해 Optional한 값에 대하여 기본값을 추가해주는 일종의 Generate 함수의 Parameter 등이 있을 것이다. (이에 대한 자세한 설명은 비즈니스 코드를 작성하는 개인의 취향 혹은 팀 내의 컨벤션이므로 깊이있게 설명하진 않는다.) 이러한 경우 아래와 필요성에 따라 아래와 같이 분리할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInformation = RequiredUserInformation &amp; Partial&lt;OptionalUserInformation&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> RequiredUserInformation &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  uid: <span class="built_in">string</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> OptionalUserInformation &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  profile: <span class="built_in">string</span>;</span><br><span class="line">  phone: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Required-타입"><a href="#Required-타입" class="headerlink" title="Required 타입"></a>Required<t> 타입</t></h4><p>Required 타입은 앞서 살핀 Partial 유틸 타입과는 반대의 개념이다. Partial 유틸 타입은 모든 프로퍼티를 Optional로 만들어줬다면 Required 타입은 제네릭 타입 T의 모든 프로퍼티에 대해 Required 속성으로 만들어준다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Patial 타입과 동일하게 기존의 값은 유지된 상태에서 Requied 타입으로 변경된다는 것을 꼭 인지하도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OptionalTodo &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    text?: <span class="built_in">string</span>;</span><br><span class="line">    isDone?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 Todo1과 타입 Todo2 는 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">type</span> Todo1 = Required&lt;OptionalTodo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Todo2 &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    text: <span class="built_in">string</span>;</span><br><span class="line">    isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<t></t></h4><p>Readonly 타입을 이용하면 주어진 제네릭 타입 T의 모든 프로퍼티가 readonly 속성을 갖도록 변경한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>readonly를 이용하는 대표적인 경우가 React 컴포넌트의 Props와 State 값이 이에 해당한다. 우리는 모두 알듯, React 내에서의 모든 Props 와 State 는 Immutable이다. 그렇기 때문에 직접적으로 변경해서는 안된다. 이러한 상황에서 Readonly 타입을 이용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Component&lt;P, S&gt; &#123;</span><br><span class="line">    <span class="comment">// 중간 생략</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props: Readonly&lt;P&gt;</span>);</span><br><span class="line">  setState&lt;K extends keyof S&gt;(<span class="params"></span></span><br><span class="line"><span class="params">      state: ((prevState: Readonly&lt;S&gt;, props: Readonly&lt;P&gt;) =&gt; (Pick&lt;S, K&gt; | S | <span class="literal">null</span>)) | (Pick&lt;S, K&gt; | S | <span class="literal">null</span>),</span></span><br><span class="line"><span class="params">      callback?: () =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">  </span>): void;</span><br><span class="line">  state: Readonly&lt;S&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>혹은 immutable-js과 같은 데이터의 불변성을 보장해주는 라이브러리나 혹은 Javascript의 freeze 함수에 사용할 때 유용하게 사용할 수 있다. 예를 들어 Object를 얕은 동결을 지원하는 freeze 함수를 사용하는 경우 모든 함수의 경우 readonly 속성을 가져야 함으로 이럴 때 유용하게 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeze</span>&lt;<span class="title">T</span>&gt;(<span class="params">obj: T</span>): <span class="title">Readonly</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pick-lt-T-K-gt"><a href="#Pick-lt-T-K-gt" class="headerlink" title="Pick&lt;T, K&gt;"></a>Pick&lt;T, K&gt;</h4><p>Pick 타입은 주어진 첫번째 제네릭 타입 T 내에서 Union 타입 K에 대한 프로퍼티에 대한 타입들을 뽑아낸다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>익숙한 TODO를 통해 Pick  타입을 사용하는 예제를 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoWithIdAndTitle 타입과 PickedTodo 타입은 동일한 타입이다.</span></span><br><span class="line"><span class="keyword">type</span> TodoWithIdAndTitle = Pick&lt;Todo, <span class="string">'id'</span> | <span class="string">'title'</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PickedTodo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 Pick 타입을 이용한다면 필요한 타입만 추출하여 원하는 새로운 타입을 만들 수 있다.</p><h4 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h4><p>Record 타입은 총 두개의 제네릭 타입을 받을 수 있다. 첫번째 제네릭 타입 K은 프로퍼티 타입으로, 두번째 제네릭 타입 T은 값의 타입으로 사용된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Record 타입의 구조체를 살펴보면 일반적으로 사용하는 Object와 닮은 꼴을 하고 있다는 것을 알 수 있다. 아래와 같이 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IFooBar = &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IHelloWorld = <span class="string">'hello'</span> | <span class="string">'world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: Record&lt;IHelloWorld, IFooBar&gt; = &#123;</span><br><span class="line">  hello: &#123;</span><br><span class="line">    foo: <span class="string">'foo'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  world: &#123;</span><br><span class="line">    foo: <span class="string">'foo'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><p>Exclude 타입은 2개의 제네릭 타입을 받을 수 있으며, 조건부 타입(Conditional type)을 이용하여 타입을 정의 한다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br></pre></td></tr></table></figure><p>두번째 제네릭 타입에 대하여 첫번째 제네릭 타입이 할당 가능한 타입(Assignable)인지를 여부를 판단하여 할당 가능한 타입을 제외한 나머지 타입들을 이용하여 타입을 정의한다. 이해하기 쉽도록 아래의 예제를 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Memo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contents = Exclude&lt;Todo | Memo, Memo&gt;;</span><br></pre></td></tr></table></figure><p>위에서 살펴본 할당 가능한(Assignable) 타입을 제외한다면 Cotents 타입은 어떠한 타입을 가지게 될까 ? 두번째 제네릭 타입 U에 해당하는 Memo에 대하여 첫번째 제네릭 타입에 해당하는 Todo와 Memo 중 할당 불가능한 타입은 Todo 타입이 될 것이다.</p><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><p>Extract 유틸 타입은 단어 그대로 추출의 의미를 가지며, Exclude 타입과 반대의 타입이다.  첫번째 제네릭 타입 U에 대하여 제네릭 타입 T 중 할당 가능한 타입을 할당한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br></pre></td></tr></table></figure><p>Exclude 타입에서 살펴보았던 예제를 다시 한번 살펴보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contents = Extract&lt;Todo | Memo, Memo&gt;;</span><br></pre></td></tr></table></figure><p>Exclude 타입과는 다르게 유니온 타입 Todo과 Memo에 대하여 Memo에 할당 타입을 반환하기 때문에 Contents 타입은 Memo 타입이 되는 것을 알 수 있다.</p><h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h4><p>Omit 타입은 두개의 제네릭 타입을 받으며 첫번째 제네릭 타입 T에 대하여 두번째 제네릭 타입 K의 값을 제외한 나머지 값을 반환합니다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><p>정의된 Omit의 타입을 살펴보면 앞서 우리가 익혔던 타입들을 이용하여 정의하고 있다. 예제를 통해 정의된 타입들을 Todo 인터페이스의 예제를 가지고 이해해보도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TodoWithOutId = Omit&lt;Todo, <span class="string">"id"</span>&gt;;</span><br></pre></td></tr></table></figure><p>일단 Exclude 타입을 통해 살펴보면 keyof T 에 해당하는 Todo 타입의 프로퍼티 중 두번째 제네릭 타입 K에 해당하는 id를 제외한 나머지 값들을 뽑아낸다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pick&lt;Todo, <span class="string">"title"</span> | <span class="string">"isDone"</span>&gt;;</span><br></pre></td></tr></table></figure><p>그렇게 Exclude를 통해 뽑아낸 유니온 타입들에 대하여 Pick 타입을 이용하여 Todo 타입 중 그에 해당하는 프로퍼티의 타입을 뽑아낸다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TodoWithOutId = Omit&lt;Todo, <span class="string">"id"</span>&gt;;</span><br><span class="line"><span class="comment">// TodoWithOutId의 타입은 아래의 인터페이스와 일치한다.</span></span><br><span class="line"><span class="keyword">interface</span> TodoWithOutId &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><p>NonNullable 유틸타입은 주어진 제네릭 타입 안에서 null이나 undefined을 제거한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? never : T;</span><br></pre></td></tr></table></figure><p>이미 앞에서 살펴봤던 타입들을 모두 이해했다면 이와 같은 Conditional type(조건부 타입)은 이해하기 어렵지 않을 것이다. 간단한 예제를 통해 살펴보면 후, 넘어가도록 하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Todo = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NullableTodos = <span class="literal">null</span> | <span class="literal">undefined</span> | Todo[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Todos = NonNullable&lt;NullableTodos&gt;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type Todos = Todo[];</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p>ReturnType 타입은 주어진 제네릭 타입 T의 return type을 할당한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>여기에서 익숙하지 않은 infer 키워드가 등장하는데, 간단히 이야기하자면 해당 <code>타입을 추론</code> 하고자 할 때 사용하는 키워드라고 생각하면 된다. 관련해서 조금더 자세히 알아보고자 한다면 <a href="https://dev.to/aexol/typescript-tutorial-infer-keyword-2cn" target="_blank" rel="noopener">https://dev.to/aexol/typescript-tutorial-infer-keyword-2cn</a> 를 참고하도록 하자. 그래서 위에서의 반환 타입을 분석해보자면, <code>T extends (...args: any) =&gt; infer R ? R : any</code> 는 R 타입에 대해서 타입 추론이 가능하다면 R 타입을 그렇지 않다면 any 타입을 반환한다. ReturnType 의 경우 해당 함수에 대한 반환 타입을 타이핑할 때 사용할 수 있다. 아마 Redux 를 사용해본 사람이라면 이러한 ReturnType을 ActionCreator 함수에서 활용할 수 있음을 깨달을 수 있을 것이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPayload &#123;</span><br><span class="line">  foo: <span class="built_in">string</span>;</span><br><span class="line">  bar: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooBarCreator = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    foo: <span class="string">"foo"</span>, bar: <span class="string">"bar"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IFooBarCreator = ReturnType&lt;<span class="keyword">typeof</span> fooBarCreator&gt;;</span><br></pre></td></tr></table></figure><h3 id="기타-유용한-유틸-타입"><a href="#기타-유용한-유틸-타입" class="headerlink" title="기타 유용한 유틸 타입"></a>기타 유용한 유틸 타입</h3><p>타입스크립트에서 제공해주는 유틸 타입을 제외하더라도 개인적으로 커스텀해서 사용하기 좋아하는 타입들 역시 있다. 이러한 유용한 유틸 타입 중 일부에 대해서는 아래의 링크에 <code>conditional-type-checks</code>를 참고하였으며, 기타는 회사에서 업무를 진행하며 필요하다는 생각이 들어 추가한 것들도 있다.</p><h4 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h4><p>Javascript로 개발을 할때는 Object를 초기화할때 null을 이용하여 초기화 시켜줬다. 이러한 객체는 선언시 null 타입을 가질 수도 혹은 이후 할당된 객체의 값을 가질 수 있어야 한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> INullable&lt;T&gt; = T | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">interface</span> ITodos &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  text: <span class="built_in">string</span>;</span><br><span class="line">  isDone: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTodo</span> (<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">INullable</span>&lt;<span class="title">ITodos</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// request api</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fetchTodo().then(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 서버의 응답값이 null일 수 있기 때문에 방어코드를 추가해준다.</span></span><br><span class="line">  <span class="keyword">if</span>(!todo) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>개인적으로는 보통 서버와의 통신을 제어하는 래퍼 함수(Wrapper function)의 리턴 타입의 인터페이스에 사용한다. 이렇게 작성된 인터페이스로 인해 일차적으로는 서버의 응답값과의 정합률이 높아질 뿐만 아니라 자칫 놓치고 넘어갈 수 있는 방어 코드에 대해서도 컴파일 단계에서 미리 알아차릴 수 있다는 장점이 있다.</p><h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>프론트 개발을 하다보면 아무리 정해져 있는 API 규약에 맞춰 백엔드 서버와 커뮤니케이션 한다고 하더라도 실제 정해져있는 규약으로 넘어오지 않는 경우가 많다. 그러한 경우 값이 없을 때의 타입이 null인지, undefined인지 알 수가 없다. 물론 아예 해당하는 키의 데이터가 안내려올때도 있지만 그러한 경우는 optional 옵션을 이용하여 인터페이스를 선언하면 되지만, 타입이 명확하지 않은 경우는 런타임 환경에서 타입 에러에 직면하는 경우가 많다. 그런 경우를 대비하며 Nullable 타입과 분리하여 Maybe 유틸 타입을 선언하여 사용한다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IMaybe&lt;T&gt; = T | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>이 외에도 AJAX의 응답값에 대한 래퍼 함수의 리턴 타입 등을 커스텀해서 사용하고 있지만, 이외에는 생각나는 유틸 타입은 없는 것 같다. 이 외에도 이러한 유용한 유틸 타입을 제공해주는 라이브러리가 있다. 혹시나 또다른 유틸 타입이 필요하다면 아래의 참고 링크를 참고하는 것도 좋을 것 같다. </p><p>혹시나 이 글을 보시고, 커스텀으로 사용하고 있는 또다른 좋은 유틸 타입이 있다면 여러분의 타입도 한번 공유 부탁드립니다.😄</p><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/microsoft/TypeScript-Handbook/blob/master/pages/Utility%20Types.md" target="_blank" rel="noopener">Typescript handbook</a></li><li><a href="https://github.com/dsherret/conditional-type-checks" target="_blank" rel="noopener">conditional-type-checks</a></li><li><a href="https://github.com/piotrwitek/utility-types" target="_blank" rel="noopener">utility-types</a></li></ul>]]></content>
    
    <summary type="html">
    
      Typescript 내의 유틸 타입 톹아보기
    
    </summary>
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/categories/typescript/"/>
    
    
      <category term="Typescript" scheme="http://blog.martinwork.co.kr/tags/typescript/"/>
    
      <category term="Util type" scheme="http://blog.martinwork.co.kr/tags/util-type/"/>
    
      <category term="유틸 타입" scheme="http://blog.martinwork.co.kr/tags/%EC%9C%A0%ED%8B%B8-%ED%83%80%EC%9E%85/"/>
    
  </entry>
  
  <entry>
    <title>왜 다시 SSR인가 01</title>
    <link href="http://blog.martinwork.co.kr/devops/2019/05/24/server-side-rendering01.html"/>
    <id>http://blog.martinwork.co.kr/devops/2019/05/24/server-side-rendering01.html</id>
    <published>2019-05-23T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전"><a href="#들어가기전" class="headerlink" title="들어가기전"></a>들어가기전</h2><p>프론트엔드 개발자가 아니더라도 웹 개발에 몸을 담고 있다면 한번쯤은 <code>SPA 애플리케이션</code>에 대해서 한번쯤 들어봤을 것이다. 요즘은 일부 회사들의 공고에도 보란듯이 <code>SPA 애플리케이션 경험자</code>라는 키워드가 나와있을 정도로 프론트엔드 개발자에게는 알아야하는 기본적인 소양이 되었다. 이참에 대체 SPA 애플리케이션이 무엇인지, 왜 SPA 애플리케이션이 나오게 되었는지 하나씩 알아볼 것이다. 그 전에 먼저 우리가 살펴보고자 하는 클라이언트의 구조에 대해서 한번 살펴보도록 하자.</p><h3 id="2-티어-아키텍쳐-구조-2-Tier-Architecture-Structure"><a href="#2-티어-아키텍쳐-구조-2-Tier-Architecture-Structure" class="headerlink" title="2 티어 아키텍쳐 구조(2 Tier Architecture Structure)"></a>2 티어 아키텍쳐 구조(2 Tier Architecture Structure)</h3><p>과거 많은 애플리케이션은 2 Tier 형태의 아키텍쳐를 가지고 있다. 2 티어 아키텍쳐란 클라이언트와 DB가 물리적으로 분리되어있는 구조 안에서, 클라이언트에는 UI와 비지니스 로직(Business logic)이 함께 있는 구조이다. </p><p><img src="/images/theory/mpa01.png" alt="/images/theory/mpa01.png"></p><p>👍 2 티어 아키텍쳐의 구조를 가져가게 될시 다음과 같은 장점이 가진다.</p><blockquote><ol><li>쉽게 빠르게 개발할 수 있으며 시스템 구축이 어렵지 않다.</li><li>애플리케이션의 구조가 단순하다.</li><li>개발 비용이 비교적 저렴하다.</li></ol></blockquote><p>보통 초기의 스타트업와 같이 적은 인원으로 시스템을 빠르게 구축할 때 이와 같은 구조를 많이 가져간다. </p><p>👎 하지만 이러한 구조에는 장점에 비해 부각되는 단점들이 있다.</p><blockquote><ol><li>클라이언트에서 DB에 직접 붙기 때문에 안정성에도 문제가 있다.</li><li>UI와 비지니스 로직을 클라이언트에서 모두 관리하기 때문에, 클라이언트에 부하가 걸리기 쉽다.</li><li>재사용이 어렵다.</li><li>비지니스가 점점 더 복잡해지거나 비대해지면 관리하기가 어려워진다.</li></ol></blockquote><p>이러한 단점은 스타트업의 성장통이라 하여 급격하게 성장하는 회사들이 결국에는 애플리케이션을 다시 만들게 되는 이유가 되기도 한다. 이러한 단점을 개선하고자 3 Tier 혹은 그 이상의 N Tier 아키텍쳐로 설계를 한다.</p><h3 id="3-티어-아키텍쳐-구조-3-Tier-Architecture-Structure"><a href="#3-티어-아키텍쳐-구조-3-Tier-Architecture-Structure" class="headerlink" title="3 티어 아키텍쳐 구조(3 Tier Architecture Structure)"></a>3 티어 아키텍쳐 구조(3 Tier Architecture Structure)</h3><p>2 티어 아키텍쳐의 구조와 큰 차이점은 클라이언트 안에 존재하는 UI와 비지니스 로직(Business logic)을 분리된다는 점이다.</p><p><img src="/images/theory/mpa02.png" alt="/images/theory/mpa02.png"></p><p>각각의 용어는 다른 단어로도 표현되는데 클라이언트를 프레젠테이션 티어, 비지니스 계층은 애플리케이션 티어라고 불르기도 한다. 이러한 구조를 가지게 된 경우 클라이언트 로직은 Frontend 개발자가, 비지니스 로직은 Backend 개발자가 담당하게 된다. 이렇게 분리하면 장점은 무엇보다 <code>재사용이 쉽다</code>라는 점이 있다. 요즘 많은 엔터프라이즈급 회사에서 지향하고 있는 MSA 구조 역시 이와 같이 프레젠테이션 티어와 비지니스 티어가 분리되어야 비로서 가져갈 수 있는 구조 중 하나이다. </p><p>👍 3 티어 아키텍쳐는 이러한 장점을 가진다.</p><blockquote><ol><li>클라이언트가 직접 DB 붙는 것이 아닌 Business 계층을 통해 붙기 때문에 보안에 용이하다.</li><li>재사용이 쉬우며, 확장에 용이하다.</li><li>비지니스 로직과 UI를 분리할 수 있다.</li></ol></blockquote><p>이러한 구조의 제일 큰 장점으로는 UI와 비지니스 로직이 분리되어 있어 애플리케이션을 배포할 때에도 UI나 비지니스 로직을 각각 배포할 수 있다. (당연히 비지니스 로직이나 DB 관련 코드가 포함되어 있으면 안된다.)</p><p>🎉 굉장히 멀리 돌아왔지만 드디어 우리가 살펴보고자 하는 클라이언트 혹은 프레젠테이션 티어라고 부르는 UI가 등장하였다. </p><h3 id="MPA-애플리케이션"><a href="#MPA-애플리케이션" class="headerlink" title="MPA 애플리케이션"></a>MPA 애플리케이션</h3><p>MPA 애플리케이션은 Multiple Page Application의 약자로서, <code>전통적인 웹 애플리케이션 방식</code>이다. MPA 애플리케이션의 가장 큰 단점으로는 프론트엔드와 백엔드가 강하게 결합되어 있다는 점이 있다. 이러한 점은 우리가 앞에서 살펴본 2 Tier 아키텍쳐의 단점과 같다는 것을 쉽게 유추할 수 있다. 이러한 구조는 우리가 편하게 <code>웹서버</code>라고 불리우는 형태의 애플리케이션이다. 아마 모두들 한번쯤은 jsp 혹은 php 등과 같은 템플릿 언어의 코드로 작성된 UI 로직을 수정해본 경험이 있을 것이다. 이렇게 작성된 애플리케이션에서 다른 페이지를 이동할 때 이동하려는 웹페이지에 대한 서버로 요청을 날리는 후 페이지를 새롭게 렌더링한다는 것을 알 수 있다. 조금더 자세하게 설명한다면 사용자가 “A”라는 페이지를 요청한다면 다음과 같은 과정을 거칠 것이다.</p><blockquote><ol><li>“A”에 대한 페이지 정보를 서버에 요청한다.</li><li>“A”에 대한 요청을 받은 서버는 해당하는 UI와 필요한 데이터(예를 들어 게시판이라고 한다면 게시글 데이터를 의미한다)를 이용하여 HTML 데이터로 파싱한다.</li><li>브라우저는 전달받은 HTML 데이터를 지정된 인코딩으로 변환하여 사용자에게 보여준다.</li></ol></blockquote><p>브라우저는 이러한 과정을 거치면서 페이지를 갱신하게 되며 사용자는 페이지가 이동될때마다 새로고침되는 것을 볼 수 있다. 이러한 새로고침은 로딩 시간을 늘어질 뿐만 아니라 사용자의 경험 역시 좋지 않을 수 밖에 없다. 이러한 단점을 AJAX 라는 기술이 어느정도 해결해줄 수 있었다. 과거에는 폼을 작성한 후 웹 서버에 제출(Submit)하게 되면 이러한 요청을 처리하며 브라우저가 새로고침되는 것을 볼 수 있었지만 요즘에는 거진 대부분 페이지 이동없이 화면을 전환하고 있다. 이러한 요청을 통해 웹 서버의 처리량 역시 과거보다는 많이 줄어들었다. 하지만 이러한 근본적으로 페이지 이동시 새로고침된다는 문제를 해결하기엔 역부족이었다. </p><h3 id="SPA-애플리케이션"><a href="#SPA-애플리케이션" class="headerlink" title="SPA 애플리케이션"></a>SPA 애플리케이션</h3><p>MPA 애플리케이션의 사용자 경험에 대한 단점을 개선해줄 수 있는 것이 바로 SPA 애플리케이션이다. SPA 애플리케이션은 Single Page Application의 약자로서 다른 말로는 CSR(Client Side Rendering)이라고 표현하기도 한다. 이러한 SPA 애플리케이션은 하나의 HTML 파일만 있으면 나머지는 Javascript를 이용해서 동적으로 화면을 구성할 수 있다. 서버는 어떠한 요청을 받던 무조건 동일한 HTML 파일은 내려준다. 그 후 사용자는 하나의 HTML 파일에서 Javascript를 이용해 동적으로 구성되는 UI 화면 속에서 마치 페이지가 <code>이동되는 것처럼</code> 보여지는 느낌을 받는다. 이렇게 URL을 조작해 마지 이동되는 것처럼 보여지게 하는 것은 해쉬 방식 혹은 HTML5의 히스토리 API를 통해 가능하다. </p><p>SPA의 가장 큰 장점으로는 <code>변경된 부분만 효율적으로 변경</code>한다는 점이다. </p><p><img src="/images/theory/spa01.png" alt="/images/theory/spa01.png"></p><p>이러한 애플리케이션 내에서 사용자에게 제공하는 모든 페이지는 Javascript 안에 포함되어져 있으며, Javascript를 이용하여 동적으로 <code>화면이 갱신되어지는 것처럼</code> 보여지게 하는 것이다. 이러한 점은 좋은 사용자 경험을 제공해줄 수 있다는 장점을 가진다. 하지만 그렇다고 장점만 있는 것은 아니다. 앞에서 설명했든 애플리케이션의 모든 페이지들이 Javascript 안에 포함되어져 있기 때문에 애플리케이션에서 사용하는 Javascript 파일은 점점 더 비대해지며 이러한 이유로 인해 <code>애플리케이션의 초기 랜더링 속도가 느리다</code>. 뿐만 아니라, Javascript를 이용하여 화면을 동적으로 그리기 때문에 <code>SEO에 굉장히 취약하다</code>는 단점을 가지고 있다. 물론 애플리케이션의 초기 랜더링 속도를 개선하기 위해 써드파티 라이브러리들을 Vendor 단위로 나눈 후 CommonChunking으로 별도로 청킹 처리를 해주거나 Dynamic Loading을 이용하여 Javascript 파일의 리소스를 최대한 줄이는 등의 전략을 세우고 있다. 하지만 이렇게 아무리 노력한다고 해도 SSR보다는 초기 랜더링 속도가 늦을 뿐만 아니라 근본적인 문제인 SEO를 해결할 수 없다는 단점을 가지고 있다. 이 다음에는 SPA의 이러한 단점을 해결하기 위한 방법에 대해서 살펴보도록 하겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기전&quot;&gt;&lt;a href=&quot;#들어가기전&quot; class=&quot;headerlink&quot; title=&quot;들어가기전&quot;&gt;&lt;/a&gt;들어가기전&lt;/h2&gt;&lt;p&gt;프론트엔드 개발자가 아니더라도 웹 개발에 몸을 담고 있다면 한번쯤은 &lt;code&gt;SPA 애플리케이션&lt;/co
      
    
    </summary>
    
      <category term="Devops" scheme="http://blog.martinwork.co.kr/categories/devops/"/>
    
    
      <category term="SSR" scheme="http://blog.martinwork.co.kr/tags/ssr/"/>
    
      <category term="CSR" scheme="http://blog.martinwork.co.kr/tags/csr/"/>
    
  </entry>
  
  <entry>
    <title>Naver Tech Concert 리뷰</title>
    <link href="http://blog.martinwork.co.kr/review/2019/04/11/2019-04-11-naver-tech-review.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/04/11/2019-04-11-naver-tech-review.html</id>
    <published>2019-04-10T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>2019년 4월 11일, 네이버의 사옥 그린팩토리에서 네이버 테크 콘서트가 열렸다. 주제는 프론트 엔드 개발 전반적인 기술과 경험, 그리고 개발 문화에 대한 공유였다. 일단은 컨퍼런스의 대상은 대학생 대상으로 주최된 행사였으나, 막상 가서 보니 실무자들 참여율이 높은 편이었다. 아무래도 대학생을 대상으로 하는 컨퍼런스이기 때문에 실무자들에게는 이미 익숙해져 있는 이야기도 있었지만, 개인적으로 컨퍼런스의 전체적인 내용에 아주 만족스러웠다. 그 중 인상 깊었던 내용들에 대한 리뷰를 남기고자 한다. </p><h3 id="플랫폼-UI-개발-전략"><a href="#플랫폼-UI-개발-전략" class="headerlink" title="플랫폼 UI 개발 전략"></a>플랫폼 UI 개발 전략</h3><p>첫번째는 이주용님의 <code>플랫폼 UI 개발 전략의 모든 것</code> 이라는 주제의 세션이었다. </p><p><img src="/images/review/NAVER-TECH-CONCERT01.png" alt="/images/review/NAVER-TECH-CONCERT01.png"></p><p>내용은 스마트에디터의 UI를 개발하면서 생겼던 이슈 및 해결 과정에 대한 것들을 풀어나가는 시간이었다. 모든 개발의 시작은 좋은 설계에서 시작한다고 생각한다. 개인적으로 생각했을 때, 중요한 것은 새로운 비지니스가 추가될 때, 그러한 요구 사항을 수용할 수 있느냐와 두번째는 유지 운영의 용이성이라고 생각한다. </p><p>스마트 에디터의 설계를 하면서 가장 중요하게 생각했던 것의 첫번째는 UI 컴포넌트의 공통화는 디자인 중심이 아닌 기능 중심으로 설계를 했다는 점이다. 디자인은 템플릿 요소의 관점에서 접근하며, 실제 UI 컴포넌트를 공통화를 고민할 때는 기능 중심의 분석을 거쳐 설계를 했다고 한다. </p><p>두번째는 조건 및 상태에 따라 다른 스타일 적용했다는 점이다. 우리가 생각하는 CSS는 Javascript와 같이 동적인 언어가 아닌 <code>정적인 언어</code>이다. 하지만 비지니스의 니즈에 따라 조건이나 상태에 따라 UI의 화면이 수도없이 바뀐다. 마치 아래와 같은 스타일을 작성하는 이유이다.</p><pre><code class="scss"><span class="selector-class">.button</span> {  <span class="comment">// ...</span>  <span class="selector-class">.has-text</span> {    <span class="comment">// ...</span>  }  <span class="selector-class">.has-icon</span> {    <span class="comment">// ...</span>  }}</code></pre><p>이러한 상황을 고려하여 CSS는 정적인 언어이지만 설계는 동적으로 이뤄져야 한다는 것이다. </p><p><img src="/images/review/NAVER-TECH-CONCERT02.png" alt="/images/review/NAVER-TECH-CONCERT02.png"></p><p>이와 동시에 중요한 것은 모듈화와 공통 요서 분리 작업이다. 위와 같이 상태나 조건에 따라 컴포넌트의 스타일이 동적으로 변경될 수 있으려면 제일 먼저 비지니스의 니즈를 분석한 후, 공통 분모를 도출 해야한다. 무엇보다 이러한 공통점을 찾을 때는 단순하게 디자인만 고려하는 것이 아니라 꼭 기능도 함께 고려를 해야 한다. 디자인이 비슷하다고 해도 기능이 다른 경우가 존재하기 때문이다. </p><p><img src="/images/review/NAVER-TECH-CONCERT03.png" alt="/images/review/NAVER-TECH-CONCERT03.png"></p><p>이러한 고민들을 해결해나가는 과정에서 스마트 에디터의 팀은 개발 방법론과 CSS Preprocessor도입했다고 한다. 개발 방법론은 BEM, SMASS, OOCSS 등과 너무도 유명한 3가지 방법이 있다. 이 중에서는 대표적으로 BEM 방식이 가장 인기 있는 방법이지만, OOCSS를 선택했다고 한다. 혹시나 스마트 에디터 팀에서 OOCSS를 선택했다고 꼭 OOCSS 방법만 선택할 필요는 없다. 위의 3가지 방법은 각각의 장단점이 있기 때문에 꼭 하나의 방법을 고수하는 것보다는 상황에 따라 선택하면 될 것 같다. </p><p>첫번째 세션에서 제일 인상 깊었던 말은 <code>플랫폼은 만능이 아니다</code>라는 말이었다. 내가 만든 코드가 모든 요구사항을 다 소화할 수 없으며, 플랫폼은 지속적으로 발전하기 때문에 코드 역시 변화해야 한다. 소프트웨어 장인 이라는 책에서는 <code>개발자는 건축가와 같이 설계하고 끝나버리는 직업이 아니라, 정원사와 같이 꾸준히 관리를 해줘야하는 직업이다</code> 라고 한다. 그렇기 때문에 개발자로서 살아가는 우리들이 꾸준히 리펙토링과 클린코드에 관심을 갖는 게 아닐까?</p><p> <img src="/images/review/NAVER-TECH-CONCERT04.png" alt="/images/review/NAVER-TECH-CONCERT04.png"></p><h3 id="회사에서-성장하기"><a href="#회사에서-성장하기" class="headerlink" title="회사에서 성장하기"></a>회사에서 성장하기</h3><p>두번째로 인상 깊었던 내용은 한재엽님의 <code>주니어 개발자의 성장에 대한 뻔하지만 뻔하지않은 이야기</code> 였다. </p><p><img src="/images/review/NAVER-TECH-CONCERT05.png" alt="/images/review/NAVER-TECH-CONCERT05.png"></p><p>개발자라면 한번쯤 스스로의 위치와 앞으로 내가 얼마나 나아갈 수 있을지에 대한 고민을 한번쯤을 해보았을 것이다. 이러한 고민을 재엽님의 경험기에 빗대자면, 많은 시간을 투자하여 다음의 것들을 공부하면 된다.</p><ol><li>출근 전후 그리고 주말 내내 시간을 투자해서 공부를 한다.</li><li>사이드 프로젝트를 진행한다.</li><li>개발 관련 뉴스레터를 통해 꾸준하게 개발에 관심을 놓지 않는다.</li><li>개발 관련 서적을 독파하여 기본기에 충실한 공부를 한다.</li><li>블로그를 운영한다.</li><li>알고리즘을 하루에 한 문제씩 풀어 논리적인 사고 방식에 대한 감을 잃지 않는다. </li></ol><p>만약 이런 것들을 하루에 한다고 하면 우리는 누구나 노력형 천재 개발자가 될 수 있다. 하지만 안타깝게도 우리의 인생은 개발자로서의 성장만 꿈꾸기에는 너무나 많은 이벤트들이 있다. 가족 혹은 애인과 시간도 보내야 하고, 가끔 번아웃된 나 자신을 위해 스스로르 보듬어줘야하기도 하며, 회사를 다닌다면 야근과 같이 불가피한 상황에 놓일 수도 있을 것이다. 그렇다면 빠른 성장을 포기해야 할까?</p><p>재엽님의 주제가 제일 마음에 와닿는 것은 이러한 현실적, 물리적 제약을 해결해나간 방법에 있다. 바로 <code>회사에서 성장하기</code>이다. 언젠가 누군가에게 했던 말 중 제일 와닿는 말이 하나가 있다. <code>개발자의 실력이 궁금하다면 그 사람의 비지니스의 코드를 보면 알 수 있다.</code> 회사는 나와 함께 동반 성장을 해나가야할 파트너이다. 개인은 정체되어 있지만 회사만 성장을 하거나 혹은 개인은 성장을 하지만 회사가 정체되어 있는 불균형은 일하고 있는 환경이 좋지 않은 상황일 가능성이 크다. 그러한 의미에서 우리는 회사라는 환경을 잘 이용하여 동반 성장을 꿈꿔야 한다. </p><p>물론 사이드 프로젝트를 통해 회사에서 채우지 못한 개발적 욕구를 채울 수도 있다. 하지만 사이드 프로젝트를 진행하다보면 모든 욕구를 다 채울 수 없다는 것을 느낄 수 있다. </p><p><img src="/images/review/NAVER-TECH-CONCERT06.png" alt="/images/review/NAVER-TECH-CONCERT06.png"></p><p>재엽님이 말씀하신 간헐적 버그에 대한 무시, 버그 제보에 대한 무시, 디바이스 이슈를 제외하고도 가장 큰 것은 유저풀이다. 하루에도 수십개의 사이드 프로젝트가 탄생하며 사라진다. 정말 성공한 사이드 프로젝트를 제외하고는 유저풀이 1000명 넘는 플랫폼이 있을까? 물론 적은 수더라도 내가 사이드 프로젝트로 만든 플랫폼을 이용해준다는 것은 정말 고마운 일이지만 개발적 욕구를 모두 채우기엔 유저풀이 적은 것은 사실이다. 많은 유저풀이 있다는 것은 내가 만든 플랫폼에 대한 자부심을 갖기에도 충분하지만, 더 많은 사용자의 데이터를 통해 사용자들의 플랫폼에 대한 니즈가 점점 더 커져 플랫폼을 발전시키는 계기가 되기도 한다. 그러한 점에서 개인적으로는 유저풀 역시 꾸준한 플랫폼의 발전에 없어서는 안되는 요소라고 생각한다. 사이드 프로젝트를 통한 플랫폼에서는 이러한 것을 채울 수 없지만, 회사에서 만드는 플랫폼의 경우에는 상황이 다르다. </p><p>일단은 회사의 플랫폼의 경우, 작은 스타트업의 경우 회사의 사활이 걸려 있을 수도 있고, 큰 회사더라도 플랫폼 사업 하나에 걸려있는 비용이 천문학적인 비용인 경우가 많다. 그런 만큼 회사에서는 더 많은 관심을 가질 수 밖에 없으며, 간헐적 버그, 디바이스 이슈 등의 사소한 것 하나하나도 전문적인 QA 검증 과정을 거쳐 완벽하게 만들고자 노력한다. 이러한 환경은 개발자가 성장을 하기에 좋은 환경이라고 생각한다. 우리에게 주어진 환경 안에서 이러한 환경을 잘 이용하여 설장하는 계기가 되었으면 한다.</p><h3 id="똑똑한-질문하기"><a href="#똑똑한-질문하기" class="headerlink" title="똑똑한 질문하기"></a>똑똑한 질문하기</h3><p>일을 하다보면 스스로 혹은 동료에게 수없이 많은 질문을 하게 된다. 하다못해, 스택오버플로우만 가도 수없이 많은 개발자들의 질문과 답변이 존재한다. 커뮤니티의 수많은 질문과 답변을 통해 우리는 스스로 성장하기도 하지만 때때로 성의없는 질문들도 있다. 질문의 내용만 살펴봐도 질문을 하기에 충분한 고민을 하지 않았다는 것을 유추할 수 있다. 스스로 해결하려 하는 것이 아니라 질문을 남의 시간을 통해 해결하려고 하는 아주 괘씸한 질문들이다. </p><p>반대로 회사에서 동료에게 이러한 질문을 던지게 된다면, 나의 시간 뿐만 아니라 동료의 시간까지도 빼앗는 상황이 되기도 한다. 그리고 이렇게 몇번 성의 없는  질문을 하다보면 동료에게서 미움을 살수도 있다. 그렇다면 성의 없는 질문은 무엇일까?</p><p>일단 먼저 질문을 하기 전에 충분하게 검색을 해보자. 우리에게는 구글이라는 훌륭한 플랫폼과 스택오버플로우라는 훌륭한 선배 개발자들이 많다. 뿐만 아니라 체계가 잡혀있는 회사 내에는 트러블 슈팅을 다룬 문서가 존재하기도 하다. 대부분의 질문들은 다 그안에서 찾을 수 있다. 하지만 가끔 어떠한 키워드로 찾아야 할지 조차 감을 못 잡을 때가 있다. 그러한 경우에는 동료에게 어떠한 질문을 해야 하는지, 사전 준비를 거쳐야 한다. </p><p>일단 첫번째로 발생 상황을 정리를 한다. 예를 들어 ‘하위 IE 브라우저에서 특정 컴포넌트에서 문제가 발생한다.’ 와 같을 것이다. 물론 조금 더 상세하면 좋다. ‘하위 IE 브라우저 중 IE8에서만 유저의 데이터를 노출시켜주는 UserInformation 컴포넌트에서 x라는 문구와 함께 랜더되지 않는다’ 와 같을 것이다. 다음으로 그러한 문제를 해결하기 위해 어떠한 시도를 했는지도 함께 전달을 해주면 좋다. 상대방 역시 내가 했던 삽질을 그대로 반복해서 시간을 낭비할 수 있기 때문이다. 물론 동료 역시 나의 질문에 답변을 못할 수도 있다. 그런 경우는 차라리 덕 디버깅과 같이 내가 생각하고 있는 바를 논리적으로 토론해보는 것도 좋다. 이러한 방식 역시 상대방과 이야기를 하다보면 스스로 논리에 구멍이 있는 것을 찾기도 혹은 동료가 찾아주기도 한다. 고로 현명한 질문을 통해 서로 발전하는 계기가 되어야 할 것이다.</p><h3 id="성능-최적화"><a href="#성능-최적화" class="headerlink" title="성능 최적화"></a>성능 최적화</h3><p>최근에 회사에서 오픈한 마이티몬의 프로젝트가 안정화 단계에 들어선 후, 플랫폼의 성능에 대한 고민을 하고 있었다. TTI(Time to interaction) 수치 라던지 초기 화면이 그려지는 로딩의 속도 혹은 리소스 절감 등이 포함이 될 것이다. 그러던 중 손찬욱님의 강연이 그러한 고민을 해결할 수 있는 하나의 빛과 같았다.</p><p><img src="/images/review/NAVER-TECH-CONCERT07.png" alt="/images/review/NAVER-TECH-CONCERT07.png"></p><p>일단 클라이언트에서 성능을 개선한다고 하면 우리가 흔히 생각하는 것들이 있다. 일단 제일 간단한 것은 css는 head 안에, js는 body태그가 끝나는 바로 상단에 넣어 준다던지, 혹은 레이지 로딩 적용, 요청수 줄이기 등이 있을 것이다. 하지만 제일 중요한 것은 현재의 상태를 분석하는 것이다. 현재의 상태를 알아야 분석을 통해 어떠한 부분을 개선할 수 있는지, 어떻게 개선하면 좋을지 등에 대한 해답을 찾을 수 있기 때문이다. 그러한 성능 분석은 아래와 같이 Chrome devtools의 Network 안에 있는 Waterfall 그래프를 통해 확인할 수 있다.</p><p><img src="/images/review/NAVER-TECH-CONCERT08.png" alt="/images/review/NAVER-TECH-CONCERT08.png"></p><p>이렇게 나온 그래프를 높이는 낮게, 오른쪽에 가깝게, 그래프 하나당 길이는 짧게 줄이는 것이 성능을 최적화할 수 있는 방법이다. 조금 더 풀어서 설명을 하면, 일단 그래프의 높이가 낮으려면 요청하는 리소스의 갯수가 적어야 한다. 그 말인즉, 모든 리소스를 청킹(Chunking)한다고 성능이 좋아진다는 것은 아니라는 말이다. 두번째로 오른쪽에 가깝다는 것은 리소스 간의 다운로드 수를 줄인다는 것이다. 이러한 두번째의 경우에는 브라우저의 랜더링에 대한 배경이 있어야 한다. 이 부분에 대해서는 추후 다른 포스팅에서 깊이 다루도록 하겠다. 마지막으로 세번째는 사실 클라이언트의 이슈보다는 서버쪽의 이슈에 가까운 경우가 많다. 그래프가 길다는 것은 서버에서 비지니스 로직을 처리하는데 시간이 오래 걸리기 때문이다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019년 4월 11일, 네이버의 사옥 그린팩토리에서 네이버 테크 콘서트가 열렸다. 주제는 프론트 엔드 개발 전반적인 기술과 경험, 그리고 개발 문화에 대한 공유였다. 일단은 컨퍼런스의 대상은 대학생 대상으로 주최된 행사였으나, 막상 가서 보니 
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="Naver Tech Concert" scheme="http://blog.martinwork.co.kr/tags/naver-tech-concert/"/>
    
      <category term="네이버콘서트" scheme="http://blog.martinwork.co.kr/tags/%EB%84%A4%EC%9D%B4%EB%B2%84%EC%BD%98%EC%84%9C%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>소프트 스킬에 대한 리뷰</title>
    <link href="http://blog.martinwork.co.kr/review/2019/03/17/soft-skill-review.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/03/17/soft-skill-review.html</id>
    <published>2019-03-16T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전"><a href="#들어가기전" class="headerlink" title="들어가기전"></a>들어가기전</h2><blockquote><p>책에 대한 리뷰를 시작하기 전에 미리 이야기를 하자면 이 책에 대한 리뷰 작성은 누구한테 부탁받은 것도 아니며 개인의 돈으로 책을 구매하여 읽은 후 작성하였습니다. 그러므로 맹목적인 책에 대한 긍정적인 리뷰가 아닌 개인적인 의견임을 미리 밝힙니다. </p></blockquote><p>들어가기전에 바쁘신 분들을 위해 책에 대한 한줄평을 남기자면 <code>책의 모든 내용이 나에게 도움이 될순 없겠지만 내가 부족한 부분과 앞으로의 성장을 위해 필요한 것에 대한 가이드가 되기에는 충분했다.</code> 라고 할 수 있다. 필자의 경우 이 책을 지인에게 추천을 의향도 있으며, 실제로 이 글을 작성하는 날에도 지인에게 이 책에 대해서 추천을 했다. 그럼 어떠한 부분들이 좋았는지 어떠한 부분이 아쉬웠는지에 대해서 상세하게 설명을 시작해보겠다.</p><h3 id="과연-이-책은-어떠한-점의-나의-구미를-땡겼는가"><a href="#과연-이-책은-어떠한-점의-나의-구미를-땡겼는가" class="headerlink" title="과연 이 책은 어떠한 점의 나의 구미를 땡겼는가?"></a>과연 이 책은 어떠한 점의 나의 구미를 땡겼는가?</h3><p>역시 보기 좋은 떡이 먹기도 좋다고 빼놓을 수 없는 것은 책의 표지가 아닐 수 없다. 한달에 평균적으로 15만원 정도의 책을 사는 필자로서는 서점에서 모든 책의 내용을 파악하고 사기보단 일단 표지가 읽고 싶게 생긴 책을 무작정 선정 후 내용을 살펴본 후 구입 여부를 판단한다. 고로 필자에게 책의 표지는 책 구매 의사 여부에 대한 영향도가 크다고 할 수 있다. 그런 의미에서 소프트 스킬이라는 책의 표지는 개인적으로 합격이었다:)</p><p><img src="/images/review/soft-skill-review01.jpeg" alt="/images/review/soft-skill-review01.jpeg"></p><p>엠포싱이 들어간 표지 뿐만 아니라 무채색을 좋아하는 필자에게는 너무나 마음에 드는 색상이었다. 그리고 너무 개발자스럽지 않은 표지가 대중교통을 이용하면서도 읽기에 부담되지 않았다:) 무엇보다 <code>평범한 개발자</code> 라는 책의 부제에서 이것은 나같은 평범한 개발자를 위한 책이다!라는 생각이 들었다. 그러고나서 책의 첫장을 펼지면 다음과 같이 이 책에 대한 저자의 철학을 바로 살필 수 있다.</p><p><img src="/images/review/soft-skill-review02.jpeg" alt="/images/review/soft-skill-review02.jpeg"></p><p>언젠가 지인이 “요즘은 집필되는 책은 내용에 대한 깊이나 몰입도가 예전에 출판된 읽기 좋은 책에 비해 아쉬운 경우가 많다.” 라는 이야기를 한적이 있다. 사실 필자의 경우에도 막상 사오고나서 마음 잡고 책을 읽으려고 앉았다가 실망한 적이 한두번이 아니다. 그런 의미에서 이 책에 대한 필자의 철학은 또다른 감동을 주기에 충분했다:)  </p><p>이러한 감동을 가지고 책의 내용을 한글자 한글자 마음에 새기며 살펴보았다. </p><h3 id="책의-내용이-나에게는-어떠한-의미였지"><a href="#책의-내용이-나에게는-어떠한-의미였지" class="headerlink" title="책의 내용이 나에게는 어떠한 의미였지?"></a>책의 내용이 나에게는 어떠한 의미였지?</h3><p>첫번째로 와닿는 말은 <code>소프트 스킬은 생각보다 중요하다</code> 였다. </p><p><img src="/images/review/soft-skill-review02_1.jpeg" alt="/images/review/soft-skill-review02_1.jpeg"></p><p>어느 한 포스팅에서 기술 업계에 대한 독성 말투에 대해서 써놓은 글을 보았다. (궁금하신 분은 <a href="https://edykim.com/ko/post/tech-has-a-toxic-tone-problem-lets-fix-it/" target="_blank" rel="noopener">기술 업계의 독성 말투 문제, 고칩시다!</a>에서 확인 할 수 있습니다.) 지금까지 짧게 다닌 회사를 제외하고 최소 1년 이상 다녔던 회사는 3개, 짧은 회사까지 포함한다면 5군데의 회사에 있었지만 어느 단 한곳 인간 관계에서 상처받지 않은 사람이 없었던 곳이 없었다. 위의 독성 말투에 대한 포스팅에서도 강조를 하고 있지만 우리가 하는 모든 일이 다양한 사람들의 참여로 인해 일어나기 때문에 이 책에서도 역시 소프트 스킬이 아주 중요하다고 강조한다. </p><p><img src="/images/review/soft-skill-review02_2.jpeg" alt="/images/review/soft-skill-review02_2.jpeg"></p><p>여기까지만 본다면 아마 ‘뭐야, 그건 어디서나 볼 수 있는 내용이잖아.’ 라는 생각을 할수 있을 것이다. 하지만 이 책에서 <code>문제아 다루기</code> 라는 내용으로 정말 마음 속 깊은 곳을 찌르는 말이 등장한다. 아마 포스팅에서도 이야기 하는 <code>습관적 반대론자</code>도 이 안에 포함되지 않을까 싶다. 새로운 시도하려고 했을 때, 맹목적인 비난을 통해 의욕을 꺾어놓으려고 하거나 혹은 새로운 시도를 하려는 사람을 깎아내리려는 사람은 어느 집단에나 꼭 한명 이상씩은 있지 않을까 싶다. 이 사람들을 이 책에서는 <code>문제아</code> 라고 표현하며 <code>그 사람들과 만났을 때는 바꾸려고 하거나 잘 지내보려고 하지 말아라</code> 라는 이야기를 한다. 말 그대로 교류를 최소화하며 되도록이면 피해야하는 사람을 굳이 내 사람 혹은 눈 안에 들려고 노력할 필요는 없다는 의미이다. 개인적으로도 이러한 사람들은 어느 집단에 가나 약간의 말만 주고받아도 충분히 파악이 되기 떄문에 되도록이면 피하는 것을 추천한다:) </p><p>두번째로 와닿는 말은 <code>이루고 싶은 게 있다면 이미 이룬 것처럼 연기하라</code>이다. 예전 어디선가 구글러들은 구글에 입사해서 구글러가 아니라, 이미 구글러였기 때문에 구글에 입사한 것이다라는 식의 글을 읽은 적이 있다. 정확하게 이러한 맥락을 아니였는데, 비슷한 의미였던 것으로 기억한다. (아무리 찾고자해도 너무 오래전이라 저는 검색에 실패했지만 혹시나 이 글을 읽는 분 중에 정확하게 아시는 분은 메일 주시면 조그마한 성의 표시라도 하고 싶습니다:) 아시는 분은 연락 바랍니다!) 이 글을 보고 구글러가 일하는 방식에 대해서 연구하고 실제 그들처럼 되고자 연기했던 적이 있었다 껄껄:) </p><p><img src="/images/review/soft-skill-review02_3.jpeg" alt="/images/review/soft-skill-review02_3.jpeg"></p><p>여기에서 이야기하고자 하는 핵심은 거짓 연기를 하라는 것이 아니라 그러한 태도로 살려고 노력한다면 원하는 것을 이룰 수 있다라는 것이다. 잠깐이나마의 연기를 통해 이러한 행동 및 마음가짐은 스스로가 프로패셔널이라는 생각을 불어넣어줄 뿐만 아니라 개개인에게 책임감과 의지를 불어넣기에 충분하다는 생각을 하게 되었다. 다만 중요한 것은 오만함과 자신감은 꼭 구분하여 그로 인해 본인 스스로를 과대평가하는 실수는 저지르지 않길 바란다.</p><p>세번째는 <code>셀프 마케팅</code>이라는 말이었다. 개발자 스스로 본인의 가치를 증명하며 재능을 돋보이게 해야한다는 의미이다. 요즘 우리는 자기 PR의 시대 속에 살고 있다고 말을 하면서도 실제로는 쑥쓰러워서 남들 앞에 나서는 걸 꺼려한다. 하지만 꼭 셀프 마케팅이라는 것을 거창하게 생각할 필요는 없다. 꼭 남들 앞에 나서지 않더라도, 이미 우리는 셀프 마케팅을 하고 있다. </p><p><img src="/images/review/soft-skill-review02_4.jpeg" alt="/images/review/soft-skill-review02_4.jpeg"></p><p>이력서 또한 지원한 회사에 ‘나는 귀사에 입사해서 이러한 것들을 해낼 수 있어요’ 라는 의미의 셀프 마케팅이 된다. 혹은 필자와 같이 소소하게나마 블로그를 운영하는 것 역시 셀프 마케팅일 수 있다. 필자의 경우 블로그를 운영하며 회사들의 러브콜을 받기도, 책 집필에 대한 제안을 받기도 했던 경험이 있어 개인적으로는 블로그를 운영하는 것에 대해서 적극 추천한다:) (형편없는 제 글을 보고 연락주신 담당자분들에게 굉장히 감사하다는 말씀을 드립니다 하하하:) ) 물론 우리가 알면서도 당하는 허위 광고식의 마케팅이나, 과대 포장이 이뤄져서는 안된다.</p><p><img src="/images/review/soft-skill-review03.png" alt="/images/review/soft-skill-review03.jpeg"></p><p>아마 한번쯤 당해본 사람이라면 막상 그 포장을 뜯어본 후, 엄청난 분노를 느꼈을 것이다 :(((( 이러한 분노를 또다른 누군가에게 전파하는 일이 없도록 조심하도록 하자 </p><p>네번째는 <code>학습 방법 익히기</code>이다. 책에서는 학습 방법에는 10단계의 과정을 통해 학습 방법에 대해서 표현하지만 본 포스팅에서 이야기하고자 하는 것은 그런 것이 아니다. 얼마 전 한 커뮤니티에서 고민 상담글로 이러한 글을 본적이 있다. ‘6개월동안 국비 지원 학원에서 열심히 공부한 후 신입으로 막상 취직해서 보니 자기가 너무 부족함을 깨달아서 다시 국비 지원을 통해 학원에서 학습을 하고자 한다.’ </p><p><img src="/images/review/soft-skill-review04.jpeg" alt="/images/review/soft-skill-review04.jpeg"></p><p>스스로가 부족하다는 고민은 개발자라면 공통적으로 하는 고민일 것이다. 여기에서 중요한 것은 학원에서 6개월 배우고도 부족함을 느꼈는데 다시 학원으로 돌아가려고 하는 글쓴이가 안타까웠다. 사실 필자의 경우 한번도 개발 관련해서 한번도 학원에서 배워본적이 없어 주관적인 의견일 수는 있겠지만 <code>학원은 앞으로 내가 공부해야할 것들에 대해 방향성만 제시</code>해준다고 생각한다. 그 이후부터는 지식에 대한 갈증은 스스로 해결해야 한다고 생각한다. </p><p>만약 위의 고민과 같이 시간이 지남에 따라 과거를 돌아보았는데 과거의 나와 현재의 내가 별 차이가 없다면 학습의 방법이 잘못된 것이 아닌가를 고민해보길 바란다.</p><p><img src="/images/review/soft-skill-review05.jpeg" alt="/images/review/soft-skill-review05.jpeg"></p><p>다섯번째는 <code>멘토</code>에 대한 내용이다. 멘토에 대한 사전적인 의미를 살펴보면 <code>정신적으로나 내면적으로 신뢰할 수 있는 상담 상대, 지도자, 스승님, 선생</code>이라는 뜻을 가진다. 많은 사람들이 멘토에 대한 의미를 헷갈려서 스승이라고 생각한다. </p><blockquote><p>멘토는 현명하고 신뢰할 수 있는 상담 상대, 지도자, 스승, 선생의 의미이다. 하지만 그렇다고 <code>멘토 = 스승</code>인 것은 아니다. 보통 스승이라고 하면 자신보다 나이가 많은 사람을 떠올리지만, 멘토의 경우는 동갑내기 친구가 될 수도 있다. 심지어는 자신보다 어린 사람이 멘토가 될 수 있다. 다시 말해 스승이 무엇인가를 <code>직접 가르쳐주는 사람</code>이라고 한다면 멘토는 <code>이끌어 주는 사람</code> 이라는 뜻이 강하다.</p></blockquote><p>[출처: <a href="https://namu.wiki/w/%EB%A9%98%ED%86%A0" target="_blank" rel="noopener">나무위키-멘토</a>]</p><p>물론 멘토가 기술적으로 뛰어나서 멘토에게 직접적으로 배울 수 있다면 굉장히 좋을 수 있다. 하지만 필자가 생각하는 멘토란 꼭 기술적으로 월등히 뛰어나서 직접적으로 기술을 가르쳐주는 사람보단 방향을 제시해줄 수 있는 사람이라고 생각한다. 물론 기술적으로도 가르침을 받으면서 방향을 제시해줄 수 있는 멘토를 만난다면 더할 나위 없이 좋을 것이다. 필자의 경우 지금까지 6명 정도의 멘토를 만났다. 그분들 중 필자와 고등학교 동창인 사람도 있고, 전직장 동료인 사람도 있으며 혹은 학교에서 우연치 않게 만난 분 그리고 같은 이커머스 종사자인 분도 있다. 지금까지 2년 가까이 거의 매주 뵙고 있는 멘토님 같이 기술적으로 뿐만 아니라 충분한 방향성을 제시해주셨던 분도 계시지만 앞에서 언급한 모든 분들이 기술적으로 월등히 뛰어나서 멘토인 것은 아니다. 물론 지금은 웹 개발로 전향하시긴 했지만 이분들 중에는 아예 웹 개발을 하지 않았던 분도 계신다. 이 분들을 만나면서 필자의 경우는 기술적인 성장도 성장이지만, 기본적인 마음 가짐에 대한 성장에 많은 도움을 받았다고 생각한다. 기술적으로 성장하는 것은 멘토가 없이도 성장이 가능하지만, 마음 가짐에 대한 성장은 혼자서 바꾸기가 쉽지 않다. 누군가의 본보기가 되여 ‘나도 언젠가는 저 사람의 모습처럼 누군가에게 비춰지고 싶다’라는 귀감을 사기란 정말 제대로 된 멘토가 없다면 쉽지 않다. 아마 이 글을 읽는 여러분이라면 한번쯤은 그런 사람을 만나보지 않았을까란 생각을 한다. 반대로 말하자면 꼭 기술적으로 월등하지 않아도 되지 우리 모두 누군가의 멘토가 될 수 있다는 의미이기도 하다. 누군가의 귀감이 되어 닮고 싶은 사람이 된다는 것이 멋진 일이 아닐 수 없다:) </p><iframe width="560" height="315" src="https://www.youtube.com/embed/SQmSI82vbIM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>개인적으로 추천하는 멘토 관련된 동영상이다. 혹시나 궁금 하신 분은 한번 보시는 것도 추천한다.</p><p>여섯번째는 <code>탈진 극복</code>에 대한 내용이다. 필자의 경우 회사에서 일하는 시간 40시간을 제외하더라도 평균적으로 주 30시간 정도는 관련 지식을 쌓기 위해 공부를 하고 있다. 물론 프로젝트로 인해 야근을 하는 경우는 주에 15시간을 못 채우는 경우도 있지만, 정시 퇴근해서 한두시간 저녁 먹고 늦장부린다는 가정하에 대략적으로 30시간이다. 그리고 주변을 살펴보면 필자 뿐만 아니라 대부분의 개발자들이 그렇게 하고 있다. (개인적으로 이러한 개발자들과 함께 한다는 것이 얼마나 행복한 것인지를 깨달았다) 하지만 이러다보면 제일 중요한 것이 바로 컨디션 조절이다. 그리고 이러한 컨디션 조절에 실패한 경우 흔희 번아웃(Burn out)에 빠졌다고 표현한다.</p><p><img src="/images/review/soft-skill-review06.jpeg" alt="/images/review/soft-skill-review06.jpeg"></p><p>제일 위험한 것이 바로 이 번아웃 증후군에 걸린 경우이다. 이러한 증후근을 <code>정신적 탈진</code> 이라는 표현을 한다. 이러한 정신적 탈진을 극복하기란 쉽지 않다. 책에서는 정신적 탈진을 <code>벽</code>이라고 표현하며 벽 너머에는 좋은 보상이 존재하며 탈진이라는 고통을 견뎌야지만 더 강한 에너지와 성취 동기가 생긴다고 이야기 한다. 누구나 한번쯤은 이러한 번아웃 상태에 빠져본 경험이 있을 것이며, 그 벽의 높이는 개개인에게 다르게 와닿을 수 있다. 누군가에게는 별것 아닌 것처럼 비춰져보일 수 있지만 나에게는 그 벽이 마치 오르지 못할 산보다 더 높을 수도 있다.</p><p> <img src="/images/review/soft-skill-review07.jpeg" alt="/images/review/soft-skill-review07.jpeg"></p><p>책에서도 <code>그냥 넘으면 된다</code>고 표현하지만 목표를 성취하고 나서의 성취감은 그 산을 넘을 수 있는 충분한 이유가 되지 않을까란 생각을 한다. 마치 과거 우리가 엄청 큰 고민이라고 여겼던 것이 시간 지나고 보면 별것 아닌 것처럼 웃어넘기듯, 사실 <code>벽</code>을 넘고나면 별거 아니었을 수도 있다. 그러한 사실은 벽을 넘어본 사람들만 알 수 있는 또다른 특권이지 않을까? :-)</p><p> <img src="/images/review/soft-skill-review08.jpeg" alt="/images/review/soft-skill-review08.jpeg"></p><h3 id="이-책의-모든-것이-다-만족스웠을까"><a href="#이-책의-모든-것이-다-만족스웠을까" class="headerlink" title="이 책의 모든 것이 다 만족스웠을까?"></a>이 책의 모든 것이 다 만족스웠을까?</h3><p>앞에서 설명했듯 책의 모든 내용이 만족스러울 수 없고 도움이 되지는 않았다. 하지만 그런 부분들은 부동산이나 주식 등과 같이 저자와 같이 미국에 사는 사람들에게는 도움이 될 수 있을 내용이다. 이런 부분을 제외한다면 대체적으로 필자에게는 또다른 영감과 열의를 일으켜준 책이었다. 앞에서도 말했듯이 이러한 아쉬운 부분들은 개인적인 견해일 뿐 읽는 사람에 따라서는 또다른 영감과 느낌을 줄 수 있을 것 같다라는 생각을 한다. 만약 나에게 앞에서 설명했던 멘토가 없다고 생각된다면 이 책을 또다른 정신적 멘토로 삼고 천천히 읽어보는 것도 굉장히 좋을 것 같다.</p><p> <img src="/images/review/soft-skill-review09.jpeg" alt="/images/review/soft-skill-review09.jpeg"></p><p>끝으로 책의 한 부분에서 표현하듯 이 책은 스스로의 발전을 원하는 사람에게 또다른 성장을 가져다 주기에 충분한 책이라는 생각을 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기전&quot;&gt;&lt;a href=&quot;#들어가기전&quot; class=&quot;headerlink&quot; title=&quot;들어가기전&quot;&gt;&lt;/a&gt;들어가기전&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;책에 대한 리뷰를 시작하기 전에 미리 이야기를 하자면 이 책에 대한 리뷰 작성은 
      
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="소프트스킬" scheme="http://blog.martinwork.co.kr/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%8A%A4%ED%82%AC/"/>
    
      <category term="인생전략71가지" scheme="http://blog.martinwork.co.kr/tags/%EC%9D%B8%EC%83%9D%EC%A0%84%EB%9E%B571%EA%B0%80%EC%A7%80/"/>
    
  </entry>
  
  <entry>
    <title>티모니언으로 살아가기</title>
    <link href="http://blog.martinwork.co.kr/review/2019/03/07/be-a-tmonian.html"/>
    <id>http://blog.martinwork.co.kr/review/2019/03/07/be-a-tmonian.html</id>
    <published>2019-03-06T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전"><a href="#들어가기전" class="headerlink" title="들어가기전"></a>들어가기전</h2><blockquote><p>글을 시작하기에 앞서 미리 밝히자면, 이 글은 글쓴이의 아주 주관적인 의견이며 팀에 따라 혹은 시간에 따라 달라질 수 있음을 미리 밝힌다. 글쓴이의 경우 과거 <a href="https://blog.martinwork.co.kr/review/2018/12/29/remembrance-in-2018.html">2018년의 회고</a>에서도 밝혔듯 회사에 대한 만족도가 높은 상태에서 작성했을테니 너무 회사의 분위기나 글쓴이의 리뷰를 모두 신뢰하지 않길 바란다.</p></blockquote><blockquote><p>필자는 2019년 8월 9일 부로 티몬이라는 회사를 떠났다. 현재 작성된 글을 작성할 당시와 퇴사한 시점에는 회사의 분위기도 많이 변화하였으며, 퇴사한 이후에도 점점더 바뀔 예정이다. 그러므로 그냥 과거의 티몬의 문화는 이랬구나 라는 정도로 가볍게 읽기를 권장한다. </p></blockquote><p>지금 현재 글쓴이의 경우 티켓몬스터의 표준화 랩에서 배송 파트의 Typescript와 React를 이용하여 프론트 개발을 담당하고 있습니다. 아직은 부족한 점이 많은 개발자이지만, 좋은 프로덕트를 만들기 위해 온갖 잔머리를 굴리며 얼마 있지 않은 지식을 쥐어짜고 있습니다. 구매 내역 개편 프로젝트 이후 최근에는 서비스의 안정을 위해 최대한 테스트 코드를 빡세게 작성하여 커버리지를 올리기 위해 고군분투하고 있습니다. </p><h3 id="티켓몬스터에-합류하기"><a href="#티켓몬스터에-합류하기" class="headerlink" title="티켓몬스터에 합류하기"></a>티켓몬스터에 합류하기</h3><p>티몬의 채용 절차는 홈워크 통과 후 1차 기술 면접, 2차 CTO 면접 그리고 티몬만의 특별한 면접인 써드아이 면접 이렇게 3가지 면접으로 이루어진다. 글쓴이의 경우 1차 기술 면접에 총 3분이 들어왔고, 면접은 그동안 해왔던 업무에 대한 이야기와 그 업무 속에서 어떠한 점을 개선해갔는지에 대한 이야기를 주로 했다. 개인적으로는 편안한 분위기에서 진행되었다. 1차를 합격하고 나면 바로 그 유명한 2차 면접인 CTO 면접을 보게 된다. 이미 면접을 들어가기 전부터 2차 면접에 대한 분위기에 대해 익히 들어 마음의 준비를 하고 갔다고 생각했었지만 막상 닥치고 보니.. 정말 쉽지 않았다. (분위기에 대해 궁금하신 분은 잡X래닛에 면접 관련 후기를 보면 많이 나와있다.) </p><p><img src="/images/review/be-a-tmonian01.png" alt="/images/review/be-a-tmonian01.png"></p><p>질문에 대한 대답을 거의 하지 못했다. 그렇게 대략 30-40분 정도의 2차 면접이 끝나면 바로 써드아이 면접을 보게 된다. 써드 아이는 같은 직군의 사람이 들어와서 보는 면접이 아니라 다른 직군 사람과의 면접으로 쉽게 생각해서 회사의 문화에 어울리는 사람인지 등을 보는 면접이라고 생각하면 될 것 같다. 나중에 들은 이야기이지만 2차 면접에서 멘탈이 깨진 많은 사람들이 써드 아이 면접에 임할 때 이미 떨어졌다고 가정하고 면접에 임하는 경우가 많다고 한다. 하지만 걱정할 필요 없다:) 입사하여 만난 대부분의 티모니언들이 2차에서 여러분과 똑같은 생각을 했다고 하니, 써드아이 면접에 임할 때도 최선을 다하길 바란다. 글쓴이 역시 마찬가지였다. 면접을 여러번 본 경험이 있다면 면접에서의 분위기만 봐도 내가 떨어졌는지 알 수 있는데, 이때가 바로 내가 떨어졌다고 생각된 때였다. 하지만 면접 끝나고 1시간도 채 되지 않아 최종 합격 전화를 받게 되었다. 여러분은 모두 뛰어난 사람이니 2차 면접에서 너무 기죽지 않았으면 하는 바램이다 :-) </p><p>최종 처우 협의 후 2018년 10월 15일, 티모니언으로 티켓몬스터에 합류하게 되었다. </p><p><img src="/images/review/be-a-tmonian02.png" alt="/images/review/be-a-tmonian02.png"></p><p>참고로 덧붙이자면 티켓몬스터의 임직원을 티모니언이라고 부른다. 입사 첫 날 업무 지원 센터에서 기다리게 되는데 그때 마주칠 수 있는 광경이다. </p><p><img src="/images/review/be-a-tmonian03.png" alt="/images/review/be-a-tmonian03.png"></p><p>그렇게 기다리다보면 인사팀과의 계약서 작성 후, 앞으로 일하게 될 자리를 배치 받게 되며 그 자리에는 웰컴 키트가 놓여 있다.</p><p><img src="/images/review/be-a-tmonian04.png" alt="/images/review/be-a-tmonian04.png"></p><p>사실 티몬이라는 회사를 좋아했던 가장 큰 이유는 바로 이러한 브랜딩이었던 것 같다. 문방사우 세트와 티몬 케릭터 나노 블럭과 티셔츠, 임시 사원증 등등이 들어있지만 개인적으로 제일 마음에 드는 것은 티셔츠였다. 물론 입사할 때가 아직은 반팔을 입을 때가 아니라 티셔츠를 입어보진 못했지만 여름이 되면 교복과 같이 입고 다니지 않을까 싶다 :-)/images/review/be-a-tmonian02.png</p><p>그리고 그 자리에는 윈도우 데스크탑이 놓여있다. 이 때 굉장히 괴리감이 들 수 있다. 맥북도 아니고 윈도우에 데스크탑이라니…. </p><p><img src="/images/review/be-a-tmonian05.png" alt="/images/review/be-a-tmonian05.png"></p><p>하지만 걱정 안해도 된다. 13인치의 맥북을 하나 더 준다. 윈도우는 처음 끄적끄적하다보면 킬일이 거의 없다. 물론 윈도우에서 개발하는 경우는 예외로 한다. </p><h3 id="티모니언이-누릴-수-있는-복지"><a href="#티모니언이-누릴-수-있는-복지" class="headerlink" title="티모니언이 누릴 수 있는 복지"></a>티모니언이 누릴 수 있는 복지</h3><p>아마 많은 분들이 궁금해 하는 것이 티모니언이 되면 누릴 수 있는 복지가 무엇인지에 대한 궁금점이지 않을까 싶다. </p><p>첫번째는 지하에 티모니언들만 이용할 수 있는 저렴한 카페가 있다는 점이다. 아메리카노가 1,000원 정도로 굉장히 저렴한 편이다.</p><p><img src="/images/review/be-a-tmonian06.png" alt="/images/review/be-a-tmonian06.png"></p><p>이전 회사에서도 사내 카페가 있었지만, 전 회사의 사내 카페보단 티몽 카페가 훨씬 넓고, 그 옆에 조그만하게나마 간단한 간식 거리를 살 수 있는 공간도 있다. </p><p>두번째는 헬스장에 대한 지원이다. 물론 하루에 한번으로 제한되어 있지만 듣기로는 회원권만 해도 가격이 어마어마하다고 한다. </p><p><img src="/images/review/be-a-tmonian07.png" alt="/images/review/be-a-tmonian07.png"></p><p>사실 글쓴이의 경우 운동을 좋아하지 않아 헬스장이 무슨 의미가 있거나 싶었지만, 그 헬스장과 함께 운영되는 사우나가 가고 나서 생각이 바뀌었다. 사우나의 시설이 엄청 좋아 점심시간에 식사를 일찍 하고 가서 피로를 푸는 사람들도 있으니 ‘아, 난 운동도 안하는데 이게 무슨 복지람’ 이라고 생각하시는 분들에게는 사우나를 추천한다:)</p><p>세번째로는 <code>슈퍼패스</code> 라는 특이한 형태의 휴가이다. 이러한 형태의 휴가를 운영하는 회사들도 종종 있는 것 같다. 이 휴가는 연차와는 별개로 지급되는 또다른 복지로서 반반차와 같이 2시간 휴가권이라고 보면 된다. 처음 입사했을 때는 상/하반기 각각 4개 정도였으나 지금은 현재 상/하반기 각각 6개로 변경되었다. 당일 바로 사용해도 무방하며 늦게 출근하든 조기 퇴근 하던 자유롭게 이용할 수 있다. 팀에 따라 다르겠지만 휴가 사용에 있어 큰 제약이 없기 때문에 언제든 편하게 사용할 수 있다. </p><p>네번째는 재택 근무이다. 개인적으로는 이 복지가 제일 마음에 든다. 아마 부서별로 다르겠지만 이 복지의 경우 CTO 조직에만 적용된다. 휴가와는 다르게 워킹데이로 2일전에는 미리 신청을 해야 하며, 재택 근무 후에는 별도의 보고서를 제출해야 한다. 종종 월요병이나 연휴로의 피로감으로 인해 회사까지 출근하기가 귀찮다라는 게 예상되는 날이면 미리 재택 근무를 신청하여 어디서든 편하게 근무를 할 수 있다:) 다만 한달에 2회라는 제약점이 있다는 것은 아쉽다. </p><p>이 외에도 화요일에 한해 모닝빵 제공이라던지, 명절 귀성버스 제공 등의 복지가 있지만 객관적으로 생각했을 때, 복지가 많다고 생각되진 않는다. 하지만 이러한 복지보다는 함께 일하는 동료들이 회사에서 제공해주는 최고의 복지가 아닐까란 생각을 한다. 물론 이또한 주관적이기 때문에 강조하지는 않는다:-)</p><h3 id="티몬의-개발-문화"><a href="#티몬의-개발-문화" class="headerlink" title="티몬의 개발 문화"></a>티몬의 개발 문화</h3><p>개인적으로 티몬의 개발 문화는 굉장히 자유로우며 기술 선택에 있어서도 제약이 많이 따른다고 생각하진 않는다. 물론 이러한 점은 팀에 따라서 다를 수 있다. 또한 팀에 따라서 사용하는 기술이 다를 수 있지만 스스로 책임을 질 수 있다면 새로운 기술을 도입함에 있어 큰 제약이 따르지 않는다. 자신의 도메인과 프로덕트에 대한 책임감은 당연하다는 입장에서 이정도의 제약은 새로운 기술의 도입에 큰 제약이라고 생각하진 않는다. 참고로 필자의 경우에는 프론트 개발팀 내에서 처음으로 타입스크립트를 도입하여 개발을 했다. 물론 새로운 기술을 도입함에 있어 같은 코드를 보는 팀원들간의 도입의 타당성에 대해서는 이야기를 해본 후 도입을 해야겠지만, 성장을 추구하는 티몬의 개발 문화에서 논리 없는 반대 의견에 부딪히는 경우는 거의 없었던 것 같다. 글쓴이가 속한 팀의 전체 연령이 타팀에 비해 전체적으로 연령대가 낮다보니 아마 더 열정에 넘쳐서 일수도 있을 것이다.</p><h3 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로.."></a>끝으로..</h3><p>이 글은 전 직장 동료의 <a href="https://jybaek.tistory.com/708" target="_blank" rel="noopener">위드이노베이션에 합류해서 젊은이로 살아가기</a> 라는 글을 본 후, 동의를 구하여 또다른 버전의 젊은이로 살아가기를 작성하게 되었습니다. 아마 회사에 입사하기 전 저와 같이 회사에 대해 궁금한 점이 많은 분들을 위해 조금이나마 도움이 되었으면 좋겠습니다. 혹은 그 전까지는 별 생각이 없다가 이 글을 본 후, <code>나도 한번 티모니언이 되어볼까?</code> 라는 생각을 하게 된다면 언제든 지원을 해보시는 것도 좋을 것 같습니다:) 이 외에도 이야기하지 못한 회사의 이야기들이 많을 테지만.. 지금 이 글을 작성하는 시간이 새벽이라 병든 닭처럼 졸며 쓰기 때문에 기억이 나질 않습니다… 혹시나 이 글에 나와있는 내용 혹은 이외에 궁금한 점이 있다면 메일 혹은 댓글 혹은 SNS을 통해 연락주시면 친절하게 답변드리도록 하겠습니다. 채용 공고에 대한 자세한 내용은 <a href="https://recruit.tmon.co.kr/recruit/list/000#page=1" target="_blank" rel="noopener">티켓몬스터 채용 공고 홈페이지</a>에서 확인 가능합니다. 긴 글 읽어주셔서 감사합니다:)</p>]]></content>
    
    <summary type="html">
    
      프론트 엔드 개발자의 티모니언으로 살아가기
    
    </summary>
    
      <category term="Review" scheme="http://blog.martinwork.co.kr/categories/review/"/>
    
    
      <category term="티켓몬스터" scheme="http://blog.martinwork.co.kr/tags/%ED%8B%B0%EC%BC%93%EB%AA%AC%EC%8A%A4%ED%84%B0/"/>
    
      <category term="TMON" scheme="http://blog.martinwork.co.kr/tags/tmon/"/>
    
      <category term="티모니언" scheme="http://blog.martinwork.co.kr/tags/%ED%8B%B0%EB%AA%A8%EB%8B%88%EC%96%B8/"/>
    
  </entry>
  
  <entry>
    <title>초보자의 GCP 사용기</title>
    <link href="http://blog.martinwork.co.kr/devops/2019/01/21/gcp-services-for-web-system.html"/>
    <id>http://blog.martinwork.co.kr/devops/2019/01/21/gcp-services-for-web-system.html</id>
    <published>2019-01-20T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h2><p>본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 <a href="https://www.facebook.com/WeGuardia?fref=gs&amp;__tn__=%2CdlC-R-R&amp;eid=ARCD0Yd6Ytb1Y_d63Sa9ZLatHm8yuJM-JFfwTq4CSs20_yszNcEoNYbFsKhrOUVjqYvwO5QD4a_65lAd&amp;hc_ref=ARTEl1G9KE36EgnIEOPf1tdGMjPLdlWR6m4ZGvEq0KgsRIf-qL3KY0ZE6WRqihAb8Us&amp;dti=540095029455098&amp;hc_location=group" target="_blank" rel="noopener">Jaeyeon Baek</a> 님과의 스터디에 대한 기록입니다. 또한 이 글은 <a href="http://www.yes24.com/24/goods/59229108" target="_blank" rel="noopener">구글 클라우드 플랫폼 입문</a> 이라는 도서에 대한 리뷰 및 개인적인 스터디 기록임을 미리 밝힙니다. </p><h3 id="Google-Compute-Engine-GCE"><a href="#Google-Compute-Engine-GCE" class="headerlink" title="Google Compute Engine(GCE)"></a>Google Compute Engine(GCE)</h3><p>GCE는 GCP에서 제공 하는 가상 머신 서비스이다. 일반적인 클라우드 환경에 비해 가상머신의 기동이 빠르고 초 단위로 청구가 과금이 되기 때문에 사용한 컴퓨팅 시간에 대해서만 요금을 지불하면 된다. 가상 머신의 두가지 타입의 메모리 인스턴스를 제공하는데 첫번째는 <code>사전 정의된 머신 유형</code>이다. 해당 유형을 사용하는 경우 마이크로 인스턴스에서부터 3.75TB까지 용도에 따라 사전 정의된 가상 머신 인스턴스를 사용할 수 있다. 두번째 타입은 <code>커스텀 머신 유형</code>이다. 이러한 경우는 사전 정의 머신 유형과는 다르게 vCPU나 메모리 등 구체적인 요구사항을 조정하여 이용할 수 있다. 만약 운용하려고 하는 서비스의 스펙에 대해서 명확하다면 커스텀 머신 유형을 이용하는 것이 비용 절감에도 도움이 된다. </p><p>GCE에서는 가상 머신에 접속이 가능한 두가지 종류의 저장소를 제공해준다. 첫번째는 최대 10TB의 <code>네트워크 저장소인 영구 디스크</code>이다. 영구 디스크는 SSD나 HDD 형식 중 하나를 선택해서 만들 수 있으며 해당 VM 인스턴스가 종료되어도 영구 디스크에 데이터가 유지가 되며 다른 가상머신 인스턴스에서 접근을 해도 이용할 수 있다. 두번째는 로컬 SSD이다. 로컬 SSD는 가상 머신 인스턴스를 호스팅하는 서버에 실제로 연결되므로 영구 디스크와 비교하여 IOPS(입출력 초당 작업수)가 매우 높고 레이턴시(지연시간)가 매우 낮다. vCPU가 1개 이상인 가상 머신에 최대 3TB의 로컬 SSD를 사용할 수 있다. </p><p>Debian, CentOS, CoreOS, Ununtu, Red Hat, Windows 등 원하는 OS를 실행시킬 수 있으며, 뿐만 아니라 GCP 커뮤니티에서 얻은 이미지나 혹은 스스로 만든 이미지를 사용할 수 있다. 이러한 GCE 가상 머신의 각각의 인스턴스는 독립된 네트워크로 접속된다. 물리적으로 다른 지역에 속한 인스턴스더라도 같은 네트워크에 접속되어있다면 내부 IP 주소를 통해 통신할 수 있다. </p><p>또한 GCE에서는 라이브 마이그레이션 지원한다. 라이브 마이그레이션은 말 그대로 어떤 물리 서버에서 운용 중인 가상머신을 다른 물리서버로 서비스 중단 없이 이동하는 기술이다. 만약 물리 서버의 유지 보수와 같이 데이터 센터 안에서 물리 서버를 정지해야하는 경우에는 해당 머신은 라이브 마이그레이션을 사용하여 다른 호스트 머신에 자동으로 이동된다.</p><h3 id="Google-Cloud-Storage"><a href="#Google-Cloud-Storage" class="headerlink" title="Google Cloud Storage"></a>Google Cloud Storage</h3><p>Cloud Storage는 높은 가용성과 내구성을 가진 오브젝트 저장소이다. 전 세계에 엣지 캐시를 가지기 때문에 사용자가 어디에 있든 빠르게 접근할 수 있다. Google App Engine이나 GCE로 동작하는 어플리케이션이나 BigQuery, Cloud Dataflow, Cloud Dataproc 등과 같은 데이터 처리 서비스의 백엔드 저장소로도 이용할 수 있다. 이러한 서비스는 아래의 4가지 저장소 등급의 가격의 서비스를 제공하니 목적에 따라 원하는 서비스를 선택하면 좋다.</p><p><img src="/images/devops/gcp-services-for-web-system01.png" alt="/images/devops/gcp-services-for-web-system01.png"></p><p>해당 서비스에서는 2가지 중요한 단어가 나온다. </p><h4 id="버킷이란-무엇인가"><a href="#버킷이란-무엇인가" class="headerlink" title="버킷이란 무엇인가"></a>버킷이란 무엇인가</h4><p>버킷이란 데이터를 담는 기본 컨테이너이다. Cloud Storage에 저장되는 모든 데이터는 버킷 안에 포함된다는 의미이기도 하다.</p><h4 id="오브젝트란-무엇인가"><a href="#오브젝트란-무엇인가" class="headerlink" title="오브젝트란 무엇인가"></a>오브젝트란 무엇인가</h4><p>Object는 Cloud Storage에 저장되는 개별 데이터 조각이다.</p><h3 id="Google-Cloud-SQL"><a href="#Google-Cloud-SQL" class="headerlink" title="Google Cloud SQL"></a>Google Cloud SQL</h3><p>Cloud SQL은 앞서 설명했던 RDBMS의 한 종류인 MySQL을 제공하는 완전 관리형 서비스이다. 해당 서비스에서는 MySQL의 실행 환경이 자동으로 만들어지고 백업이나 유지보수도 자동으로 이뤄진다.<br>MySQL의 완전 관리형 서비스<br>유지보수<br>어플리케이션에서 이용</p><hr><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://cloud.google.com/gcp/?hl=ko&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=japac-KR-all-ko-dr-bkws-all-super-trial-e-dr-1003987&amp;utm_content=text-ad-none-none-DEV_c-CRE_249736095777-ADGP_Hybrid%20%7C%20AW%20SEM%20%7C%20BKWS%20~%20T1%20%7C%20EXA%20%7C%20General%20%7C%201:1%20%7C%20KR%20%7C%20ko%20%7C%20cloud%20platform%20%7C%20google%20cloud%20platforms%20%7C%20en-KWID_43700030027797675-kwd-141425403689&amp;userloc_1009871&amp;utm_term=KW_google%20cloud%20platforms&amp;gclid=EAIaIQobChMI0O_h_L2A4AIVjRsqCh1TlgUqEAAYASAAEgKSiPD_BwE" target="_blank" rel="noopener">Google Cloud 공식홈페이지</a></li><li><a href="https://cloud.google.com/storage/docs/key-terms?hl=ko#buckets" target="_blank" rel="noopener">Google Cloud 공식홈페이지-Google Cloud Storage</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기-전&quot;&gt;&lt;a href=&quot;#들어가기-전&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전&quot;&gt;&lt;/a&gt;들어가기 전&lt;/h2&gt;&lt;p&gt;본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 &lt;a href=&quot;https://www.f
      
    
    </summary>
    
      <category term="Devops" scheme="http://blog.martinwork.co.kr/categories/devops/"/>
    
    
      <category term="Google Cloud Platform" scheme="http://blog.martinwork.co.kr/tags/google-cloud-platform/"/>
    
  </entry>
  
  <entry>
    <title>초보자의 GCP 사용기</title>
    <link href="http://blog.martinwork.co.kr/devops/2019/01/21/what-kind-of-web-service.html"/>
    <id>http://blog.martinwork.co.kr/devops/2019/01/21/what-kind-of-web-service.html</id>
    <published>2019-01-20T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기-전"><a href="#들어가기-전" class="headerlink" title="들어가기 전"></a>들어가기 전</h2><p>본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 <a href="https://www.facebook.com/WeGuardia?fref=gs&amp;__tn__=%2CdlC-R-R&amp;eid=ARCD0Yd6Ytb1Y_d63Sa9ZLatHm8yuJM-JFfwTq4CSs20_yszNcEoNYbFsKhrOUVjqYvwO5QD4a_65lAd&amp;hc_ref=ARTEl1G9KE36EgnIEOPf1tdGMjPLdlWR6m4ZGvEq0KgsRIf-qL3KY0ZE6WRqihAb8Us&amp;dti=540095029455098&amp;hc_location=group" target="_blank" rel="noopener">Jaeyeon Baek</a> 님과의 스터디에 대한 기록입니다. 또한 이 글은 <a href="http://www.yes24.com/24/goods/59229108" target="_blank" rel="noopener">구글 클라우드 플랫폼 입문</a> 이라는 도서에 대한 리뷰 및 개인적인 스터디 기록임을 미리 밝힙니다. </p><h3 id="웹-서비스의-종류"><a href="#웹-서비스의-종류" class="headerlink" title="웹 서비스의 종류"></a>웹 서비스의 종류</h3><p>우리가 주로 이용하는 클라우드 서비스, 예를 들어 AWS나 GCP 혹은 Azure와 같은 서비스를 이용하기 전에 기본적으로 알아야 할 것이 있다. 그것이 바로  어플리케이션의 종류와 동작하는 방식 등이다. 그 안에는 웹 어플리케이션과 앱 어플리케이션, HTTP 통신 규약 혹은 데이터베이스에 대한 것들이 포함되어 있다. 이러한 대부분의 것들이 앞으로 학습할 GCP 공부에 도움이 되길 바라며 간단히 정리를 해보았다.</p><p>우리가 주로 사용하는 많은 서비스들은 거의 대부분 웹 어플리케이션이나 앱 어플리케이션에 포함되는 경우가 많다. 쇼핑을 위한 이커머스 서비스, 정보 검색을 위한 포털 서비스, 숙박을 위한 배달 앱 서비스 등등 편의를 위한 서비스를 제공해주는 많은 훌륭한 회사들이 많다. 우리가 PC나 모바일 웹에서 도메인을 기반으로 검색하고 들어가는 사이트들은 거의 <code>웹 어플리케이션</code>인 경우가 많다. 반대로 앱스토어에서 다운받은 어플리케이션의 경우에는 <code>네이티브 어플리케이션</code>인 경우가 많다. 하지만 앱스토어에서 받았다고 하더라도 모든 어플리케이션이 네이티브 어플리케이션은 아니다. 요즘은 네이티브 어플리케이션과 반응형 웹을 이용하여 <code>하이브리드 형태</code>로 제작하는 경우도 많다. 그러한 경우는 물론 여러가지 이유가 있겠지만, 개인적으로 생각했을 때 가장 큰 이유 중 하나는 <code>플랫폼 별 리소스</code> 를 집중적으로 관리하기 위해서가 아닐까란 생각을 한다. 네이티브 앱 개발자도 IOS 개발자가 있고 Android 개발자가 있다. 물론 각자 사용하는 프레임워크도 다르고 언어도 다를 수 있다. 이런식으로 플랫폼 별로 리소스를 별도로 관리를 해준다면 버전 관리, 동일한 사용자 경험 부여 등의 문제가 생길 수 있다. </p><p><img src="/images/devops/what-kind-of-web-service01.png" alt="/images/devops/what-kind-of-web-service01.png"></p><p>이러한 여러 가지 플랫폼들을 공통적으로 백엔드(Back-end)서버 혹은 API 서버라고 불리는 웹 서버와 요청(Request)와 응답(Response)을 주고 받는다. </p><p><img src="/images/devops/what-kind-of-web-service02.png" alt="/images/devops/what-kind-of-web-service02.png"></p><h3 id="URL와-Method의-종류"><a href="#URL와-Method의-종류" class="headerlink" title="URL와 Method의 종류"></a>URL와 Method의 종류</h3><p>이러한 API 서버는 상황에 따라서는 여러 대일수도 있습니다. 클라이언트에서는 어떠한 자원이 필요한지를 알고 원하는 자원에 대한 요청을 합니다. 그러한 원하는 자원은 URL(Uniform Resource Locator)을 지정하게 됩니다.  </p><p><img src="/images/devops/what-kind-of-web-service03.png" alt="/images/devops/what-kind-of-web-service03.png"></p><p>위의 URL 중 사용자 이름(user)와 비밀번호(password), 그리고 포트번호(port) 등 아마 생소한 것들도 있을 것이다. 우리가 URL을 통해 이용하는 많은 웹 사이트들의 경우 사용자 이름이나 비밀번호 같은 경우 생략 되어져있다. 또는 포트번호와 같이 기본 포트(80)로 지정이 되어있거나 포트 포워딩을 통해 우리가 URL만 보고는 쉽게 유추할 수 없는 경우도 많다.</p><p>단순히 이러한 URL만 있다고 해서 모든 요청을 API서버에서 알아서 할 순 없습니다. 그래서 우리는 요청에 대한 메소드(Method)와 함께 요청을 보냅니다. 보통 많이 사용하는 Method는 <code>Get, Post, Put, Delete</code> 등이 있으며 종종 <code>Option</code> 메소드도 볼 수 있다. 이러한 메소드와 URI(Uniform Resource Identifier)을 통해 RESTful API 설계를 많이 한다. RESTful API에 대한 이야기는 해당 포스팅 주제가 아니므로 별도로 다루진 않는다. 궁금한 경우는 <a href="https://blog.martinwork.co.kr/theory/2017/11/11/what-is-restful-api.html">여기</a>에서 확인할 수 있다.</p><p>각 메소드들에 대해서 간단히 설명을 하면 다음과 같이 설명할 수 있다.</p><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description              </th></tr></thead><tbody><tr><td style="text-align:left">Get</td><td style="text-align:left">해당 자원을 조회할 때 사용</td></tr><tr><td style="text-align:left">Post</td><td style="text-align:left">해당 자원을 생할 때 사용 </td></tr><tr><td style="text-align:left">Put</td><td style="text-align:left">해당 자원을 수정할 때 사용 </td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left">해당 자원을 삭제할 때 사용 </td></tr><tr><td style="text-align:left">Option</td><td style="text-align:left">Preflight(사전 전달)의 역할을 함으로써 해당 요청 전 해당 자원에 대한 지원여부를 확인할 때 사용</td></tr></tbody></table><p>이러한 요청에 대한 결과값은 상태(Status)와 함께 응답을 준다.</p><h3 id="Status-규약"><a href="#Status-규약" class="headerlink" title="Status 규약"></a>Status 규약</h3><p>HTTP Request status codes HTTP 상태 코드는 특정 HTTP 요청에 대한 상태를 나타내준다. HTTP 표쥰 규약의 경우 3자리수로 이루어져 있으며 각자 대역별로 추상적인 의미를 가지게 된다.</p><h4 id="Success-status-2XX"><a href="#Success-status-2XX" class="headerlink" title="Success status(2XX)"></a>Success status(2XX)</h4><p>해당 상태들은 클라이언트에서 요청한 동작을 수신하여 이해해서 성공적으로 처리했음을 의미 한다. </p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">200</td><td style="text-align:left">OK</td><td style="text-align:left">요청 성공(단, HTTP method에 따라 성공 의미는 다름)</td></tr><tr><td style="text-align:left">201</td><td style="text-align:left">Created</td><td style="text-align:left">요청이 성공하여, 새로운 리소스가 생성(put, post methods에 해당)</td></tr><tr><td style="text-align:left">202</td><td style="text-align:left">Accepted</td><td style="text-align:left">요청을 성공적으로 수신하였으나 처리되지 않음. 비동기 처리에서 사용하며 response 에는 결과가 포함되지 않을 수도 있음.</td></tr></tbody></table><h3 id="Redirect-status-3xx"><a href="#Redirect-status-3xx" class="headerlink" title="Redirect status(3xx)"></a>Redirect status(3xx)</h3><p>해당 상태들을 클라이언트에서 요청을 한 후, 그 요청을 마무리하기 추가적인 액션을 취해야 함을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">301</td><td style="text-align:left">Moved Permanently</td><td style="text-align:left">요청한 리소스의 URI가 영구적으로 변경되었음을 의미하며, 새로운 URI를 response 에 포함.</td></tr><tr><td style="text-align:left">302</td><td style="text-align:left">Found</td><td style="text-align:left">요청한 리소스의 URI가 임시적으로 변경되었으며, 이후에는 요청한 리소스의 URI 로 돌아올 예정임. </td></tr></tbody></table><h3 id="Error-in-client-status-4xx"><a href="#Error-in-client-status-4xx" class="headerlink" title="Error in client status(4xx)"></a>Error in client status(4xx)</h3><p>해당 상태는 클라이언트의 요청에 뭔가의 오류가 있음을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">400</td><td style="text-align:left">Bad Request</td><td style="text-align:left">클라이언트에 보낸 요청을 서버에서 이해할 수 없음</td></tr><tr><td style="text-align:left">401</td><td style="text-align:left">Unauthorized</td><td style="text-align:left">요청한 리소스에 대한 권한이 없음을 의미(인증되지 않은 경우) </td></tr><tr><td style="text-align:left">403</td><td style="text-align:left">Forbidden</td><td style="text-align:left">요청한 리소스에 대한 접근 권한이 없음을 의미하며 401과 다른점은 서버에서는 요청자를 알고 있으나, 인증여부 상관없이 비공개인 경우</td></tr><tr><td style="text-align:left">404</td><td style="text-align:left">Not Found</td><td style="text-align:left">요청한 리소스의 URI가 없음을 의미</td></tr><tr><td style="text-align:left">405</td><td style="text-align:left">Method Not Allowed</td><td style="text-align:left">요청한 리소스의 URI에 요청한 메소드가 정의되어 있지 않을 경우</td></tr></tbody></table><h3 id="Error-in-server-status-5xx"><a href="#Error-in-server-status-5xx" class="headerlink" title="Error in server status(5xx)"></a>Error in server status(5xx)</h3><p>4xx는 클라이언트의 오류일 경우라고 한다면, 해당 상태는 서버에 오류가 있음을 의미한다.</p><table><thead><tr><th style="text-align:left">Status</th><th style="text-align:left">Message</th><th style="text-align:left">Information</th></tr></thead><tbody><tr><td style="text-align:left">500</td><td style="text-align:left">Internal Server Error</td><td style="text-align:left">서버 내부에 오류가 있어 요청을 수행할 수 없음 </td></tr><tr><td style="text-align:left">502</td><td style="text-align:left">Bad Gateway</td><td style="text-align:left">서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받음</td></tr><tr><td style="text-align:left">503</td><td style="text-align:left">Service Unavailable</td><td style="text-align:left">서버가 가부하에 걸렸거나, 유지보수를 위하여 접근이 거부</td></tr></tbody></table><h3 id="데이터-베이스"><a href="#데이터-베이스" class="headerlink" title="데이터 베이스"></a>데이터 베이스</h3><p>이전까지 클라이언트와 API서버와의 커뮤니케이션 과정을 살펴보았다. 이제는 어플리케이션의 보다더 뒷단을 살펴볼 필요가 있다. 클라이언트와 API서버가 서로 리소스에 대한 커뮤니케이션 하는 과정에서 일어나는 대부분의 행동은 데이터 베이스에 저장이 된다.</p><p><img src="/images/devops/what-kind-of-web-service04.png" alt="/images/devops/what-kind-of-web-service04.png"></p><p>이러한 데이터 베이스에는 크게 두가지 종류가 있다. </p><h3 id="관계형-데이터-베이스-관리-시스템-RDBMS"><a href="#관계형-데이터-베이스-관리-시스템-RDBMS" class="headerlink" title="관계형 데이터 베이스 관리 시스템 RDBMS"></a>관계형 데이터 베이스 관리 시스템 RDBMS</h3><p>아마 데이터베이스를 사용할 때 제일 많이 이용하는 데이터 베이스가 아닐까 싶다. 데이터베이스 하면 대표적으로 생각나는 Mysql도 이 안에 해당한다. RDBMS는 Relational Database Management System의 약자로서 스프레드시트 같은 형태의 데이터 베이스를 생각하면 이해하기 쉽다. RDBMS는 IBM 산호세 연구소의 <a href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%93%9C%EA%B1%B0_F._%EC%BB%A4%EB%93%9C" target="_blank" rel="noopener">에드거 F. 커드</a>가 도입한 관계형 모델을 기반으로 한다. 관계형 데이터 베이스는 만들거나 이용하기가 쉽다. 처음 데이터 베이스는 만든 후 관련되는 응용 프로그램들은 변경하지 않고, 새로운 데이터 항목을 데이터 베이스에 추가 할 수 있다(파일이나 네트웍 데이터베이스 등, 그 이전의 데이터베이스들은 항목이 수정되면, 그 데이터베이스를 사용하는 모든 응용 프로그램도 함께 수정해야하는 어려움이 있었다). </p><p>관계형 데이터베이스는 미리 정의된 내용에 따라 테이블들이 구성되는데, 각 테이블은 데이터 종류나 성격에 따라 여러 개의 컬럼(column)이 포함될 수 있다. 예를 들어, 주문거래 데이터베이스에는 <code>성명, 주소, 전화번호</code> 등의 컬럼 항목으로 구성된 테이블과 또한 주문내용(제품, 고객, 일자, 판매가격 등)을 나타내는 테이블이 포함될 수 있다. 이러한 데이터는 사용자의 필요에 맞는 형태로 데이터베이스의 내용을 볼 수 있다. 또한, 관계형 데이터베이스를 구축할 때 데이터 컬럼이 가질 수 있는 값의 범위(domain)나, 그 값에 적용될 수 있는 제한사항(constraint)을 정의할 수 있다. 예를 들어, 고객의 성명을 빈 칸으로 남겨 놓지 못하게 한다거나, 판매가격에는 마이너스(-) 값이 올 수 없도록 제한할 수 있다. 관계형 데이터베이스를 정의하게 되면 그 테이블이나 컬럼, 도메인 및 제한사항에 대한 내용을 가진 메타 데이터(metadata) 테이블이 함께 만들어진다. 이러한 RDBMS를 GCP에서는 <code>Cloud SQL</code>이라는 서비스를 통해 이용할 수 있다.</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>관계형 데이터 베이스와는 전혀 다른 형태의 데이터 베이스이다. NoSQL은 오랫동안 사용되어진 관계형 데이터와는 다르게 2000년대 초반부터 떠오르기 시작하였다. 과거 빅데이터의 등장에 따라 RDBMS만을 이용해서는 데이터를 처리하는 데 드는 비용의 증가를 막을 수 없었다. 데이터의 양과 트래픽을 한 대에서 실행되도록 설계된 RDBMS의 <code>Scale-up 비용</code>이 기하급수적으로 증가했기 때문이다. 이러한 상황에서 <code>Scale-out</code>을 목표로 등장한 데이터 베이스가 바로 NoSQL이다. 대표적인 데이터베이스로는 Redis나 MongoDB가 포함된다. 주된 데이터 모델의 방식은 KVS(Key-Value Store) 방식이다. </p><p>NoSQL은 대규모의 데이터와 트래픽을 위해 설계되었기 때문에 많은 양의 데이터를 다뤄야하는 채팅 데이터나 로그 데이터를 저장하는 데 용이하다. NoSQL은 관계형 데이터 베이스에 비해 유연한 데이터 모델을 사용하며  비정형 데이터를 다룰 때 그 빛을 바랄 수 있다. 또한 key-value 방식의 데이터 모델을 사용하기에 응답 속도나 처리 효율에 있어 뛰어난 성능을 보여준다. 이러한 NoSQL을 GCP에서는 Cloud DataStore와 Cloud Bigtable을 통해 서비스하고 있다.</p><h3 id="SQL문"><a href="#SQL문" class="headerlink" title="SQL문"></a>SQL문</h3><p>위에서 살펴본 SQL문을 통해 데이터에 접근할 수 있습니다.</p><ol><li>데이터 정의 언어(DDL: Data Definition Language)<br><code>데이터를 저장하는 구조를 정의</code>하기 위한 명령어로서 <code>CREATE문(생성)</code>, <code>DROP문(삭제)</code>, <code>ALERT문(변경)</code>이 이에 해당한다.</li><li>데이터 조작 언어(DML: Data Manipulation Language)<br><code>데이터를 조작</code>하기 위한 명령어로서, <code>UPDATE문(변경)</code>, <code>DELETE문(삭제)</code>, <code>INSERT문(추가)</code>, <code>SELECT문(조회)</code>가 이에 해당한다.</li><li>데이터 제어 언어(DCL: Data Control Language)<br><code>데이터베이스에 접근 권한 제어나 상태 관리</code>를 하기 위한 명령어로서, 사용자에게 권한을 부여하거나 트랜잭션을 처리할 때 주로 사용합니다.</li></ol><p>사실 SQL문 자체를 많이 쓸 일이 없어서일 수도 있겠지만 다른 명령어는 익숙해도 트랜잭션이라는 것이 굉장히 생소했다. 그렇다면 트랜잭션이란 무엇일까?</p><h3 id="트랜잭션-Transaction-이란"><a href="#트랜잭션-Transaction-이란" class="headerlink" title="트랜잭션(Transaction)이란?"></a>트랜잭션(Transaction)이란?</h3><p>위키 백괴에 따르면 데이터베이스 트랜젝션은 <code>데이터베이스 관리 시스템 또는 유사한 시스템에서 상호 작용의 단위</code> 라고 표현하고 있다. 어려운 이 문장을 풀어서 설명하면 <code>데이터베이스 안의 데이터를 변경할 때 하나의 단위로 묶어서 관리하는 구조</code>를 일컫는다. 많은 블로그들과 책에서도 은행의 계좌 시스템이라는 굉장히 좋은 예시로 들어 표현하고 있어 필자도 그림으로 그려 가며 표현해보고자 한다. </p><p>만약 다음의 그림과 같이 Man이 Woman에게 $10를 계좌이체 해준다고 가정해보자. </p><p><img src="/images/devops/what-kind-of-web-service05.png" alt="/images/devops/what-kind-of-web-service05.png"></p><p>그렇다면 Man의 계좌에 대한 데이터는 -$10에 대한 변경이 일어날 것이고, Woman의 계좌 데이터에서는 +$10에 대한 변경이 일어날 것이다. 이러한 일련의 과정이 하나의 단위로 묶여서 일어나야 한다. 이러한 구조를 트랜잭션이라고 표현한다. 이러한 일련의 과정이 모두 성공적으로 처리가 완료되어 완료된 경우를 <code>COMMIT</code>이라고 표현하고, 만약 하나라도 실패하여 모든 처리를 되돌리는 과정을 <code>ROLLBACK</code>이라고 표현한다. 이러한 특성으로 인해 RDBMS는 아래의 ACID 특성을 필요하다.</p><ol><li>Atomicity(원자성)<br>트랜잭션에 포함된 처리가 모두 처리가 되거나 혹은 모두 취소가 되어야 한다.</li><li>Consistency(일관성)<br>트랜잭셕 처리 전후로, 모든 데이터의 정합성이 지켜지며, 모순이 없어야 한다.</li><li>Isolation(독립성)<br>트랜잭션 안에서 처리 중인 처리가 다른 처리에 영향을 미치지 않아야 한다.</li><li>Durability(내구성)<br>트랜잭션이 끝났다면 시스템 장애가 생겨도 데이터를 잃지 않아야 한다.</li></ol><h3 id="가상화-서버"><a href="#가상화-서버" class="headerlink" title="가상화 서버"></a>가상화 서버</h3><p>아마도 MacOS를 사용하는 사용자라면 쉽게 이러한 가상화 서버를 접할 수 있을 것이다. 혹은 다양한 OS에서 어플리케이션을 테스트해야하는 경우에도 접해볼 수 있다. 이러한 가상화 서버는 한 대의 물리 서버를 여러 개의 가상 서버로 나눠서 이용하는 것을 일컫는다. 이러한 가상화 서버는 3개지 형태로 분류할 수 있다.</p><h4 id="1-호스트형-가상화"><a href="#1-호스트형-가상화" class="headerlink" title="1. 호스트형 가상화"></a>1. 호스트형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service06.png" alt="/images/devops/what-kind-of-web-service06.png"></p><p>호스트형 가상화는 하드웨어 위의 기반이 되는 호스트 OS(Window, Mac 등)가 존재하며 그 호스트 OS에 가상화 소프트웨어를 설치한다. 이렇게 설치된 가상화 소프트웨어를 통해 서버 하드웨어를 에뮬레이션하는 것이다. 서버 하드웨어를 에뮬레이트하기 때문에 필요한 여분의 CPU 자원,디스크 용량, 메모리 사용량 등과 같은 오버헤드가 커질 수 있지만 게스트 OS에 대한 제약이 없어 대부분의 OS를 동작시킬 수 있다. 이러한 소프트 웨어는 VMware, VirtualBox, Parallels 등이 포함된다.</p><h4 id="2-하이퍼바이저형-가상화"><a href="#2-하이퍼바이저형-가상화" class="headerlink" title="2. 하이퍼바이저형 가상화"></a>2. 하이퍼바이저형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service07.png" alt="/images/devops/what-kind-of-web-service07.png"></p><p>하이퍼바이저형 가상화는 VMM(Virtual Machine Monitor)을 하드웨어 위에서 직접 동작시키기 떄문에 호스트OS 설치가 필요 없다. 호스트 OS에 할당할 리소스가 없기에 호스트형 가상화보다는 오버헤드가 적은게 특징이며 하이퍼바이저가 하드웨어를 직접 제어하기 때문에 리소르르 효율적으로 사용할 수 있습니다. Linux KVM이나 Hyper-v 등이 해당합니다.</p><h4 id="3-컨테이너형-가상화"><a href="#3-컨테이너형-가상화" class="headerlink" title="3. 컨테이너형 가상화"></a>3. 컨테이너형 가상화</h4><p><img src="/images/devops/what-kind-of-web-service08.png" alt="/images/devops/what-kind-of-web-service08.png"></p><p>마지막은 컨테이너형 가상화이다. 앞의 두 가상화 서버와는 다르게 각자의 가상환경에 게스트 OS가 존재하지 않기 때문에 오버헤드가 적으며 가볍고 빠르게 동작하는 것이 특징이다. 호스트 OS위에 컨테이너 기반으로 분리해두고 각가에 독립된 OS 환경을 제공해준다. 이러한 컨테이너는 HostOS를 다른 컨테이너들과 공유한다. Docker가 대표적인 컨테이너 가상화 기술을 사용합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;들어가기-전&quot;&gt;&lt;a href=&quot;#들어가기-전&quot; class=&quot;headerlink&quot; title=&quot;들어가기 전&quot;&gt;&lt;/a&gt;들어가기 전&lt;/h2&gt;&lt;p&gt;본 포스팅은 구글 클라우드 플랫폼 사용자 그룹의 운영진인 &lt;a href=&quot;https://www.f
      
    
    </summary>
    
      <category term="Devops" scheme="http://blog.martinwork.co.kr/categories/devops/"/>
    
    
      <category term="Google Cloud Platform" scheme="http://blog.martinwork.co.kr/tags/google-cloud-platform/"/>
    
  </entry>
  
  <entry>
    <title>최고의 집합 알고리즘</title>
    <link href="http://blog.martinwork.co.kr/theory/2019/01/19/top-group-algorithm.html"/>
    <id>http://blog.martinwork.co.kr/theory/2019/01/19/top-group-algorithm.html</id>
    <published>2019-01-18T15:50:51.000Z</published>
    <updated>2019-09-06T14:51:07.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>본 문제는 <a href="http://programmers.co.kr" target="_blank" rel="noopener">프로그래머스</a>라는 알고리즘 사이트에서 가져온 문제입니다. 알고리즘을 푸는 모든 과정은 자바스크립트로 이뤄졌습니다. </p><p>먼저 이 문제는 다음과 같다.</p><blockquote><p>자연수 n 개로 이루어진 집합 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다. 최고의 집합은 n개의 원소의 합은 S가 되는 수의 집합입니다. 이러한 조건을 만족하며 n개의 수의 곱이 최대가 되는 집합입니다.</p></blockquote><p>예를 들어 각각의 원소 갯수 n을 2라고 가정하고 원소의 합 S를 9라고 가면 하면 경우의 수는 [1, 8], [2,7], [3,6], [4,5] 등으로 총 4개가 될 수 있다. 그 중에서 최고의 집합은 [4,5]인 집합이다. 예시를 하나 더 들어보자. 원소의 갯수 n은 2이라고 가정하고 원소의 합 S를 13이라고 가정하면 경우의 수는 [1,12], [2,11], [3,10], [4,9], [5,8], [6,7] 이다. 6개의 집합 중 최고의 집합은 [6,7]이 해당한다. </p><h3 id="문제-해결-방법-유추"><a href="#문제-해결-방법-유추" class="headerlink" title="문제 해결 방법 유추"></a>문제 해결 방법 유추</h3><p>위에서의 두가지 공통점으로는 최고의 집합은 두수의 차가 최소일 경우이다 라는 가정을 얻을 수 있다. </p><p>그러한 가정은 다음과 같은 방법으로 증명할 수 있다. 간단하게 예시를 들기 위해 n은 2개라고 가정한다. 자연수 a와 b의 합이 S라고 가정했을 때, a와 b의 관계를 구하기 위해 a-b과 a+b를 비교를 한다. </p><p><img src="/images/algorithm/top-to-group01.png" alt="/images/algorithm/top-to-group01.png"></p><p>두 값중 a+b의 제곱근이 a-b의 제곱근보다는 큰 값일 테니 전자에서 후자의 값을 빼준다.</p><p><img src="/images/algorithm/top-to-group02.png" alt="/images/algorithm/top-to-group02.png"></p><p>두 값을 서로 비교해서 빼면 결국에 다음과 같이 나온다.</p><p><img src="/images/algorithm/top-to-group03.png" alt="/images/algorithm/top-to-group03.png"></p><p>우리가 구하고자 하는 ab 값을 구하기 위해 오른쪽과 왼쪽의 값을 4로 나누어 준다.</p><p><img src="/images/algorithm/top-to-group04.png" alt="/images/algorithm/top-to-group04.png"></p><p>그렇게 나누고 나면 우리가 원하는 ab의 값이 나오고 다음의 그림과 같이 a-b 의 값이 작을 수록 ab의 값이 커지는 것을 알 수 있다.</p><p><img src="/images/algorithm/top-to-group05.png" alt="/images/algorithm/top-to-group05.png"></p><p>결국 이 문제에서 최다의 ab 값을 구하기 위해서는 n개의 수의 차가 적을수록 원하는 최대값을 구할 수 있다.</p><h3 id="문제-해결"><a href="#문제-해결" class="headerlink" title="문제 해결"></a>문제 해결</h3><p>먼저 n개의 자연수가 n개의 자연수의 합 S 보다 클 경우를 대비하는 방어코드를 추가했다. n개의 자연수의 합이 S보다 작을 경우는 문제에서 주어진 경우와 같이 -1에 해당하는 배열을 반환해준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 합이 S인 서로 차이가 적은 n개의 자연수를 찾는 것이기 때문에 S를 n으로 나누어 준다. 나눈 값을 그대로 넣어주면 소수점이 나온다. 하지만 우리가 구하고자 하는 값은 자연수 이기에 반올림 혹은 내림 등 중 하나를 선택해야 한다. 여기에서 주목할 것은 우리가 구하고자 하는 값은 올림차순으로 이루어진 집합이기 때문에 여기에서는 내림을 선택해준다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 하나씩 구해서 answer이라는 배열에 넣으면 구해야할 자연수 n개의 갯수는 점점 줄어든다.</span></span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">Math</span>.floor(s/(n-i));</span><br><span class="line">    <span class="comment">// 구한 값을 answer 배열에 담아준다.</span></span><br><span class="line">    answer.push(number);</span><br><span class="line">    <span class="comment">// 전체의 갯수에서 구한 값을 제외시켜준후, 다시 배열을 시작한다.</span></span><br><span class="line">    s = s - number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 내림차순으로 이루어진 집합을 구하고자 한다면 다음과 같이 구할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> answer = [];</span><br><span class="line">  <span class="keyword">if</span> (n &gt; s) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">Math</span>.round(s/(n-i));</span><br><span class="line">    answer.push(number);</span><br><span class="line">    s = s - number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;문제-설명&quot;&gt;&lt;a href=&quot;#문제-설명&quot; class=&quot;headerlink&quot; title=&quot;문제 설명&quot;&gt;&lt;/a&gt;문제 설명&lt;/h2&gt;&lt;p&gt;본 문제는 &lt;a href=&quot;http://programmers.co.kr&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="Theory" scheme="http://blog.martinwork.co.kr/categories/theory/"/>
    
    
      <category term="프로그래머스" scheme="http://blog.martinwork.co.kr/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"/>
    
      <category term="최고의집합" scheme="http://blog.martinwork.co.kr/tags/%EC%B5%9C%EA%B3%A0%EC%9D%98%EC%A7%91%ED%95%A9/"/>
    
  </entry>
  
</feed>
